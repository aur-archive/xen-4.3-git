diff -Naur xen/Config.mk xen-b/Config.mk
--- xen/Config.mk	2013-05-30 10:38:28.125040872 -0600
+++ xen-b/Config.mk	2013-05-30 18:15:29.951707540 -0600
@@ -7,7 +7,6 @@
 # fallback for older make
 realpath = $(wildcard $(foreach file,$(1),$(shell cd -P $(dir $(file)) && echo "$$PWD/$(notdir $(file))")))
 
--include $(XEN_ROOT)/.config
 
 # A debug build of Xen and tools?
 debug ?= y
@@ -29,7 +28,7 @@
 
 # Tools to run on system hosting the build
 HOSTCC      = gcc
-HOSTCFLAGS  = -Wall -Werror -Wstrict-prototypes -O2 -fomit-frame-pointer
+HOSTCFLAGS  = -Wstrict-prototypes -O2 -fomit-frame-pointer
 HOSTCFLAGS += -fno-strict-aliasing
 
 DISTDIR     ?= $(XEN_ROOT)/dist
@@ -165,7 +164,7 @@
 
 CFLAGS += -std=gnu99
 
-CFLAGS += -Wall -Wstrict-prototypes
+CFLAGS += -Wstrict-prototypes
 
 # Clang complains about macros that expand to 'if ( ( foo == bar ) ) ...'
 # and is over-zealous with the printf format lint
diff -Naur xen/extras/mini-os/lib/math.c xen-b/extras/mini-os/lib/math.c
--- xen/extras/mini-os/lib/math.c	2013-05-30 10:38:28.188374206 -0600
+++ xen-b/extras/mini-os/lib/math.c	2013-05-30 18:15:29.951707540 -0600
@@ -186,6 +186,7 @@
 	 * and thus
 	 *	m = 4 - n <= 2
 	 */
+	tmp.ul[H] = tmp.ul[L] = 0;
 	tmp.uq = uq;
 	u[0] = 0;
 	u[1] = HHALF(tmp.ul[H]);
diff -Naur xen/extras/mini-os/minios.mk xen-b/extras/mini-os/minios.mk
--- xen/extras/mini-os/minios.mk	2013-05-30 10:38:28.188374206 -0600
+++ xen-b/extras/mini-os/minios.mk	2013-05-30 18:15:29.955040874 -0600
@@ -6,7 +6,7 @@
 
 # Define some default flags.
 # NB. '-Wcast-qual' is nasty, so I omitted it.
-DEF_CFLAGS += -fno-builtin -Wall -Werror -Wredundant-decls -Wno-format -Wno-redundant-decls
+DEF_CFLAGS += -fno-builtin -Wall -Wredundant-decls -Wno-format -Wno-redundant-decls
 DEF_CFLAGS += $(call cc-option,$(CC),-fno-stack-protector,)
 DEF_CFLAGS += $(call cc-option,$(CC),-fgnu89-inline)
 DEF_CFLAGS += -Wstrict-prototypes -Wnested-externs -Wpointer-arith -Winline
diff -Naur xen/tools/Rules.mk xen-b/tools/Rules.mk
--- xen/tools/Rules.mk	2013-05-30 10:38:28.201707538 -0600
+++ xen-b/tools/Rules.mk	2013-05-30 18:15:29.955040874 -0600
@@ -9,6 +9,8 @@
 export _INSTALL := $(INSTALL)
 INSTALL = $(XEN_ROOT)/tools/cross-install
 
+LDFLAGS_RPATH = -Wl,-rpath,'$${ORIGIN}$(if $(1),/$(1))'
+
 XEN_INCLUDE        = $(XEN_ROOT)/tools/include
 XEN_LIBXC          = $(XEN_ROOT)/tools/libxc
 XEN_XENLIGHT       = $(XEN_ROOT)/tools/libxl
diff -Naur xen/tools/blktap/drivers/Makefile xen-b/tools/blktap/drivers/Makefile
--- xen/tools/blktap/drivers/Makefile	2013-05-30 10:38:28.201707538 -0600
+++ xen-b/tools/blktap/drivers/Makefile	2013-05-30 18:15:29.955040874 -0600
@@ -38,8 +38,9 @@
 CFLAGS += $(PTHREAD_CFLAGS)
 LDFLAGS += $(PTHREAD_LDFLAGS)
 
-LDLIBS_blktapctrl := $(MEMSHRLIBS) $(LDLIBS_libxenctrl) $(LDLIBS_libxenstore) -L../lib -lblktap -lrt -lm $(PTHREAD_LIBS)
-LDLIBS_img := $(AIOLIBS) $(CRYPT_LIB) $(PTHREAD_LIBS) -lz
+LDLIBS_xen := $(LDLIBS_libxenctrl) $(LDLIBS_libxenstore)
+LDLIBS_blktapctrl := $(MEMSHRLIBS) $(LDLIBS_xen) -L../lib -lblktap -lrt -lm $(PTHREAD_LIBS)
+LDLIBS_img := $(AIOLIBS) $(CRYPT_LIB) $(PTHREAD_LIBS) -lz $(LDLIBS_xen)
 
 BLK-OBJS-y  := block-aio.o
 BLK-OBJS-y  += block-sync.o
@@ -47,6 +48,7 @@
 BLK-OBJS-y  += block-ram.o
 BLK-OBJS-y  += block-qcow.o
 BLK-OBJS-y  += block-qcow2.o
+BLK-OBJS-y  += block-cdrom.o
 BLK-OBJS-y  += aes.o
 BLK-OBJS-y  += tapaio.o
 BLK-OBJS-$(CONFIG_Linux) += blk_linux.o
diff -Naur xen/tools/blktap/drivers/block-cdrom.c xen-b/tools/blktap/drivers/block-cdrom.c
--- xen/tools/blktap/drivers/block-cdrom.c	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/tools/blktap/drivers/block-cdrom.c	2013-05-30 18:15:29.955040874 -0600
@@ -0,0 +1,565 @@
+/* block-cdrom.c
+ *
+ * simple slow synchronous cdrom disk implementation. Based off
+ * of block-sync.c
+ *
+ * (c) 2006 Andrew Warfield and Julian Chesterfield
+ * (c) 2008 Novell Inc. <plc@novell.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation; or, when distributed
+ * separately from the Linux kernel or incorporated into other
+ * software packages, subject to the following license:
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this source file (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/statvfs.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/mount.h>
+
+#include "tapdisk.h"
+#include <xen/io/cdromif.h>
+
+struct tdcdrom_state {
+	int fd;
+	int xs_fd;        /* for xen event polling */
+	int media_present;
+	int media_changed;
+	struct xs_handle *xs_handle;
+	char *dev_name;
+	int dev_type;
+	td_flag_t flags;
+};
+
+#define BLOCK_DEVICE   0
+#define FILE_DEVICE    1
+#define CDROM_DEFAULT_SECTOR_SIZE 2048
+#define CDROM_DEFAULT_SIZE 2000000000
+
+/*Get Image size, secsize*/
+static void get_image_info(struct disk_driver *dd)
+{
+	int ret;
+	long size;
+	unsigned long total_size;
+	struct statvfs statBuf;
+	struct stat stat;
+	struct td_state     *s   = dd->td_state;
+	struct tdcdrom_state *prv = dd->private;
+
+	s->size = 0;
+	s->sector_size = CDROM_DEFAULT_SECTOR_SIZE;
+	s->info = (VDISK_CDROM | VDISK_REMOVABLE | VDISK_READONLY);
+	prv->media_present = 0;
+
+	ret = fstat(prv->fd, &stat);
+	if (ret != 0) {
+		DPRINTF("ERROR: fstat failed, Couldn't stat image");
+		return;
+	}
+
+	if (S_ISBLK(stat.st_mode)) {
+		/*Accessing block device directly*/
+		int status;
+
+		prv->dev_type = BLOCK_DEVICE;
+		status = ioctl(prv->fd, CDROM_DRIVE_STATUS, CDSL_CURRENT);
+		if (status == CDS_DISC_OK) {
+			prv->media_present = 1;
+			if ((ret =ioctl(prv->fd,BLKGETSIZE,&s->size))!=0) {
+				DPRINTF("ERR: BLKGETSIZE failed, couldn't stat image");
+				s->size = CDROM_DEFAULT_SIZE;
+			}
+		}
+		else {
+			s->size = CDROM_DEFAULT_SIZE;
+		}
+		/*Get the sector size*/
+#if defined(BLKSSZGET)
+		{
+			int arg;
+			s->sector_size = CDROM_DEFAULT_SECTOR_SIZE;
+			ioctl(prv->fd, BLKSSZGET, &s->sector_size);
+
+			if (s->sector_size != CDROM_DEFAULT_SECTOR_SIZE)
+				DPRINTF("Note: sector size is %llu (not %d)\n",
+					(long long unsigned)s->sector_size,
+					CDROM_DEFAULT_SECTOR_SIZE);
+		}
+#else
+		s->sector_size = CDROM_DEFAULT_SECTOR_SIZE;
+#endif
+		DPRINTF("Block Device: Image size: %llu"
+			" media_present: %d sector_size: %llu\n",
+			(long long unsigned)s->size, prv->media_present,
+			(long long unsigned)s->sector_size);
+	} else {
+		/*Local file? try fstat instead*/
+		prv->dev_type = FILE_DEVICE;
+		prv->media_present = 1;
+		s->size = (stat.st_size >> SECTOR_SHIFT);
+		s->sector_size = DEFAULT_SECTOR_SIZE;
+		DPRINTF("Local File: Image size: %llu\n",
+				(long long unsigned)s->size);
+	}
+	return;
+}
+
+static inline void init_fds(struct disk_driver *dd)
+{
+	int i;
+	struct tdcdrom_state *prv = dd->private;
+
+	for(i = 0; i < MAX_IOFD; i++)
+		dd->io_fd[i] = 0;
+
+	prv->xs_handle = xs_daemon_open();
+	prv->xs_fd = xs_fileno(prv->xs_handle);
+	dd->io_fd[0] = prv->xs_fd;
+}
+
+void open_device (struct disk_driver *dd)
+{
+	struct tdcdrom_state *prv = dd->private;
+	int o_flags;
+
+	o_flags = O_NONBLOCK | O_LARGEFILE |
+		((prv->flags == TD_RDONLY) ? O_RDONLY : O_RDWR);
+
+	if (prv->fd < 0) {
+		prv->fd = open(prv->dev_name, o_flags);
+		if (prv->fd == -1) {
+			DPRINTF("Unable tp open: (%s)\n", prv->dev_name);
+			return;
+		}
+	}
+
+	if (prv->fd != -1) {
+
+		get_image_info(dd);
+
+		if (prv->dev_type == BLOCK_DEVICE) {
+			int status;
+			status = ioctl(prv->fd, CDROM_DRIVE_STATUS, CDSL_CURRENT);
+			switch (status) {
+				case CDS_DISC_OK:
+					prv->media_present = 1;
+					break;
+				default:
+					prv->media_present = 0;
+			}
+		}
+		else
+			prv->media_present = 1;
+	}
+}
+
+/*
+ * Main entry point, called when first loaded
+ */
+int tdcdrom_open (struct disk_driver *dd, const char *name, td_flag_t flags)
+{
+	int ret;
+	struct tdcdrom_state *prv = dd->private;
+
+	ret = asprintf(&prv->dev_name, "%s", name);
+	if (ret < 0) {
+		prv->dev_name = NULL;
+		goto out;
+	}
+	prv->fd = -1;
+	prv->media_changed = 0;
+	prv->media_present = 0;
+	prv->flags = flags;
+	init_fds(dd);
+
+	open_device(dd);
+
+out:
+	return ret;
+}
+
+int tdcdrom_queue_read(struct disk_driver *dd, uint64_t sector,
+		int nb_sectors, char *buf, td_callback_t cb,
+		int id, void *private)
+{
+	struct td_state     *s   = dd->td_state;
+	struct tdcdrom_state *prv = dd->private;
+	int      size    = nb_sectors * s->sector_size;
+	uint64_t offset  = sector * (uint64_t)s->sector_size;
+	int ret;
+
+	if (prv->fd == -1 || prv->media_present == 0) {
+		ret = 0 - ENOMEDIUM;
+		return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+	}
+	size    = nb_sectors * 512;
+	offset  = sector * (uint64_t)512;
+	ret = lseek(prv->fd, offset, SEEK_SET);
+	if (ret != (off_t)-1) {
+		ret = read(prv->fd, buf, size);
+		if (ret != size) {
+			ret = 0 - errno;
+		} else {
+			ret = 1;
+		}
+	} else ret = 0 - errno;
+
+	return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+}
+
+int tdcdrom_queue_write(struct disk_driver *dd, uint64_t sector,
+		int nb_sectors, char *buf, td_callback_t cb,
+		int id, void *private)
+{
+	struct td_state     *s   = dd->td_state;
+	struct tdcdrom_state *prv = dd->private;
+	int      size    = nb_sectors * s->sector_size;
+	uint64_t offset  = sector * (uint64_t)s->sector_size;
+	int ret = 0;
+
+	if (prv->fd == -1 || prv->media_present == 0) {
+		ret = 0 - ENOMEDIUM;
+		return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+	}
+	ret = lseek(prv->fd, offset, SEEK_SET);
+	if (ret != (off_t)-1) {
+		ret = write(prv->fd, buf, size);
+		if (ret != size) {
+			ret = 0 - errno;
+		} else {
+			ret = 1;
+		}
+	} else ret = 0 - errno;
+
+	return cb(dd, (ret < 0) ? ret : 0, sector, nb_sectors, id, private);
+}
+
+int tdcdrom_queue_packet(struct disk_driver *dd, uint64_t sector,
+		int nb_sectors, char *buf, td_callback_t cb,
+		int id, void *private)
+{
+	struct td_state     *s   = dd->td_state;
+	struct tdcdrom_state *prv = dd->private;
+	int      size    = nb_sectors * s->sector_size;
+	uint64_t offset  = sector * (uint64_t)s->sector_size;
+	int ret = 0;
+
+	union xen_block_packet *sp;
+	struct xen_cdrom_packet *xcp;
+	struct xen_cdrom_support *xcs;
+	struct xen_cdrom_open *xco;
+	struct xen_cdrom_media_info *xcmi;
+	struct xen_cdrom_media_changed *xcmc;
+	struct cdrom_generic_command cgc;
+	struct vcd_generic_command * vgc;
+	struct request_sense sense;
+
+	sp = (union xen_block_packet *)buf;
+	switch(sp->type) {
+		case XEN_TYPE_CDROM_SUPPORT:
+			xcs = &(sp->xcs);
+			xcs->err = 0;
+			xcs->ret = 0;
+			xcs->supported = 1;
+			break;
+		case XEN_TYPE_CDROM_PACKET:
+			xcp = &(sp->xcp);
+			xcp->err = 0;
+			xcp->ret = 0;
+			vgc = (struct vcd_generic_command *)(buf + PACKET_PAYLOAD_OFFSET);
+
+			memset( &cgc, 0, sizeof(struct cdrom_generic_command));
+			memcpy(cgc.cmd, vgc->cmd, CDROM_PACKET_SIZE);
+			cgc.stat = vgc->stat;
+			cgc.data_direction = vgc->data_direction;
+			cgc.quiet = vgc->quiet;
+			cgc.timeout = vgc->timeout;
+
+			if (prv->fd == -1) {
+				xcp = &(sp->xcp);
+				xcp->ret = -1;
+				xcp->err =  0 - ENODEV;
+				return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+			}
+			if (prv->dev_type == FILE_DEVICE) {
+				DPRINTF("%s() FILE_DEVICE inappropriate packetcmd \n",__func__);
+				return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+			}
+			switch ( cgc.cmd[0]) {
+				case GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
+					{
+						int lock;
+						lock = cgc.cmd[4] & 1;
+						if (ioctl (prv->fd, CDROM_LOCKDOOR, lock) < 0) {
+							xcp->err = -(errno);
+							xcp->ret = -1;
+						}
+					}
+					break;
+				case GPCMD_START_STOP_UNIT:
+					{
+						int start, eject;
+						start = cgc.cmd[4] & 1;
+						eject = (cgc.cmd[4] >> 1) & 1;
+						if (eject && !start) {
+							if (ioctl (prv->fd, CDROMEJECT, NULL) < 0) {
+								xcp->err = -(errno);
+								xcp->ret = -1;
+							}
+						} else if (eject && start) {
+							if (ioctl (prv->fd, CDROMCLOSETRAY, NULL) < 0) {
+								xcp->err = -(errno);
+								xcp->ret = -1;
+							}
+						}
+					}
+					break;
+				default:
+					{
+						if (vgc->sense_offset) {
+							cgc.sense = &sense;
+						}
+						if (vgc->buffer_offset) {
+							cgc.buffer = malloc(vgc->buflen);
+							memcpy(cgc.buffer, (char *)sp + PACKET_BUFFER_OFFSET, vgc->buflen);
+							cgc.buflen = vgc->buflen;
+						}
+						if (ioctl (prv->fd, CDROM_SEND_PACKET, &cgc) < 0 ) {
+							xcp->err = -(errno);
+							xcp->ret = -1;
+						}
+						if (cgc.sense) {
+							memcpy((char *)sp + PACKET_SENSE_OFFSET, cgc.sense, sizeof(struct request_sense));
+						}
+						if (cgc.buffer) {
+							vgc->buflen = cgc.buflen;
+							memcpy((char *)sp + PACKET_BUFFER_OFFSET, cgc.buffer, cgc.buflen);
+							free(cgc.buffer);
+						}
+						break;
+					}
+			}
+			break;
+		case XEN_TYPE_CDROM_OPEN:
+			{
+				unsigned int len;
+				struct stat statbuf;
+				int major = 0;
+				int minor = 0;
+
+				if (stat (prv->dev_name, &statbuf) == 0) {
+					major = major (statbuf.st_rdev);
+					minor = minor (statbuf.st_rdev);
+				}
+				xco = &(sp->xco);
+				xco->err = 0;
+				xco->ret = 0;
+				if (xco->payload_offset) {
+					char *present;
+					char *buf;
+					char *num;
+					char *nodename;
+					char media_present[2];
+					nodename = (char *)sp + xco->payload_offset;
+					if (asprintf(&buf, "%s/media-present", nodename) < 0)
+						goto out_payload_offset;
+					present = xs_read(prv->xs_handle, XBT_NULL, buf, &len);
+					if (present) {
+						free(buf);
+						goto out_payload_offset_free;
+					}
+
+					sprintf(media_present, "%d", prv->media_present);
+					xs_write(prv->xs_handle, XBT_NULL, buf, media_present, strlen(media_present));
+					xs_watch(prv->xs_handle, buf, "media-present");
+					free(buf);
+
+					if (asprintf(&buf, "%s/params", nodename) < 0)
+						goto out_payload_offset_free;
+					xs_watch(prv->xs_handle, buf, "params");
+					free(buf);
+
+					if (asprintf(&num, "%x:%x", major, minor) < 0)
+						goto out_payload_offset_free;
+					if (asprintf(&buf, "%s/physical-device", nodename) < 0) {
+						free(num);
+						goto out_payload_offset_free;
+					}
+					xs_write(prv->xs_handle, XBT_NULL, buf, num, strlen(num));
+					free(buf);
+					free(num);
+out_payload_offset_free:
+					free(present);
+out_payload_offset:
+					;
+				}
+
+				xco->media_present = prv->media_present;
+				xco->sectors = 0;
+				xco->sector_size = 2048;
+				if (prv->media_present && prv->fd != -1 ) {
+					get_image_info(dd);
+					xco->sectors = s->size;
+					xco->sector_size = s->sector_size;
+				}
+			}
+			break;
+		case XEN_TYPE_CDROM_MEDIA_CHANGED:
+			xcmc = &(sp->xcmc);
+			xcmc->err = 0;
+			xcmc->ret = 0;
+			xcmc->media_changed = prv->media_changed;
+			prv->media_changed = 0;
+			break;
+		default:
+			xcp = &(sp->xcp);
+			xcp->err = -EINVAL;
+			xcp->ret = -1;
+			break;
+	}
+
+	return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+}
+
+int tdcdrom_submit(struct disk_driver *dd)
+{
+	return 0;
+}
+
+int tdcdrom_close(struct disk_driver *dd)
+{
+	struct tdcdrom_state *prv = dd->private;
+
+	if (prv->fd != -1) {
+		close(prv->fd);
+		prv->fd = -1;
+	}
+	prv->xs_fd = -1;
+	xs_daemon_close(prv->xs_handle);
+	free(prv->dev_name);
+
+	return 0;
+}
+
+void tdcdrom_process_media_change_event(struct disk_driver *dd, char **vec)
+{
+    struct tdcdrom_state *prv = dd->private;
+    char *media_present;
+    unsigned int len;
+
+	media_present = xs_read(prv->xs_handle, XBT_NULL, vec[XS_WATCH_PATH], &len);
+	if (strcmp(media_present, "0") == 0) {
+		close(prv->fd);
+		prv->fd = -1;
+		prv->media_present = 0;
+	}
+	else {
+		open_device(dd);
+		prv->media_changed = 1;
+	}
+	free(media_present);
+}
+
+void tdcrom_process_params_event(struct disk_driver *dd, char **vec)
+{
+    struct tdcdrom_state *prv = dd->private;
+    char *params;
+    unsigned int len;
+
+	params = xs_read(prv->xs_handle, XBT_NULL, vec[XS_WATCH_PATH], &len);
+	if (params) {
+		char *cp = strchr(params, ':');
+		if (cp) {
+			cp++;
+			if (prv->dev_name)
+				free(prv->dev_name);
+			if (asprintf(&prv->dev_name, "%s", cp) < 0) {
+				prv->dev_name = NULL;
+				return;
+			}
+			if (prv->fd != -1) {
+				close(prv->fd);
+				prv->fd = -1;
+			}
+			open_device(dd);
+			prv->media_changed = 1;
+		}
+		free(params);
+	}
+}
+
+int tdcdrom_do_callbacks(struct disk_driver *dd, int sid)
+{
+	struct tdcdrom_state *prv = dd->private;
+	char **vec;
+	unsigned int num;
+
+	vec = xs_read_watch(prv->xs_handle, &num);
+	if (!vec)
+		return 1;
+
+    if (!strcmp(vec[XS_WATCH_TOKEN], "media-present")) {
+        tdcdrom_process_media_change_event(dd, vec);
+        goto out;
+    }
+
+    if (!strcmp(vec[XS_WATCH_TOKEN], "params")) {
+        tdcrom_process_params_event(dd, vec);
+        goto out;
+    }
+
+ out:
+    free(vec);
+	return 1;
+}
+
+int tdcdrom_get_parent_id(struct disk_driver *dd, struct disk_id *id)
+{
+	return TD_NO_PARENT;
+}
+
+int tdcdrom_validate_parent(struct disk_driver *dd,
+		struct disk_driver *parent, td_flag_t flags)
+{
+	return -EINVAL;
+}
+
+struct tap_disk tapdisk_cdrom = {
+	.disk_type           = "tapdisk_cdrom",
+	.private_data_size   = sizeof(struct tdcdrom_state),
+	.td_open             = tdcdrom_open,
+	.td_queue_read       = tdcdrom_queue_read,
+	.td_queue_packet     = tdcdrom_queue_packet,
+	.td_queue_write      = tdcdrom_queue_write,
+	.td_submit           = tdcdrom_submit,
+	.td_close            = tdcdrom_close,
+	.td_do_callbacks     = tdcdrom_do_callbacks,
+	.td_get_parent_id    = tdcdrom_get_parent_id,
+	.td_validate_parent  = tdcdrom_validate_parent
+};
diff -Naur xen/tools/blktap/drivers/tapdisk.c xen-b/tools/blktap/drivers/tapdisk.c
--- xen/tools/blktap/drivers/tapdisk.c	2013-05-30 10:38:28.205040873 -0600
+++ xen-b/tools/blktap/drivers/tapdisk.c	2013-05-30 18:15:29.955040874 -0600
@@ -735,6 +735,22 @@
 					goto out;
 				}
 				break;
+			case BLKIF_OP_PACKET:
+				ret = 0;
+				if (drv->td_queue_packet)
+					ret = drv->td_queue_packet(dd, sector_nr,
+							nsects, page,
+							send_responses,
+							idx, (void *)(long)i);
+				if (ret > 0) dd->early += ret;
+				else if (ret == -EBUSY) {
+					/* put req back on queue */
+					--info->fe_ring.req_cons;
+					info->busy.req     = req;
+					info->busy.seg_idx = i;
+					goto out;
+				}
+				break;
 			default:
 				DPRINTF("Unknown block operation\n");
 				break;
diff -Naur xen/tools/blktap/drivers/tapdisk.h xen-b/tools/blktap/drivers/tapdisk.h
--- xen/tools/blktap/drivers/tapdisk.h	2013-05-30 10:38:28.205040873 -0600
+++ xen-b/tools/blktap/drivers/tapdisk.h	2013-05-30 18:15:29.955040874 -0600
@@ -137,6 +137,9 @@
 	int (*td_get_parent_id)  (struct disk_driver *dd, struct disk_id *id);
 	int (*td_validate_parent)(struct disk_driver *dd, 
 				  struct disk_driver *p, td_flag_t flags);
+	int (*td_queue_packet)  (struct disk_driver *dd, uint64_t sector,
+				  int nb_sectors, char *buf, td_callback_t cb,
+				  int id, void *prv);
 };
 
 typedef struct disk_info {
@@ -160,6 +163,7 @@
 extern struct tap_disk tapdisk_ram;
 extern struct tap_disk tapdisk_qcow;
 extern struct tap_disk tapdisk_qcow2;
+extern struct tap_disk tapdisk_cdrom;
 
 
 /*Define Individual Disk Parameters here */
@@ -229,6 +233,17 @@
 #endif
 };
 
+static disk_info_t cdrom_disk = {
+	DISK_TYPE_CDROM,
+	"raw image (cdrom)",
+	"cdrom",
+	0,
+	0,
+#ifdef TAPDISK
+	&tapdisk_cdrom,
+#endif
+};
+
 /*Main disk info array */
 static disk_info_t *dtypes[] = {
 	&aio_disk,
@@ -237,6 +252,7 @@
 	&ram_disk,
 	&qcow_disk,
 	&qcow2_disk,
+	&cdrom_disk,
 };
 
 typedef struct driver_list_entry {
diff -Naur xen/tools/blktap/lib/blktaplib.h xen-b/tools/blktap/lib/blktaplib.h
--- xen/tools/blktap/lib/blktaplib.h	2013-05-30 10:38:28.205040873 -0600
+++ xen-b/tools/blktap/lib/blktaplib.h	2013-05-30 18:15:29.955040874 -0600
@@ -219,6 +219,7 @@
 #define DISK_TYPE_RAM      3
 #define DISK_TYPE_QCOW     4
 #define DISK_TYPE_QCOW2    5
+#define DISK_TYPE_CDROM    6
 
 /* xenstore/xenbus: */
 #define DOMNAME "Domain-0"
diff -Naur xen/tools/blktap2/drivers/Makefile xen-b/tools/blktap2/drivers/Makefile
--- xen/tools/blktap2/drivers/Makefile	2013-05-30 10:38:28.205040873 -0600
+++ xen-b/tools/blktap2/drivers/Makefile	2013-05-30 18:15:29.955040874 -0600
@@ -9,7 +9,7 @@
 LOCK_UTIL  = lock-util
 INST_DIR   = $(SBINDIR)
 
-CFLAGS    += -Werror -g
+CFLAGS    += -g
 CFLAGS    += -Wno-unused
 CFLAGS    += -fno-strict-aliasing
 CFLAGS    += -I$(BLKTAP_ROOT)/include -I$(BLKTAP_ROOT)/drivers
diff -Naur xen/tools/debugger/gdbsx/Rules.mk xen-b/tools/debugger/gdbsx/Rules.mk
--- xen/tools/debugger/gdbsx/Rules.mk	2013-05-30 10:38:28.248374205 -0600
+++ xen-b/tools/debugger/gdbsx/Rules.mk	2013-05-30 18:15:29.955040874 -0600
@@ -1,4 +1,4 @@
 include $(XEN_ROOT)/tools/Rules.mk
 
-CFLAGS   += -Werror -Wmissing-prototypes 
+CFLAGS   += -Wmissing-prototypes 
 # (gcc 4.3x and later)   -Wconversion -Wno-sign-conversion
diff -Naur xen/tools/debugger/gdbsx/xg/xg_main.c xen-b/tools/debugger/gdbsx/xg/xg_main.c
--- xen/tools/debugger/gdbsx/xg/xg_main.c	2013-05-30 10:38:28.251707539 -0600
+++ xen-b/tools/debugger/gdbsx/xg/xg_main.c	2013-05-30 18:15:29.955040874 -0600
@@ -179,7 +179,7 @@
     hypercall.op = __HYPERVISOR_domctl;
     hypercall.arg[0] = (unsigned long)&domctl;
 
-    rc = ioctl(_dom0_fd, IOCTL_PRIVCMD_HYPERCALL, (ulong)&hypercall);
+    rc = ioctl(_dom0_fd, IOCTL_PRIVCMD_HYPERCALL, (unsigned long)&hypercall);
     if (domctlarg && sz)
         munlock(domctlarg, sz);
     return rc;
@@ -219,7 +219,7 @@
     hypercall.arg[0] = (unsigned long)XENVER_capabilities;
     hypercall.arg[1] = (unsigned long)&xen_caps;
 
-    rc = ioctl(_dom0_fd, IOCTL_PRIVCMD_HYPERCALL, (ulong)&hypercall);
+    rc = ioctl(_dom0_fd, IOCTL_PRIVCMD_HYPERCALL, (unsigned long)&hypercall);
     munlock(&xen_caps, sizeof(xen_caps));
     XGTRC("XENCAPS:%s\n", xen_caps);
 
diff -Naur xen/tools/examples/Makefile xen-b/tools/examples/Makefile
--- xen/tools/examples/Makefile	2013-05-30 10:38:28.251707539 -0600
+++ xen-b/tools/examples/Makefile	2013-05-30 18:15:29.955040874 -0600
@@ -25,7 +25,7 @@
 XEN_CONFIGS += xend-pci-permissive.sxp
 XEN_CONFIGS += xl.conf
 XEN_CONFIGS += cpupool
-
+XEN_CONFIGS += xmexample.disks
 .PHONY: all
 all:
 
diff -Naur xen/tools/examples/xend-config.sxp xen-b/tools/examples/xend-config.sxp
--- xen/tools/examples/xend-config.sxp	2013-05-30 10:38:28.251707539 -0600
+++ xen-b/tools/examples/xend-config.sxp	2013-05-30 18:15:29.955040874 -0600
@@ -194,6 +194,26 @@
 #(network-script network-route)
 #(vif-script     vif-route)
 
+# SuSE users note:
+# If using a routed network configuration it is advised to NOT use
+# network-route and vif-route scripts but instead use sysconfig scripts
+# in dom0 and vif-route-ifup script to "connect" the domU vif to dom0.
+# Since this configuration requires a vif sysconfig script in dom0, a static
+# vif name must be used.  E.g. in dom0 the vif sysconfig script
+# (/etc/sysconfig/network/ifcfg-xen1.0) may contain
+#
+#    NAME='XEN vm 1 virtual interface 0'
+#    BOOTPROTO='static'
+#    STARTMODE='hotplug'
+#    ...
+#
+# The corresponding domain vif configuration would contain e.g.
+# vif=[ 'mac=00:16:3e:aa:bb:cc,script=vif-route-ifup,vifname=xen1.0', ]
+#
+# If the vif-route-ifup script will be used for all domains, it can be
+# set here as the default vif script, alleviating the need for
+# 'script=' in domain vif configuration.
+#(vif-script     vif-route-ifup)
 
 ## Use the following if network traffic is routed with NAT, as an alternative
 # to the settings for bridged networking given above.
diff -Naur xen/tools/examples/xmexample.disks xen-b/tools/examples/xmexample.disks
--- xen/tools/examples/xmexample.disks	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/tools/examples/xmexample.disks	2013-05-30 18:15:29.955040874 -0600
@@ -0,0 +1,32 @@
+# A VM's disks can be stored in a variety of ways.
+# Here are some examples:
+disk = [
+    # Block device
+    'phy:/dev/hdb,xvda,w',
+    # Raw format, accessed via loopback
+    'file:/var/lib/xen/images/disk-example/disk0,xvdb,w',
+    # Raw format, accessed via blocktap
+    'tap:aio:/var/lib/xen/images/disk-example/disk0,xvdc,w',
+    # QCOW format, accessed via blocktap
+    'tap:qcow:/var/lib/xen/images/disk-example/disk0.qcow,xvdd,w',
+    # NBD (network block device):  IP and port are separated by space
+    'nbd:192.168.0.1 20004,xvde,w',
+    # iSCSI:  The usual colon is replaced with '@'
+    'iscsi:iqn.2006-09.de.suse@0ac47ee2-216e-452a-a341-a12624cd0225,xvdf,w',
+    # Fibre Channel N_Port ID Virtualization
+    'npiv:210400e08b80c40f,xvdg,w' ]
+
+
+# Remaining settings for the example VM:
+name="disk-example"
+memory=512
+vcpus=1
+on_crash="destroy"
+on_poweroff="destroy"
+on_reboot="restart"
+localtime=0
+builder="linux"
+bootloader="/usr/lib/xen/boot/domUloader.py"
+bootargs="--entry=xvda2:/boot/vmlinuz-xen,/boot/initrd-xen"
+vif=[ 'mac=00:16:3e:00:01:02,bridge=xenbr0' ]
+vfb=['type=vnc,vncunused=1']
diff -Naur xen/tools/examples/xmexample.hvm xen-b/tools/examples/xmexample.hvm
--- xen/tools/examples/xmexample.hvm	2013-05-30 10:38:28.251707539 -0600
+++ xen-b/tools/examples/xmexample.hvm	2013-05-30 18:15:29.958374206 -0600
@@ -127,6 +127,15 @@
 # Device Model to be used
 device_model = 'qemu-dm'
 
+# the amount of memory in MiB for the guest
+#actmem=42
+
+# Optional: guest page file
+#xenpaging_file="/var/lib/xen/xenpaging/<domain_name>.<domaind_id>.paging"
+
+# Optional: extra cmdline options for xenpaging
+#xenpaging_extra=[ 'string', 'string' ]
+
 #-----------------------------------------------------------------------------
 # boot on floppy (a), hard disk (c), Network (n) or CD-ROM (d) 
 # default: hard disk, cd-rom, floppy
diff -Naur xen/tools/firmware/Makefile xen-b/tools/firmware/Makefile
--- xen/tools/firmware/Makefile	2013-05-30 10:38:28.251707539 -0600
+++ xen-b/tools/firmware/Makefile	2013-05-30 18:15:29.958374206 -0600
@@ -18,8 +18,8 @@
 	cp ovmf-makefile ovmf/Makefile;
 
 seabios-dir:
-	GIT=$(GIT) $(XEN_ROOT)/scripts/git-checkout.sh $(SEABIOS_UPSTREAM_URL) $(SEABIOS_UPSTREAM_TAG) seabios-dir
-	cp seabios-config seabios-dir/.config;
+	GIT=$(GIT) $(XEN_ROOT)/scripts/git-checkout.sh $(SEABIOS_UPSTREAM_URL) $(SEABIOS_UPSTREAM_TAG) seabios-dir 	
+	cp seabios-config seabios-dir/.config; 
 
 .PHONY: all
 all: $(SUBDIRS-y)
diff -Naur xen/tools/firmware/etherboot/Config xen-b/tools/firmware/etherboot/Config
--- xen/tools/firmware/etherboot/Config	2013-05-30 10:38:28.251707539 -0600
+++ xen-b/tools/firmware/etherboot/Config	2013-05-30 18:15:29.958374206 -0600
@@ -1,3 +1,4 @@
+NICS = rtl8139 8086100e eepro100 e1000 pcnet32 10ec8029
 
 CFLAGS += -UPXE_DHCP_STRICT
 CFLAGS += -DPXE_DHCP_STRICT
diff -Naur xen/tools/firmware/hvmloader/config.h xen-b/tools/firmware/hvmloader/config.h
--- xen/tools/firmware/hvmloader/config.h	2013-05-30 10:38:28.255040872 -0600
+++ xen-b/tools/firmware/hvmloader/config.h	2013-05-30 18:15:29.958374206 -0600
@@ -5,6 +5,9 @@
 
 enum virtual_vga { VGA_none, VGA_std, VGA_cirrus, VGA_pt };
 extern enum virtual_vga virtual_vga;
+//PARCHE//
+extern uint8_t gfx_bdf;
+//PARCHE_END//
 
 extern unsigned long igd_opregion_pgbase;
 #define IGD_OPREGION_PAGES 3
diff -Naur xen/tools/hotplug/Linux/network-bridge xen-b/tools/hotplug/Linux/network-bridge
--- xen/tools/hotplug/Linux/network-bridge	2013-05-30 10:38:28.271707539 -0600
+++ xen-b/tools/hotplug/Linux/network-bridge	2013-05-30 18:15:29.958374206 -0600
@@ -280,19 +280,19 @@
     transfer_addrs ${bridge} ${pdev}
     if ! ifdown ${bridge}; then
 	get_ip_info ${bridge}
-    fi
-    ip link set ${pdev} down
-    ip addr flush ${bridge}
+	ip link set ${pdev} down
+	ip addr flush ${bridge}
 
-    brctl delif ${bridge} ${pdev}
-    ip link set ${bridge} down
+	brctl delif ${bridge} ${pdev}
+	ip link set ${bridge} down
 
-    ip link set ${bridge} name ${tdev}
+	ip link set ${bridge} name ${tdev}
+	brctl delbr ${tdev}
+    fi
+    ip link set ${pdev} down
     ip link set ${pdev} name ${netdev}
     do_ifup ${netdev}
 
-    brctl delbr ${tdev}
-
     release_lock "network-bridge"
 }
 
diff -Naur xen/tools/hotplug/Linux/network-openvswitch xen-b/tools/hotplug/Linux/network-openvswitch
--- xen/tools/hotplug/Linux/network-openvswitch	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/tools/hotplug/Linux/network-openvswitch	2013-05-30 18:15:29.958374206 -0600
@@ -0,0 +1,121 @@
+#!/bin/bash
+#============================================================================
+# Default Xen network start/stop script.
+# Xend calls a network script when it starts.
+# The script name to use is defined in ${XEN_CONFIG_DIR}/xend-config.sxp
+# in the network-script field.
+#
+# This script creates a virtual switch (default ${netdev}) and adds a
+# device (defaults to eth0) to it.  The interface that this Open vSwitch
+# is created on should not have a working IP address and will be used as
+# a switch for Xen domU's.
+#
+# Usage:
+# network-openvswitch (start|stop|status) {VAR=VAL}*
+#
+# Vars:
+# bridge     The bridge to use (default xenvs0).
+# netdev     The interface to add to the bridge (default eth0).
+#
+# start:
+# Creates the bridge as bridge
+# Enslaves netdev to bridge
+#
+# stop:
+# Removes netdev from the bridge
+# Deletes bridge
+#
+# status:
+# Print addresses, interfaces
+#
+#============================================================================
+
+dir=$(dirname "$0")
+. "$dir/logging.sh"
+. "$dir/xen-script-common.sh"
+. "$dir/xen-network-common.sh"
+. "$dir/locking.sh"
+
+findCommand "$@"
+evalVariables "$@"
+
+netdev=${netdev:-eth1}
+bridge=${bridge:-ovs0}
+
+addr=`ip addr show dev ${netdev} | egrep '^ *inet' | sed -e 's/ *inet
+//' -e 's/ .*//'`
+if [ -n "$addr" ]; then
+    echo "Invalid device: ${netdev} is up and has a valid IP address!" >&2
+    exit 1
+fi
+
+show_status () {
+    local dev=$1
+    local bridge=$2
+
+    echo '============================================================'
+    echo 'vSwitch interfaces'
+    ovs-vsctl list-ifaces ${bridge}
+    echo ' '
+    echo 'vSwitch ports'
+    ovs-vsctl list-ports ${bridge}
+    echo '============================================================'
+}
+
+op_start () {
+    if [ "${bridge}" = "null" ] ; then
+        return
+    fi
+
+    ip link set "${netdev}" down
+    ip link set "${netdev}" 0.0.0.0 up
+    ovs-vsctl -- --may-exist add-br ${bridge}
+    ip link set "${bridge}" 0.0.0.0 up
+    ovs-vsctl -- --may-exist add-port ${bridge} ${netdev}
+
+    # Remove any stale ports from last time virtual switch was running
+    for port in $(ovs-vsctl list-ports ${bridge})
+    do
+        if [ "${port}" != "${netdev}" ]
+        then
+            ip link set "${port}" down
+            ovs-vsctl del-port ${port}
+
+        fi
+    done
+}
+
+op_stop () {
+    if [ "${bridge}" = "null" ]; then
+        return
+    fi
+
+    # Remove all ports from virtual switch
+    for port in $(ovs-vsctl list-ports ${bridge})
+    do
+        ip link set "${port}" down
+        ovs-vsctl del-port ${port}
+    done
+
+    ip link set "${bridge}" down
+    ovs-vsctl -- --if-exists del-br ${bridge}
+}
+
+case "$command" in
+    start)
+        op_start
+        ;;
+
+    stop)
+        op_stop
+        ;;
+
+    status)
+        show_status ${netdev} ${bridge}
+        ;;
+
+    *)
+        echo "Unknown command: $command" >&2
+        echo 'Valid commands are: start, stop, status' >&2
+        exit 1
+esac
diff -Naur xen/tools/hotplug/Linux/vif-bridge xen-b/tools/hotplug/Linux/vif-bridge
--- xen/tools/hotplug/Linux/vif-bridge	2013-05-30 10:38:28.271707539 -0600
+++ xen-b/tools/hotplug/Linux/vif-bridge	2013-05-30 18:15:29.958374206 -0600
@@ -32,6 +32,13 @@
 dir=$(dirname "$0")
 . "$dir/vif-common.sh"
 
+mac=$(xenstore_read_default "$XENBUS_PATH/mac" "")
+if [ -z "$mac" ]
+then
+    log debug "No device details in $XENBUS_PATH, exiting."
+    exit 0
+fi
+
 bridge=${bridge:-}
 bridge=$(xenstore_read_default "$XENBUS_PATH/bridge" "$bridge")
 
diff -Naur xen/tools/hotplug/Linux/vif-route-ifup xen-b/tools/hotplug/Linux/vif-route-ifup
--- xen/tools/hotplug/Linux/vif-route-ifup	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/tools/hotplug/Linux/vif-route-ifup	2013-05-30 18:15:29.958374206 -0600
@@ -0,0 +1,34 @@
+#!/bin/bash
+#============================================================================
+# /etc/xen/vif-route-ifup
+#
+# Script for configuring a vif in routed mode.
+# The hotplugging system will call this script if it is specified either in
+# the device configuration given to Xend, or the default Xend configuration
+# in /etc/xen/xend-config.sxp.  If the script is specified in neither of those
+# places, then vif-bridge is the default.
+#
+# Usage:
+# vif-route-ifup (add|remove|online|offline)
+#
+# Environment vars:
+# dev         vif interface name (required).
+#============================================================================
+
+dir=$(dirname "$0")
+. "$dir/vif-common.sh"
+
+case "$command" in
+    online)
+        ifup ${dev}
+        ;;
+    offline)
+        do_without_error ifdown ${dev}
+        ;;
+esac
+
+log debug "Successful vif-route-ifup $command for ${dev}."
+if [ "$command" = "online" ]
+then
+  success
+fi
diff -Naur xen/tools/hotplug/Linux/xend.rules xen-b/tools/hotplug/Linux/xend.rules
--- xen/tools/hotplug/Linux/xend.rules	2013-05-30 10:38:28.271707539 -0600
+++ xen-b/tools/hotplug/Linux/xend.rules	2013-05-30 18:15:29.958374206 -0600
@@ -1,4 +1,4 @@
 SUBSYSTEM=="pci", RUN+="socket:/org/xen/xend/udev_event"
 SUBSYSTEM=="scsi", RUN+="socket:/org/xen/xend/udev_event"
 SUBSYSTEM=="usb", RUN+="socket:/org/xen/xend/udev_event"
-#SUBSYSTEM=="net", KERNEL!="vif[0-9]*.[0-9]*|tap[0-9]*.[0-9]*", RUN+="socket:/org/xen/xend/udev_event"
+SUBSYSTEM=="net", KERNEL!="vif[0-9]*.[0-9]*|tap[0-9]*.[0-9]*", RUN+="socket:/org/xen/xend/udev_event"
diff -Naur xen/tools/libaio/harness/Makefile xen-b/tools/libaio/harness/Makefile
--- xen/tools/libaio/harness/Makefile	2013-05-30 10:38:28.275040872 -0600
+++ xen-b/tools/libaio/harness/Makefile	2013-05-30 18:15:29.958374206 -0600
@@ -4,7 +4,7 @@
 HARNESS_SRCS:=main.c
 # io_queue.c
 
-CFLAGS=-Wall -Werror -g -O -laio
+CFLAGS=-Wall -g -O -laio
 #-lpthread -lrt
 
 all: $(PROGS)
diff -Naur xen/tools/libfsimage/Rules.mk xen-b/tools/libfsimage/Rules.mk
--- xen/tools/libfsimage/Rules.mk	2013-05-30 10:38:28.278374206 -0600
+++ xen-b/tools/libfsimage/Rules.mk	2013-05-30 18:15:29.958374206 -0600
@@ -1,7 +1,7 @@
 include $(XEN_ROOT)/tools/Rules.mk
 
 CFLAGS += -Wno-unknown-pragmas -I$(XEN_ROOT)/tools/libfsimage/common/ -DFSIMAGE_FSDIR=\"$(FSDIR)\"
-CFLAGS += -Werror -D_GNU_SOURCE
+CFLAGS += -D_GNU_SOURCE
 LDFLAGS += -L../common/
 
 PIC_OBJS := $(patsubst %.c,%.opic,$(LIB_SRCS-y))
diff -Naur xen/tools/libxc/Makefile xen-b/tools/libxc/Makefile
--- xen/tools/libxc/Makefile	2013-05-30 10:38:28.285040872 -0600
+++ xen-b/tools/libxc/Makefile	2013-05-30 18:15:29.958374206 -0600
@@ -80,7 +80,7 @@
 
 -include $(XEN_TARGET_ARCH)/Makefile
 
-CFLAGS   += -Werror -Wmissing-prototypes
+CFLAGS   += -Wmissing-prototypes
 CFLAGS   += -I. $(CFLAGS_xeninclude)
 
 # Needed for posix_fadvise64() in xc_linux.c
diff -Naur xen/tools/libxc/xc_suspend.c xen-b/tools/libxc/xc_suspend.c
--- xen/tools/libxc/xc_suspend.c	2013-05-30 10:38:28.291707539 -0600
+++ xen-b/tools/libxc/xc_suspend.c	2013-05-30 18:15:29.958374206 -0600
@@ -16,8 +16,43 @@
 
 #include "xc_private.h"
 #include "xenguest.h"
+#include <signal.h>
+#ifdef __MINIOS__
+extern int kill (__pid_t __pid, int __sig);
+#endif
 
 #define SUSPEND_LOCK_FILE "/var/lib/xen/suspend_evtchn"
+/* cleanup obsolete suspend lock file which is unlinked for any reason,
+so that current process can get lock */
+static void clean_obsolete_lock(int domid)
+{
+    int fd, pid, n;
+    char buf[128];
+    char suspend_file[256];
+
+    snprintf(suspend_file, sizeof(suspend_file), "%s_%d_lock.d",
+        SUSPEND_LOCK_FILE, domid);
+    fd = open(suspend_file, O_RDWR);
+
+    if (fd < 0)
+        return;
+
+    n = read(fd, buf, 127);
+
+    close(fd);
+
+    if (n > 0)
+    {
+        sscanf(buf, "%d", &pid);
+        /* pid does not exist, this lock file is obsolete, just delete it */
+        if ( kill(pid,0) )
+        {
+            unlink(suspend_file);
+            return;
+        }
+    }
+}
+
 static int lock_suspend_event(xc_interface *xch, int domid)
 {
     int fd, rc;
@@ -27,6 +62,7 @@
 
     snprintf(suspend_file, sizeof(suspend_file), "%s_%d_lock.d",
 	    SUSPEND_LOCK_FILE, domid);
+    clean_obsolete_lock(domid);
     mask = umask(022);
     fd = open(suspend_file, O_CREAT | O_EXCL | O_RDWR, 0666);
     if (fd < 0)
@@ -41,6 +77,9 @@
     rc = write_exact(fd, buf, strlen(buf));
     close(fd);
 
+    if(rc)
+    unlink(suspend_file);
+
     return rc;
 }
 
@@ -127,8 +166,7 @@
     return suspend_evtchn;
 
 cleanup:
-    if (suspend_evtchn != -1)
-        xc_suspend_evtchn_release(xch, xce, domid, suspend_evtchn);
+    xc_suspend_evtchn_release(xch, xce, domid, suspend_evtchn);
 
     return -1;
 }
diff -Naur xen/tools/libxen/src/xen_common.c xen-b/tools/libxen/src/xen_common.c
--- xen/tools/libxen/src/xen_common.c	2013-05-30 10:38:28.298374206 -0600
+++ xen-b/tools/libxen/src/xen_common.c	2013-05-30 18:15:29.961707539 -0600
@@ -904,8 +904,15 @@
             0 != strcmp((char *)value_node->children->name, "struct") ||
             value_node->children->children == NULL)
         {
+#if PERMISSIVE
+            fprintf(stderr,
+                    "Expected Map from the server, but didn't get one\n");
+            ((arbitrary_map **)value)[slot] = NULL;
+#else
+
             server_error(s,
                          "Expected Map from the server, but didn't get it");
+#endif
         }
         else
         {
diff -Naur xen/tools/libxl/Makefile xen-b/tools/libxl/Makefile
--- xen/tools/libxl/Makefile	2013-05-30 10:38:28.301707539 -0600
+++ xen-b/tools/libxl/Makefile	2013-05-30 18:15:29.961707539 -0600
@@ -11,7 +11,7 @@
 XLUMAJOR = 4.3
 XLUMINOR = 0
 
-CFLAGS += -Werror -Wno-format-zero-length -Wmissing-declarations \
+CFLAGS += -Wno-format-zero-length -Wmissing-declarations \
 	-Wno-declaration-after-statement -Wformat-nonliteral
 CFLAGS += -I. -fPIC
 
diff -Naur xen/tools/libxl/libxl_dm.c xen-b/tools/libxl/libxl_dm.c
--- xen/tools/libxl/libxl_dm.c	2013-05-30 10:38:28.305040872 -0600
+++ xen-b/tools/libxl/libxl_dm.c	2013-05-30 18:15:29.961707539 -0600
@@ -222,6 +222,12 @@
                 }
             }
         }
+        if (b_info->u.hvm.watchdog || b_info->u.hvm.watchdog_action) {
+            flexarray_append(dm_args, "-watchdog");
+            if (b_info->u.hvm.watchdog_action) {
+                flexarray_vappend(dm_args, "-watchdog-action", b_info->u.hvm.watchdog_action, NULL);
+            }
+        }
         if (b_info->u.hvm.soundhw) {
             flexarray_vappend(dm_args, "-soundhw", b_info->u.hvm.soundhw, NULL);
         }
@@ -520,6 +526,12 @@
                 }
             }
         }
+        if (b_info->u.hvm.watchdog || b_info->u.hvm.watchdog_action) {
+            flexarray_append(dm_args, "-watchdog");
+            if (b_info->u.hvm.watchdog_action) {
+                flexarray_vappend(dm_args, "-watchdog-action", b_info->u.hvm.watchdog_action, NULL);
+            }
+        }
         if (b_info->u.hvm.soundhw) {
             flexarray_vappend(dm_args, "-soundhw", b_info->u.hvm.soundhw, NULL);
         }
diff -Naur xen/tools/libxl/libxl_types.idl xen-b/tools/libxl/libxl_types.idl
--- xen/tools/libxl/libxl_types.idl	2013-05-30 10:38:28.308374206 -0600
+++ xen-b/tools/libxl/libxl_types.idl	2013-05-30 18:15:29.961707539 -0600
@@ -332,6 +332,8 @@
                                        ("usbdevice",        string),
                                        ("soundhw",          string),
                                        ("xen_platform_pci", libxl_defbool),
+                                       ("watchdog",         string),
+                                       ("watchdog_action",  string),
                                        ("usbdevice_list",   libxl_string_list),
                                        ])),
                  ("pv", Struct(None, [("kernel", string),
diff -Naur xen/tools/libxl/xl_cmdimpl.c xen-b/tools/libxl/xl_cmdimpl.c
--- xen/tools/libxl/xl_cmdimpl.c	2013-05-30 10:38:28.311707539 -0600
+++ xen-b/tools/libxl/xl_cmdimpl.c	2013-05-30 18:15:29.961707539 -0600
@@ -1394,6 +1394,8 @@
                         " \"device_model_stubdomain_override\" directive"
                         " for pv guest\n");
         }
+        xlu_cfg_replace_string (config, "watchdog", &b_info->u.hvm.watchdog, 0);
+        xlu_cfg_replace_string (config, "watchdog_action", &b_info->u.hvm.watchdog_action, 0);
     }
 
 
diff -Naur xen/tools/misc/serial-split/Makefile xen-b/tools/misc/serial-split/Makefile
--- xen/tools/misc/serial-split/Makefile	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/tools/misc/serial-split/Makefile	2013-05-30 18:15:29.961707539 -0600
@@ -0,0 +1,20 @@
+CC     ?= gcc
+CFLAGS ?= -Wall -Os
+CFILES = $(wildcard *.c)
+OBJS   = $(patsubst %.c,%.o,$(wildcard *.c))
+TARGET = serial-split
+
+all: $(TARGET)
+
+install: all
+	install -d $(DESTDIR)/usr/bin
+	install -s $(TARGET) $(DESTDIR)/usr/bin/
+
+clean:
+	rm *.o $(TARGET) *~
+
+$(TARGET): $(OBJS)
+	$(CC) $(CFLAGS) -o $@ $^
+
+%.o: %.c Makefile
+	$(CC) $(CFLAGS) -c -o $@ $<
diff -Naur xen/tools/misc/serial-split/serial-split.c xen-b/tools/misc/serial-split/serial-split.c
--- xen/tools/misc/serial-split/serial-split.c	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/tools/misc/serial-split/serial-split.c	2013-05-30 18:15:29.961707539 -0600
@@ -0,0 +1,422 @@
+/*
+ *  serial-split.c
+ *  pdb / console splitter
+ *
+ *  Copyright 2005 Charles Coffing <ccoffing@novell.com>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ */
+
+/*
+ *  Typical setup:
+ *
+ *               Development box          Xen box
+ *                      ...-----+        +-----...
+ *  +---------+                 |        |
+ *  | gdb     |                 |        |
+ *  |         |\ high           |        |
+ *  +---------+ \               |        |
+ *               \+-----------+ | serial | +------------------+
+ *                |  splitter |------------| Xen              |
+ *               /+-----------+ |        | |  - pdb    (com1H)|
+ *  +---------+ /               |        | |  - printk (com1) |
+ *  | console |/ low            |        | +------------------+
+ *  | viewer  |                 |        |
+ *  +---------+                 |        |
+ *                      ...-----+        +-----...
+ */
+
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <termios.h>
+#include <sys/signal.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <netinet/in.h>
+
+const unsigned int DefaultLowPort = 12010;
+const unsigned int DefaultBaud = 115200;
+const char DefaultSerialDevice[] = "/dev/ttyS0";
+
+#define DEBUG 0
+#define MAX(a,b) ((a)<(b)?(b):(a))
+
+
+static int cook_baud(int baud)
+{
+    int cooked_baud = 0;
+    switch (baud)
+    {
+    case     50: cooked_baud =     B50; break;
+    case     75: cooked_baud =     B75; break;
+    case    110: cooked_baud =    B110; break;
+    case    134: cooked_baud =    B134; break;
+    case    150: cooked_baud =    B150; break;
+    case    200: cooked_baud =    B200; break;
+    case    300: cooked_baud =    B300; break;
+    case    600: cooked_baud =    B600; break;
+    case   1200: cooked_baud =   B1200; break;
+    case   1800: cooked_baud =   B1800; break;
+    case   2400: cooked_baud =   B2400; break;
+    case   4800: cooked_baud =   B4800; break;
+    case   9600: cooked_baud =   B9600; break;
+    case  19200: cooked_baud =  B19200; break;
+    case  38400: cooked_baud =  B38400; break;
+    case  57600: cooked_baud =  B57600; break;
+    case 115200: cooked_baud = B115200; break;
+    }
+    return cooked_baud;
+}
+
+
+static int start_listener(unsigned short port)
+{
+    int fd;
+    struct sockaddr_in sin;
+    int on = 1;
+
+    if ((fd = socket (AF_INET, SOCK_STREAM, 0)) < 0)
+    {
+        perror("socket");
+        goto out1;
+    }
+
+    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof (on));
+
+    memset(&sin, 0, sizeof(sin));
+    sin.sin_family = AF_INET;
+    sin.sin_port = htons (port);
+    sin.sin_addr.s_addr = INADDR_ANY;
+    if (bind(fd, (struct sockaddr *)&sin, sizeof(sin)) < 0)
+    {
+        perror("bind");
+        goto out2;
+    }
+
+    if (listen(fd, 1) < 0)
+    {
+        perror("listen");
+        goto out2;
+    }
+
+    fprintf(stderr, "Listening on port %d\n", port);
+
+    return fd;
+
+out2:
+    close(fd);
+out1:
+    return -1;
+}
+
+
+static int accept_conn(int fd)
+{
+    int on = 1;
+    int new_fd;
+    struct sockaddr_in from;
+    socklen_t fromlen = sizeof(from);
+
+    new_fd = accept(fd, (struct sockaddr *)&from, &fromlen);
+    if (new_fd < 0)
+        perror("accept");
+    ioctl(new_fd, FIONBIO, &on);
+
+    fprintf(stderr, "Accepted connection on %d\n", new_fd);
+
+    return new_fd;
+}
+
+
+static void close_conn(int * fd)
+{
+    shutdown(*fd, 2);
+    close(*fd);
+    *fd = -1;
+}
+
+
+static int receive_data(int * fd, char * buf, ssize_t max_bytes, int * poll)
+{
+    ssize_t bytes;
+    if ((bytes = read(*fd, buf, max_bytes)) < 0)
+    {
+        perror("read");
+        *poll = 1;
+        return 0;
+    }
+    else if (bytes == 0)
+    {
+        close_conn(fd);
+        *poll = 0;
+        return 0;
+    }
+    else
+    {
+        if (bytes == max_bytes)
+            *poll = 1;
+        else
+            *poll = 0;
+#if DEBUG
+        {
+            ssize_t i;
+            fprintf(stderr, "Received %d bytes on %d:\n", bytes, *fd);
+            for (i = 0; i < bytes; ++ i)
+            {
+                if ((i & 0xf) == 0)
+                    printf("    ");
+                printf("%02x", buf[i] & 0xff);
+                if (((i+1) & 0xf) == 0 || i + 1 == bytes)
+                    printf("\n");
+                else
+                    printf(" ");
+            }
+        }
+#endif
+        return bytes;
+    }
+}
+
+
+static void set_high_bit(char * buf, size_t bytes)
+{
+    size_t i;
+    for(i = 0; i < bytes; ++ i)
+        buf[i] |= 0x80;
+}
+
+
+static void clear_high_bit(char * buf, size_t bytes)
+{
+    size_t i;
+    for(i = 0; i < bytes; ++ i)
+        buf[i] &= 0x7f;
+}
+
+
+static int open_serial(char const * serial_dev, int baud)
+{
+    struct termios newsertio;
+    int serial_fd;
+    memset(&newsertio, 0, sizeof(newsertio));
+
+    if ((serial_fd = open(serial_dev, O_RDWR | O_NOCTTY | O_NONBLOCK)) < 0)
+    {
+        perror(serial_dev);
+        return -1;
+    }
+
+    newsertio.c_cflag = baud | CS8 | CLOCAL | CREAD;
+    newsertio.c_iflag = IGNBRK | IGNPAR;    /* raw input */
+    newsertio.c_oflag = 0;                  /* raw output */
+    newsertio.c_lflag = 0;                  /* no echo, no signals */
+    newsertio.c_cc[VMIN] = 1;
+    newsertio.c_cc[VTIME] = 0;
+    tcflush(serial_fd, TCIFLUSH);
+    tcsetattr(serial_fd, TCSANOW, &newsertio);
+
+    fprintf(stderr, "Listening on %s\n", serial_dev);
+
+    return serial_fd;
+}
+
+
+static void main_loop(int serial_fd, int low_listener, int high_listener)
+{
+    fd_set rdfds;
+    int low_poll = 0, high_poll = 0, serial_poll = 0;
+    int low_fd = -1, high_fd = -1;
+
+    while(1)
+    {
+        char buf[1024];
+        ssize_t bytes;
+        int max;
+
+        FD_ZERO(&rdfds);
+        FD_SET(low_fd < 0 ? low_listener : low_fd, &rdfds);
+        FD_SET(high_fd < 0 ? high_listener : high_fd, &rdfds);
+        FD_SET(serial_fd, &rdfds);
+
+        max = MAX(low_fd, low_listener);
+        max = MAX(max, high_fd);
+        max = MAX(max, high_listener);
+        max = MAX(max, serial_fd);
+
+        if (select(max + 1, &rdfds, NULL, NULL, NULL) < 0)
+        {
+            perror("select");
+            continue;
+        }
+
+        if (FD_ISSET(low_listener, &rdfds))
+        {
+            assert(low_fd < 0);
+            low_fd = accept_conn(low_listener);
+        }
+
+        if (FD_ISSET(high_listener, &rdfds))
+        {
+            assert(high_fd < 0);
+            high_fd = accept_conn(high_listener);
+        }
+
+        if (low_poll || (low_fd >= 0 && FD_ISSET(low_fd, &rdfds)))
+        {
+            if ((bytes = receive_data(&low_fd, &buf[0], sizeof(buf),
+                                      &low_poll)) > 0)
+            {
+                clear_high_bit(&buf[0], bytes);
+                if (write(serial_fd, &buf[0], bytes) < 0)
+                    perror("write");
+            }
+        }
+
+        if (high_poll || (high_fd >= 0 && FD_ISSET(high_fd, &rdfds)))
+        {
+            if ((bytes = receive_data(&high_fd, &buf[0], sizeof(buf),
+                                      &high_poll)) > 0)
+            {
+                set_high_bit(&buf[0], bytes);
+                if (write(serial_fd, &buf[0], bytes) < 0)
+                    perror("write");
+            }
+        }
+
+        if (serial_poll || FD_ISSET(serial_fd, &rdfds))
+        {
+            if ((bytes = receive_data(&serial_fd, &buf[0], sizeof(buf),
+                                      &serial_poll)) > 0)
+            {
+                ssize_t i;
+                for (i = 0; i < bytes; ++ i)
+                {
+                    if (buf[i] & 0x80)
+                    {
+                        if (high_fd >= 0)
+                        {
+                            buf[i] &= 0x7f;
+                            if ((write(high_fd, &buf[i], 1)) < 0)
+                            {
+                                perror("write");
+                                close_conn(&high_fd);
+                                high_poll = 0;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if (low_fd >= 0)
+                        {
+                            if ((write(low_fd, &buf[i], 1)) < 0)
+                            {
+                                perror("write");
+                                close_conn(&low_fd);
+                                low_poll = 0;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+
+
+static void usage()
+{
+    printf(
+"Description:\n"
+"        Splits the serial port between two TCP ports.  Bytes read from the\n"
+"        serial port will be delivered to one of the two TCP ports (high or\n"
+"        low) depending on whether the high bit is set.  Bytes written to the\n"
+"        TCP ports will be forwarded to the serial port; the high bit will be\n"
+"        set or cleared to denote the source.\n"
+"Usage:\n"
+"        serial-split [-d<serial-device>] [-b<baud>]\n"
+"                     [-l<low-port>] [-h<high-port>]\n"
+"Parameters:\n"
+"        -d<serial-device>  Defaults to %s.\n"
+"        -b<baud>           Baud rate of the serial port.  Defaults to %d.\n"
+"                           Also assumes 8N1.\n"
+"        -l<low-port>       Low TCP port.  Defaults to %d, or one less than\n"
+"                           the high port.\n"
+"        -h<high-port>      High TCP port.  Defaults to %d, or one more than\n"
+"                           the low port.\n",
+DefaultSerialDevice, DefaultBaud, DefaultLowPort, DefaultLowPort + 1);
+
+    exit(1);
+}
+
+
+int main(int argc, char **argv)
+{
+    int cooked_baud = cook_baud(DefaultBaud);
+    char const * serial_dev = DefaultSerialDevice;
+    int low_port = -1, high_port = -1;
+    int serial_fd, low_listener, high_listener;
+
+    while ( --argc != 0 )
+    {
+        char *p = argv[argc];
+        if ( *(p++) != '-' )
+            usage();
+        switch (*(p++))
+        {
+        case 'b':
+            if ( (cooked_baud = cook_baud(atoi(p))) == 0 )
+            {
+                fprintf(stderr, "Bad baud rate\n");
+                exit(1);
+            }
+            break;
+        case 'd':
+            serial_dev = p;
+            break;
+        case 'l':
+            if ((low_port = atoi(p)) <= 0)
+                usage();
+            break;
+        case 'h':
+            if ((high_port = atoi(p)) <= 0)
+                usage();
+            break;
+        default:
+            usage();
+        }
+    }
+
+    if (low_port == -1 && high_port == -1)
+        low_port = DefaultLowPort;
+    if (low_port == -1)
+        low_port = high_port - 1;
+    if (high_port == -1)
+        high_port = low_port + 1;
+
+    if ((serial_fd = open_serial(serial_dev, cooked_baud)) < 0 ||
+        (low_listener = start_listener(low_port)) < 0 ||
+        (high_listener = start_listener(high_port)) < 0)
+        exit(1);
+
+    main_loop(serial_fd, low_listener, high_listener);
+
+    return 0;
+}
+
diff -Naur xen/tools/misc/xend xen-b/tools/misc/xend
--- xen/tools/misc/xend	2013-05-30 10:38:28.315040872 -0600
+++ xen-b/tools/misc/xend	2013-05-30 18:15:29.961707539 -0600
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/python -Es
 #  -*- mode: python; -*-
 #============================================================================
 # Copyright (C) 2004 Mike Wray <mike.wray@hp.com>
diff -Naur xen/tools/pygrub/src/pygrub xen-b/tools/pygrub/src/pygrub
--- xen/tools/pygrub/src/pygrub	2013-05-30 10:38:28.325040872 -0600
+++ xen-b/tools/pygrub/src/pygrub	2013-05-30 18:15:29.965040871 -0600
@@ -17,7 +17,6 @@
 import copy
 import logging
 import platform
-import xen.lowlevel.xc
 
 import curses, _curses, curses.wrapper, curses.textpad, curses.ascii
 import getopt
@@ -26,6 +25,7 @@
 import grub.GrubConf
 import grub.LiloConf
 import grub.ExtLinuxConf
+import xnloader
 
 PYGRUB_VER = 0.6
 FS_READ_MAX = 1024 * 1024
@@ -119,6 +119,7 @@
     fd = os.open(file, os.O_RDONLY)
     buf = os.read(fd, 512)
     os.close(fd)
+    offzerocount = 0
     for poff in (446, 462, 478, 494): # partition offsets
 
         # MBR contains a 16 byte descriptor per partition
@@ -128,6 +129,7 @@
         
         # offset == 0 implies this partition is not enabled
         if offset == 0:
+            offzerocount += 1
             continue
 
         if type == FDISK_PART_SOLARIS or type == FDISK_PART_SOLARIS_OLD:
@@ -148,6 +150,9 @@
         else:
             part_offs.append(offset)
 
+    if offzerocount == 4:
+        # Might be a grub boot sector pretending to be an MBR
+        part_offs.append(0)
     return part_offs
 
 class GrubLineEditor(curses.textpad.Textbox):
@@ -637,51 +642,6 @@
 
     return grubcfg
 
-def supports64bitPVguest():
-    xc = xen.lowlevel.xc.xc()
-    caps = xc.xeninfo()['xen_caps'].split(" ")
-    for cap in caps:
-        if cap == "xen-3.0-x86_64":
-            return True
-    return False
-
-# If nothing has been specified, look for a Solaris domU. If found, perform the
-# necessary tweaks.
-def sniff_solaris(fs, cfg):
-    if not fs.file_exists("/platform/i86xpv/kernel/unix") and \
-       not fs.file_exists("/platform/i86xpv/kernel/amd64/unix"):
-        return cfg
-
-    if not cfg["kernel"]:
-        if supports64bitPVguest() and \
-          fs.file_exists("/platform/i86xpv/kernel/amd64/unix"):
-            cfg["kernel"] = "/platform/i86xpv/kernel/amd64/unix"
-            cfg["ramdisk"] = "/platform/i86pc/amd64/boot_archive"
-        elif fs.file_exists("/platform/i86xpv/kernel/unix"):
-            cfg["kernel"] = "/platform/i86xpv/kernel/unix"
-            cfg["ramdisk"] = "/platform/i86pc/boot_archive"
-        else:
-            return cfg
-
-    # Unpleasant. Typically we'll have 'root=foo -k' or 'root=foo /kernel -k',
-    # and we need to maintain Xen properties (root= and ip=) and the kernel
-    # before any user args.
-    
-    xenargs = ""
-    userargs = ""
-    
-    if not cfg["args"]:
-        cfg["args"] = cfg["kernel"]
-    else:
-        for arg in cfg["args"].split():
-            if re.match("^root=", arg) or re.match("^ip=", arg):
-                xenargs += arg + " "
-            elif arg != cfg["kernel"]:
-                userargs += arg + " "
-        cfg["args"] = xenargs + " " + cfg["kernel"] + " " + userargs
-
-    return cfg
- 
 def sniff_netware(fs, cfg):
     if not fs.file_exists("/nwserver/xnloader.sys"):
         return cfg
@@ -734,6 +694,8 @@
             if len(data) == 0:
                 os.close(tfd)
                 del datafile
+                if file_to_read == "/nwserver/xnloader.sys":
+                    xnloader.patch_netware_loader(ret)
                 return ret
             try:
                 os.write(tfd, data)
@@ -846,10 +808,7 @@
         try:
             fs = fsimage.open(file, offset, bootfsoptions)
 
-            chosencfg = sniff_solaris(fs, incfg)
-
-            if not chosencfg["kernel"]:
-                chosencfg = sniff_netware(fs, incfg)
+            chosencfg = sniff_netware(fs, incfg)
 
             if not chosencfg["kernel"]:
                 chosencfg = run_grub(file, entry, fs, incfg["args"])
diff -Naur xen/tools/python/README.XendConfig xen-b/tools/python/README.XendConfig
--- xen/tools/python/README.XendConfig	2013-05-30 10:38:28.325040872 -0600
+++ xen-b/tools/python/README.XendConfig	2013-05-30 18:15:29.965040871 -0600
@@ -118,6 +118,9 @@
                                 image.vncdisplay
                                 image.vncunused
                                 image.hvm.device_model
+                                image.hvm.actmem
+                                image.hvm.xenpaging_file
+                                image.hvm.xenpaging_extra
                                 image.hvm.display
                                 image.hvm.xauthority
                                 image.hvm.vncconsole
diff -Naur xen/tools/python/README.sxpcfg xen-b/tools/python/README.sxpcfg
--- xen/tools/python/README.sxpcfg	2013-05-30 10:38:28.325040872 -0600
+++ xen-b/tools/python/README.sxpcfg	2013-05-30 18:15:29.965040871 -0600
@@ -51,6 +51,9 @@
   - vncunused
   (HVM)
   - device_model
+  - actmem
+  - xenpaging_file
+  - xenpaging_extra
   - display
   - xauthority
   - vncconsole
diff -Naur xen/tools/python/xen/util/pci.py xen-b/tools/python/xen/util/pci.py
--- xen/tools/python/xen/util/pci.py	2013-05-30 10:38:28.335040872 -0600
+++ xen-b/tools/python/xen/util/pci.py	2013-05-30 18:15:29.965040871 -0600
@@ -1268,7 +1268,11 @@
             pass
 
     def get_info_from_sysfs(self):
-        self.find_capability(0x11)
+        try:
+            self.find_capability(0x11)
+        except PciDeviceParseError, err:
+            log.error("Caught '%s'" % err)
+             return False
         sysfs_mnt = find_sysfs_mnt()
         if sysfs_mnt == None:
             return False
diff -Naur xen/tools/python/xen/xend/XendAPI.py xen-b/tools/python/xen/xend/XendAPI.py
--- xen/tools/python/xen/xend/XendAPI.py	2013-05-30 10:38:28.338374206 -0600
+++ xen-b/tools/python/xen/xend/XendAPI.py	2013-05-30 18:15:29.965040871 -0600
@@ -1941,10 +1941,10 @@
                               bool(live), port, node, ssl, bool(chs))
         return xen_api_success_void()
 
-    def VM_save(self, _, vm_ref, dest, checkpoint):
+    def VM_save(self, _, vm_ref, dest, checkpoint, force):
         xendom = XendDomain.instance()
         xeninfo = xendom.get_vm_by_uuid(vm_ref)
-        xendom.domain_save(xeninfo.getDomid(), dest, checkpoint)
+        xendom.domain_save(xeninfo.getDomid(), dest, checkpoint, force)
         return xen_api_success_void()
 
     def VM_restore(self, _, src, paused):
diff -Naur xen/tools/python/xen/xend/XendAPIConstants.py xen-b/tools/python/xen/xend/XendAPIConstants.py
--- xen/tools/python/xen/xend/XendAPIConstants.py	2013-05-30 10:38:28.338374206 -0600
+++ xen-b/tools/python/xen/xend/XendAPIConstants.py	2013-05-30 18:15:29.965040871 -0600
@@ -45,8 +45,10 @@
 XEN_API_ON_CRASH_BEHAVIOUR = [
     'destroy',
     'coredump_and_destroy',
+    'coredump_destroy',
     'restart',
     'coredump_and_restart',
+    'coredump_restart',
     'preserve',
     'rename_restart'
 ]
diff -Naur xen/tools/python/xen/xend/XendCheckpoint.py xen-b/tools/python/xen/xend/XendCheckpoint.py
--- xen/tools/python/xen/xend/XendCheckpoint.py	2013-05-30 10:38:28.341707539 -0600
+++ xen-b/tools/python/xen/xend/XendCheckpoint.py	2013-05-30 18:15:29.965040871 -0600
@@ -172,7 +172,7 @@
             dominfo.destroy()
             dominfo.testDeviceComplete()
         try:
-            dominfo.setName(domain_name, False)
+            dominfo.setName(domain_name)
         except VmError:
             # Ignore this.  The name conflict (hopefully) arises because we
             # are doing localhost migration; if we are doing a suspend of a
diff -Naur xen/tools/python/xen/xend/XendConfig.py xen-b/tools/python/xen/xend/XendConfig.py
--- xen/tools/python/xen/xend/XendConfig.py	2013-05-30 10:38:28.341707539 -0600
+++ xen-b/tools/python/xen/xend/XendConfig.py	2013-05-30 18:15:29.965040871 -0600
@@ -147,6 +147,9 @@
     'apic': int,
     'boot': str,
     'device_model': str,
+    'actmem': str,
+    'xenpaging_file': str,
+    'xenpaging_extra': str,
     'loader': str,
     'display' : str,
     'fda': str,
@@ -159,6 +162,7 @@
     'nographic': int,
     'nomigrate': int,
     'pae' : int,
+    'extid': int,
     'rtc_timeoffset': int,
     'parallel': str,
     'serial': str,
@@ -192,6 +196,8 @@
     'xen_platform_pci': int,
     "gfx_passthru": int,
     'oos' : int,
+    'watchdog': str,
+    'watchdog_action': str,
 }
 
 # Xen API console 'other_config' keys.
@@ -512,8 +518,16 @@
             self['platform']['nomigrate'] = 0
 
         if self.is_hvm():
+            if 'actmem' not in self['platform']:
+                self['platform']['actmem'] = "0"
+            if 'xenpaging_file' not in self['platform']:
+                self['platform']['xenpaging_file'] = ""
+            if 'xenpaging_extra' not in self['platform']:
+                self['platform']['xenpaging_extra'] = []
             if 'timer_mode' not in self['platform']:
                 self['platform']['timer_mode'] = 1
+            if 'extid' in self['platform'] and int(self['platform']['extid']) == 1:
+                self['platform']['viridian'] = 1
             if 'viridian' not in self['platform']:
                 self['platform']['viridian'] = 0
             if 'rtc_timeoffset' not in self['platform']:
@@ -1865,7 +1879,14 @@
         ports = sxp.child(dev_sxp, 'port')
         for port in ports[1:]:
             try:
-                num, bus = port
+                # When ['port' ['1','']] is saved into sxp file, it will become (port (1 ))
+                # If using this sxp file, here variable "port" will be port=1,
+                # we should process it, otherwise, it will report error.
+                if len(port) == 1:
+                    num = port[0]
+                    bus = ""
+                else:
+                    num, bus = port
                 dev_config['port-%i' % int(num)] = str(bus)
             except TypeError:
                 pass
diff -Naur xen/tools/python/xen/xend/XendDomain.py xen-b/tools/python/xen/xend/XendDomain.py
--- xen/tools/python/xen/xend/XendDomain.py	2013-05-30 10:38:28.341707539 -0600
+++ xen-b/tools/python/xen/xend/XendDomain.py	2013-05-30 18:15:29.968374204 -0600
@@ -1505,7 +1505,7 @@
                     pass
                 sock.close()
 
-    def domain_save(self, domid, dst, checkpoint=False):
+    def domain_save(self, domid, dst, checkpoint=False, force=False):
         """Start saving a domain to file.
 
         @param domid: Domain ID or Name
@@ -1521,6 +1521,9 @@
             if not dominfo:
                 raise XendInvalidDomain(str(domid))
 
+            if os.access(dst, os.F_OK) and not force:
+                raise XendError("Save file:%s exist!\n" % dst)
+
             if dominfo.getDomid() == DOM0_ID:
                 raise XendError("Cannot save privileged domain %s" % str(domid))
             if dominfo._stateGet() != DOM_STATE_RUNNING:
@@ -1832,6 +1835,21 @@
             log.exception(ex)
             raise XendError(str(ex))
 
+    def domain_swaptarget_set(self, domid, mem):
+        """Set the memory limit for a domain.
+
+        @param domid: Domain ID or Name
+        @type domid: int or string.
+        @param mem: memory limit (in MiB)
+        @type mem: int
+        @raise XendError: fail to set memory
+        @rtype: 0
+        """
+        dominfo = self.domain_lookup_nr(domid)
+        if not dominfo:
+            raise XendInvalidDomain(str(domid))
+        dominfo.setSwapTarget(mem)
+
     def domain_maxmem_set(self, domid, mem):
         """Set the memory limit for a domain.
 
diff -Naur xen/tools/python/xen/xend/XendDomainInfo.py xen-b/tools/python/xen/xend/XendDomainInfo.py
--- xen/tools/python/xen/xend/XendDomainInfo.py	2013-05-30 10:38:28.341707539 -0600
+++ xen-b/tools/python/xen/xend/XendDomainInfo.py	2013-05-30 18:15:29.968374204 -0600
@@ -1295,8 +1295,15 @@
                 frontpath = self.getDeviceController(deviceClass).frontendPath(dev)
                 backpath = xstransact.Read(frontpath, "backend")
                 thread.start_new_thread(self.getDeviceController(deviceClass).finishDeviceCleanup, (backpath, path))
-
-            rc = self.getDeviceController(deviceClass).destroyDevice(devid, force)
+            if deviceClass =='vusb':
+                dev = self.getDeviceController(deviceClass).convertToDeviceNumber(devid)
+                state = self.getDeviceController(deviceClass).readBackend(dev, 'state')
+                if state == '1':
+                    rc = self.getDeviceController(deviceClass).destroyDevice(devid, True)
+                else:
+                    rc = self.getDeviceController(deviceClass).destroyDevice(devid, force)
+            else:
+                rc = self.getDeviceController(deviceClass).destroyDevice(devid, force)
             if not force and rm_cfg:
                 # The backend path, other than the device itself,
                 # has to be passed because its accompanied frontend
@@ -1459,6 +1466,17 @@
         pci_conf = self.info['devices'][dev_uuid][1]
         return map(pci_dict_to_bdf_str, pci_conf['devs'])
 
+    def setSwapTarget(self, target):
+        """Set the swap target of this domain.
+        @param target: In MiB.
+        """
+        log.debug("Setting swap target of domain %s (%s) to %d MiB.",
+                  self.info['name_label'], str(self.domid), target)
+
+        if self.domid > 0:
+            self.storeDom("memory/target-tot_pages", target * 1024)
+            self.info['platform']['actmem'] = str(target)
+
     def setMemoryTarget(self, target):
         """Set the memory target of this domain.
         @param target: In MiB.
@@ -2247,6 +2265,8 @@
                  self.info['name_label'], self.domid, self.info['uuid'],
                  new_name, new_uuid)
         self._unwatchVm()
+        if self.image:
+            self.image.destroyXenPaging()
         self._releaseDevices()
         # Remove existing vm node in xenstore
         self._removeVm()
@@ -2884,7 +2904,7 @@
 
             self.guest_bitsize = self.image.getBitSize()
             # Make sure there's enough RAM available for the domain
-            balloon.free(memory + shadow + vtd_mem, self)
+            balloon.free(memory + shadow + vtd_mem + 512, self)
 
             # Set up the shadow memory
             shadow_cur = xc.shadow_mem_control(self.domid, shadow / 1024)
@@ -2919,6 +2939,9 @@
 
             self._createDevices()
 
+            if self.image:
+                self.image.createXenPaging()
+
             self.image.cleanupTmpImages()
 
             self.info['start_time'] = time.time()
@@ -2943,6 +2966,8 @@
         self.refresh_shutdown_lock.acquire()
         try:
             self.unwatchShutdown()
+            if self.image:
+                self.image.destroyXenPaging()
             self._releaseDevices()
             bootloader_tidy(self)
 
@@ -3027,6 +3052,7 @@
         self.refreshShutdown()
 
         log.debug("XendDomainInfo.completeRestore done")
+            self.image.createXenPaging()
 
 
     def _endRestore(self):
@@ -3157,6 +3183,8 @@
             # could also fetch a parsed note from xenstore
             fast = self.info.get_notes().get('SUSPEND_CANCEL') and 1 or 0
             if not fast:
+                if self.image:
+                    self.image.destroyXenPaging()
                 self._releaseDevices()
                 self.testDeviceComplete()
                 self.testvifsComplete()
@@ -3172,6 +3200,8 @@
                 self._storeDomDetails()
 
                 self._createDevices()
+                if self.image:
+                    self.image.createXenPaging()
                 log.debug("XendDomainInfo.resumeDomain: devices created")
 
             xc.domain_resume(self.domid, fast)
@@ -3908,6 +3938,14 @@
             else:
                 config['mode'] = 'RW'
 
+        if dev_class == 'console':
+            if not config.has_key('protocol'):
+                con_type = config.get('type', '')
+                if con_type == 'vnc':
+                    config['protocol'] = 'rfb'
+                elif con_type == 'sdl':
+                    config['protocol'] = 'rdp'
+
         return config
 
     def get_dev_property(self, dev_class, dev_uuid, field):
diff -Naur xen/tools/python/xen/xend/image.py xen-b/tools/python/xen/xend/image.py
--- xen/tools/python/xen/xend/image.py	2013-05-30 10:38:28.345040872 -0600
+++ xen-b/tools/python/xen/xend/image.py	2013-05-30 18:15:29.968374204 -0600
@@ -122,6 +122,10 @@
         self.vm.permissionsVm("image/cmdline", { 'dom': self.vm.getDomid(), 'read': True } )
 
         self.device_model = vmConfig['platform'].get('device_model')
+        self.actmem = str(vmConfig['platform'].get('actmem'))
+        self.xenpaging_file = str(vmConfig['platform'].get('xenpaging_file'))
+        self.xenpaging_extra = vmConfig['platform'].get('xenpaging_extra')
+        self.xenpaging_pid = None
 
         self.display = vmConfig['platform'].get('display')
         self.xauthority = vmConfig['platform'].get('xauthority')
@@ -392,6 +396,87 @@
         sentinel_fifos_inuse[sentinel_path_fifo] = 1
         self.sentinel_path_fifo = sentinel_path_fifo
 
+    def createXenPaging(self):
+        if not self.vm.info.is_hvm():
+            return
+        if self.actmem == "0":
+            return
+        if self.xenpaging_pid:
+            return
+        xenpaging_bin = auxbin.pathTo("xenpaging")
+        args = [xenpaging_bin]
+        args = args + ([ "-f", "/var/lib/xen/xenpaging/%s.%d.paging" % (str(self.vm.info['name_label']), self.vm.getDomid())])
+        if self.xenpaging_extra:
+            args = args + (self.xenpaging_extra)
+        args = args + ([ "-d", "%d" % self.vm.getDomid()])
+        self.xenpaging_logfile = "/var/log/xen/xenpaging-%s.log" %  str(self.vm.info['name_label'])
+        logfile_mode = os.O_WRONLY|os.O_CREAT|os.O_APPEND|os.O_TRUNC
+        null = os.open("/dev/null", os.O_RDONLY)
+        try:
+            os.unlink(self.xenpaging_logfile)
+        except:
+            pass
+        logfd = os.open(self.xenpaging_logfile, logfile_mode, 0644)
+        sys.stderr.flush()
+        contract = osdep.prefork("%s:%d" % (self.vm.getName(), self.vm.getDomid()))
+        xenpaging_pid = os.fork()
+        if xenpaging_pid == 0: #child
+            try:
+                osdep.postfork(contract)
+                os.dup2(null, 0)
+                os.dup2(logfd, 1)
+                os.dup2(logfd, 2)
+                try:
+                    env = dict(os.environ)
+                    log.info("starting %s" % args)
+                    os.execve(xenpaging_bin, args, env)
+                except Exception, e:
+                    log.warn('failed to execute xenpaging: %s' % utils.exception_string(e))
+                    os._exit(126)
+            except:
+                log.warn("starting xenpaging failed")
+                os._exit(127)
+        else:
+            osdep.postfork(contract, abandon=True)
+            self.xenpaging_pid = xenpaging_pid
+            os.close(null)
+            os.close(logfd)
+        self.vm.storeDom("xenpaging/xenpaging-pid", self.xenpaging_pid)
+        self.vm.storeDom("memory/target-tot_pages", int(self.actmem) * 1024)
+
+    def destroyXenPaging(self):
+        if self.actmem == "0":
+            return
+        if self.xenpaging_pid:
+            try:
+                os.kill(self.xenpaging_pid, signal.SIGHUP)
+            except OSError, exn:
+                log.exception(exn)
+            for i in xrange(100):
+                try:
+                    (p, rv) = os.waitpid(self.xenpaging_pid, os.WNOHANG)
+                    if p == self.xenpaging_pid:
+                        break
+                except OSError:
+                    # This is expected if Xend has been restarted within
+                    # the life of this domain.  In this case, we can kill
+                    # the process, but we can't wait for it because it's
+                    # not our child. We continue this loop, and after it is
+                    # terminated make really sure the process is going away
+                    # (SIGKILL).
+                    pass
+                time.sleep(0.1)
+            else:
+                log.warning("xenpaging %d took more than 10s "
+                            "to terminate: sending SIGKILL" % self.xenpaging_pid)
+                try:
+                    os.kill(self.xenpaging_pid, signal.SIGKILL)
+                    os.waitpid(self.xenpaging_pid, 0)
+                except OSError:
+                    # This happens if the process doesn't exist.
+                    pass
+        self.xenpaging_pid = None
+
     def createDeviceModel(self, restore = False):
         if self.device_model is None:
             return
@@ -828,6 +913,7 @@
 
         self.apic = int(vmConfig['platform'].get('apic', 0))
         self.acpi = int(vmConfig['platform'].get('acpi', 0))
+        self.extid = int(vmConfig['platform'].get('extid', 0))
         self.guest_os_type = vmConfig['platform'].get('guest_os_type')
         self.memory_sharing = int(vmConfig['memory_sharing'])
         try:
@@ -855,7 +941,8 @@
 
         dmargs = [ 'boot', 'fda', 'fdb', 'soundhw',
                    'localtime', 'serial', 'stdvga', 'isa',
-                   'acpi', 'usb', 'usbdevice', 'gfx_passthru' ]
+                   'acpi', 'usb', 'usbdevice', 'gfx_passthru',
+                   'watchdog', 'watchdog_action' ]
 
         for a in dmargs:
             v = vmConfig['platform'].get(a)
@@ -863,6 +950,7 @@
             # python doesn't allow '-' in variable names
             if a == 'stdvga': a = 'std-vga'
             if a == 'keymap': a = 'k'
+            if a == 'watchdog_action': a = 'watchdog-action'
 
             # Handle booleans gracefully
             if a in ['localtime', 'std-vga', 'isa', 'usb', 'acpi']:
@@ -1036,7 +1124,7 @@
 
     def configure(self, vmConfig):
         HVMImageHandler.configure(self, vmConfig)
-        self.pae = int(vmConfig['platform'].get('pae',  0))
+        self.pae = int(vmConfig['platform'].get('pae',  1))
         self.vramsize = int(vmConfig['platform'].get('videoram',4)) * 1024
 
     def buildDomain(self):
diff -Naur xen/tools/python/xen/xend/server/BlktapController.py xen-b/tools/python/xen/xend/server/BlktapController.py
--- xen/tools/python/xen/xend/server/BlktapController.py	2013-05-30 10:38:28.345040872 -0600
+++ xen-b/tools/python/xen/xend/server/BlktapController.py	2013-05-30 18:15:29.968374204 -0600
@@ -15,6 +15,7 @@
     'ram',
     'qcow',
     'qcow2',
+    'cdrom',
     'ioemu',
     ]
 
diff -Naur xen/tools/python/xen/xend/server/DevController.py xen-b/tools/python/xen/xend/server/DevController.py
--- xen/tools/python/xen/xend/server/DevController.py	2013-05-30 10:38:28.345040872 -0600
+++ xen-b/tools/python/xen/xend/server/DevController.py	2013-05-30 18:15:29.968374204 -0600
@@ -149,7 +149,10 @@
         (status, err) = self.waitForBackend(devid)
 
         if status == Timeout:
-            self.destroyDevice(devid, False)
+            #Clean timeout backend resource
+            dev = self.convertToDeviceNumber(devid)
+            self.writeBackend(dev, HOTPLUG_STATUS_NODE, HOTPLUG_STATUS_ERROR)
+            self.destroyDevice(devid, True)
             raise VmError("Device %s (%s) could not be connected. "
                           "Hotplug scripts not working." %
                           (devid, self.deviceClass))
@@ -554,7 +557,17 @@
 
             xswatch(statusPath, hotplugStatusCallback, ev, result)
 
-            ev.wait(DEVICE_CREATE_TIMEOUT)
+            for i in range(1, 50):
+                ev.wait(DEVICE_CREATE_TIMEOUT/50)
+                status = xstransact.Read(statusPath)
+                if status is not None:
+                    if status == HOTPLUG_STATUS_ERROR:
+                        result['status'] = Error
+                    elif status == HOTPLUG_STATUS_BUSY:
+                        result['status'] = Busy
+                    else:
+                        result['status'] = Connected
+                    break
 
             err = xstransact.Read(backpath, HOTPLUG_ERROR_NODE)
 
@@ -571,7 +584,12 @@
 
         xswatch(statusPath, deviceDestroyCallback, ev, result)
 
-        ev.wait(DEVICE_DESTROY_TIMEOUT)
+        for i in range(1, 50):
+            ev.wait(DEVICE_DESTROY_TIMEOUT/50)
+            status = xstransact.Read(statusPath)
+            if status is None:
+                result['status'] = Disconnected
+                break 
 
         return result['status']
 
diff -Naur xen/tools/python/xen/xm/cpupool.py xen-b/tools/python/xen/xm/cpupool.py
--- xen/tools/python/xen/xm/cpupool.py	2013-05-30 10:38:28.351707539 -0600
+++ xen-b/tools/python/xen/xm/cpupool.py	2013-05-30 18:15:29.968374204 -0600
@@ -157,9 +157,17 @@
             #    ["0,2","1,3"]       -> [[0,2],[1,3]]
             #    ["0-3,^1","1-4,^2"] -> [[0,2,3],[1,3,4]]
             try:
-                for c in cfg_cpus:
-                    cpus = cnv(c)
-                    cpus_list.append(cpus)
+                cpus_str = ""
+                list_len = len(cfg_cpus)
+                n = 0
+                while n < list_len:
+                    if type(cfg_cpus[n]) != str:
+                        raise SyntaxError('cpus = %s' % cfg_cpus)
+                    cpus_str += cfg_cpus[n]
+                    n += 1
+                    if n < list_len:
+                        cpus_str += ', '
+                cpus_list = cnv(cpus_str)
             except ValueError, e:
                 raise err('cpus = %s: %s' % (cfg_cpus, e))
     else:
diff -Naur xen/tools/python/xen/xm/create.py xen-b/tools/python/xen/xm/create.py
--- xen/tools/python/xen/xm/create.py	2013-05-30 10:38:28.351707539 -0600
+++ xen-b/tools/python/xen/xm/create.py	2013-05-30 18:15:29.968374204 -0600
@@ -36,7 +36,7 @@
 from xen.util import blkif
 from xen.util import vscsi_util
 import xen.util.xsm.xsm as security
-from xen.xm.main import serverType, SERVER_XEN_API, get_single_vm
+from xen.xm.main import serverType, SERVER_XEN_API, SERVER_LEGACY_XMLRPC, get_single_vm
 from xen.util import utils, auxbin
 from xen.util.pci import dev_dict_to_sxp, \
                          parse_pci_name_extended, PciDeviceParseError
@@ -242,6 +242,10 @@
           use="""Expose Viridian interface to x86 HVM guest?
           (Default is 0).""")
 
+gopts.var('extid', val='EXTID',
+          fn=set_int, default=0,
+          use="Specify extention ID for a HVM domain.")
+
 gopts.var('acpi', val='ACPI',
           fn=set_int, default=1,
           use="Disable or enable ACPI of HVM domain.")
@@ -473,6 +477,18 @@
           fn=set_value, default=None,
           use="Set the path of the root NFS directory.")
 
+gopts.var('actmem', val='NUM',
+          fn=set_value, default='0',
+          use="Number of pages to swap.")
+
+gopts.var('xenpaging_file', val='PATH',
+          fn=set_value, default=None,
+          use="pagefile to use (optional)")
+
+gopts.var('xenpaging_extra', val='string1,string2',
+          fn=append_value, default=[],
+          use="additional args for xenpaging (optional)")
+
 gopts.var('device_model', val='FILE',
           fn=set_value, default=None,
           use="Path to device model program.")
@@ -517,6 +533,21 @@
           fn=set_value, default='',
           use="Name of USB device to add?")
 
+gopts.var('watchdog', val='NAME',
+          fn=set_value, default='',
+          use="Watchdog device to use. May be ib700 or i6300esb")
+
+gopts.var('watchdog_action', val='reset|shutdown|poweroff|pause|none|dump',
+          fn=set_value, default="reset",
+          use="""Action when watchdog timer expires:
+          - reset:     Default, forcefully reset the guest;
+          - shutdown:  Gracefully shutdown the guest (not recommended);
+          - poweroff:  Forcefully power off the guest;
+          - pause:     Pause the guest;
+          - none:      Do nothing;
+          - dump:      Automatically dump the guest;
+          """)
+
 gopts.var('description', val='NAME',
           fn=set_value, default='',
           use="Description of a domain")
@@ -1032,6 +1063,9 @@
     args = [ 'acpi', 'apic',
              'boot',
              'cpuid', 'cpuid_check',
+             'actmem',
+             'xenpaging_file',
+             'xenpaging_extra',
              'device_model', 'display',
              'fda', 'fdb',
              'gfx_passthru', 'guest_os_type',
@@ -1047,7 +1081,7 @@
              'timer_mode',
              'usb', 'usbdevice',
              'vcpus', 'vnc', 'vncconsole', 'vncdisplay', 'vnclisten',
-             'vncunused', 'viridian', 'vpt_align',
+             'vncunused', 'vpt_align',
              'xauthority', 'xen_extended_power_mgmt', 'xen_platform_pci',
              'memory_sharing' ]
 
@@ -1056,6 +1090,10 @@
             config_image.append([a, vals.__dict__[a]])
     if vals.vncpasswd is not None:
         config_image.append(['vncpasswd', vals.vncpasswd])
+    if vals.extid and vals.extid == 1:
+        config_image.append(['viridian', vals.extid])
+    elif vals.viridian:
+        config_image.append(['viridian', vals.viridian])
 
 
 def make_config(vals):
@@ -1072,6 +1110,7 @@
         if hasattr(vals, 'vcpus'):
             vcpus = getattr(vals, 'vcpus')
 
+             'watchdog', 'watchdog_action',
         if maxvcpus and not vcpus:
             config.append(['vcpus', maxvcpus])
         if maxvcpus and vcpus:
@@ -1465,7 +1504,7 @@
             except IOError, exn:
                 raise OptionError("Cannot read file %s: %s" % (config, exn[1]))
         
-        if serverType == SERVER_XEN_API:
+        if serverType == SERVER_XEN_API or serverType == SERVER_LEGACY_XMLRPC:
             from xen.xm.xenapi_create import sxp2xml
             sxp2xml_inst = sxp2xml()
             doc = sxp2xml_inst.convert_sxp_to_xml(config, transient=True)
@@ -1473,7 +1512,7 @@
         if opts.vals.dryrun and not opts.is_xml:
             SXPPrettyPrint.prettyprint(config)
 
-        if opts.vals.xmldryrun and serverType == SERVER_XEN_API:
+        if opts.vals.xmldryrun:
             print doc.toprettyxml()
 
     if opts.vals.dryrun or opts.vals.xmldryrun:
diff -Naur xen/tools/python/xen/xm/main.py xen-b/tools/python/xen/xm/main.py
--- xen/tools/python/xen/xm/main.py	2013-05-30 10:38:28.355040872 -0600
+++ xen-b/tools/python/xen/xm/main.py	2013-05-30 18:15:29.971707539 -0600
@@ -114,6 +114,8 @@
                      'Set the maximum amount reservation for a domain.'),
     'mem-set'     : ('<Domain> <Mem>',
                      'Set the current memory usage for a domain.'),
+    'mem-swap-target' : ('<Domain> <Mem>',
+                     'Set the memory usage for a domain.'),
     'migrate'     : ('<Domain> <Host>',
                      'Migrate a domain to another machine.'),
     'pause'       : ('<Domain>', 'Pause execution of a domain.'),
@@ -121,7 +123,7 @@
     'reset'       : ('<Domain>', 'Reset a domain.'),
     'restore'     : ('<CheckpointFile> [-p]',
                      'Restore a domain from a saved state.'),
-    'save'        : ('[-c] <Domain> <CheckpointFile>',
+    'save'        : ('[-c|-f] <Domain> <CheckpointFile>',
                      'Save a domain state to restore later.'),
     'shutdown'    : ('<Domain> [-waRH]', 'Shutdown a domain.'),
     'top'         : ('', 'Monitor a host and the domains in real time.'),
@@ -341,6 +343,7 @@
     ),
     'save': (
        ('-c', '--checkpoint', 'Leave domain running after creating snapshot'),
+       ('-f', '--force', 'Force to overwrite exist file'),
     ),
     'restore': (
        ('-p', '--paused', 'Do not unpause domain after restoring it'),
@@ -862,18 +865,21 @@
 
 def xm_save(args):
 
-    arg_check(args, "save", 2, 3)
+    arg_check(args, "save", 2, 4)
     
     try:
-        (options, params) = getopt.gnu_getopt(args, 'c', ['checkpoint'])
+        (options, params) = getopt.gnu_getopt(args, 'cf', ['checkpoint', 'force'])
     except getopt.GetoptError, opterr:
         err(opterr)
         usage('save')
 
     checkpoint = False
+    force = False
     for (k, v) in options:
         if k in ['-c', '--checkpoint']:
             checkpoint = True
+        if k in ['-f', '--force']:
+            force = True
 
     if len(params) != 2:
         err("Wrong number of parameters")
@@ -1580,6 +1586,17 @@
         mem_target = int_unit(args[1], 'm')
         server.xend.domain.setMemoryTarget(dom, mem_target)
 
+def xm_mem_swap_target(args):
+    arg_check(args, "mem-swap-target", 2)
+
+    dom = args[0]
+
+    if serverType == SERVER_XEN_API:
+        err("xenapi not supported")
+    else:
+        swap_target = int_unit(args[1], 'm')
+        server.xend.domain.swaptarget_set(dom, swap_target)
+
 def xm_usb_add(args):
     arg_check(args, "usb-add", 2)
     server.xend.domain.usb_add(args[0],args[1])
@@ -3782,6 +3799,7 @@
     # memory commands
     "mem-max": xm_mem_max,
     "mem-set": xm_mem_set,
+    "mem-swap-target": xm_mem_swap_target,
     # cpu commands
     "vcpu-pin": xm_vcpu_pin,
     "vcpu-list": xm_vcpu_list,
diff -Naur xen/tools/python/xen/xm/xenapi_create.py xen-b/tools/python/xen/xm/xenapi_create.py
--- xen/tools/python/xen/xm/xenapi_create.py	2013-05-30 10:38:28.355040872 -0600
+++ xen-b/tools/python/xen/xm/xenapi_create.py	2013-05-30 18:15:29.971707539 -0600
@@ -1046,6 +1046,9 @@
             'acpi',
             'apic',
             'boot',
+            'actmem',
+            'xenpaging_file',
+            'xenpaging_extra',
             'device_model',
             'loader',
             'fda',
@@ -1074,7 +1077,9 @@
             'xen_platform_pci',
             'tsc_mode'
             'description',
-            'nomigrate'
+            'nomigrate',
+            'watchdog',
+            'watchdog_action'
         ]
 
         platform_configs = []
diff -Naur xen/tools/tests/mce-test/tools/Makefile xen-b/tools/tests/mce-test/tools/Makefile
--- xen/tools/tests/mce-test/tools/Makefile	2013-05-30 10:38:28.358374206 -0600
+++ xen-b/tools/tests/mce-test/tools/Makefile	2013-05-30 18:15:29.971707539 -0600
@@ -1,7 +1,7 @@
 XEN_ROOT=$(CURDIR)/../../../..
 include $(XEN_ROOT)/tools/Rules.mk
 
-CFLAGS += -Werror
+CFLAGS +=
 CFLAGS += $(CFLAGS_libxenctrl)
 CFLAGS += $(CFLAGS_libxenguest)
 CFLAGS += $(CFLAGS_libxenstore) 
diff -Naur xen/tools/tests/mem-sharing/Makefile xen-b/tools/tests/mem-sharing/Makefile
--- xen/tools/tests/mem-sharing/Makefile	2013-05-30 10:38:28.358374206 -0600
+++ xen-b/tools/tests/mem-sharing/Makefile	2013-05-30 18:15:29.971707539 -0600
@@ -1,7 +1,7 @@
 XEN_ROOT=$(CURDIR)/../../..
 include $(XEN_ROOT)/tools/Rules.mk
 
-CFLAGS += -Werror
+CFLAGS +=
 
 CFLAGS += $(CFLAGS_libxenctrl)
 CFLAGS += $(CFLAGS_xeninclude)
diff -Naur xen/tools/tests/xen-access/Makefile xen-b/tools/tests/xen-access/Makefile
--- xen/tools/tests/xen-access/Makefile	2013-05-30 10:38:28.358374206 -0600
+++ xen-b/tools/tests/xen-access/Makefile	2013-05-30 18:15:29.971707539 -0600
@@ -1,7 +1,7 @@
 XEN_ROOT=$(CURDIR)/../../..
 include $(XEN_ROOT)/tools/Rules.mk
 
-CFLAGS += -Werror
+CFLAGS +=
 
 CFLAGS += $(CFLAGS_libxenctrl)
 CFLAGS += $(CFLAGS_libxenguest)
diff -Naur xen/tools/xenstat/xentop/Makefile xen-b/tools/xenstat/xentop/Makefile
--- xen/tools/xenstat/xentop/Makefile	2013-05-30 10:38:28.365040872 -0600
+++ xen-b/tools/xenstat/xentop/Makefile	2013-05-30 18:15:29.971707539 -0600
@@ -18,7 +18,7 @@
 all install xentop:
 else
 
-CFLAGS += -DGCC_PRINTF -Wall -Werror $(CFLAGS_libxenstat)
+CFLAGS += -DGCC_PRINTF -Wall $(CFLAGS_libxenstat)
 LDLIBS += $(LDLIBS_libxenstat) $(CURSES_LIBS) $(SOCKET_LIBS)
 CFLAGS += -DHOST_$(XEN_OS)
 
diff -Naur xen/tools/xenstore/xenstore.h xen-b/tools/xenstore/xenstore.h
--- xen/tools/xenstore/xenstore.h	2013-05-30 10:38:28.365040872 -0600
+++ xen-b/tools/xenstore/xenstore.h	2013-05-30 18:15:29.971707539 -0600
@@ -26,6 +26,7 @@
 
 #define XS_OPEN_READONLY	1UL<<0
 #define XS_OPEN_SOCKETONLY      1UL<<1
+#define XS_OPEN_DOMAINONLY      1UL<<2
 
 /*
  * Setting XS_UNWATCH_FILTER arranges that after xs_unwatch, no
diff -Naur xen/tools/xenstore/xenstore_client.c xen-b/tools/xenstore/xenstore_client.c
--- xen/tools/xenstore/xenstore_client.c	2013-05-30 10:38:28.365040872 -0600
+++ xen-b/tools/xenstore/xenstore_client.c	2013-05-30 18:15:29.971707539 -0600
@@ -629,7 +629,7 @@
 	    max_width = ws.ws_col - 2;
     }
 
-    xsh = xs_open(socket ? XS_OPEN_SOCKETONLY : 0);
+    xsh = xs_open(socket ? XS_OPEN_SOCKETONLY : XS_OPEN_DOMAINONLY);
     if (xsh == NULL) err(1, "xs_open");
 
 again:
diff -Naur xen/tools/xenstore/xs.c xen-b/tools/xenstore/xs.c
--- xen/tools/xenstore/xs.c	2013-05-30 10:38:28.368374206 -0600
+++ xen-b/tools/xenstore/xs.c	2013-05-30 18:15:29.971707539 -0600
@@ -278,17 +278,19 @@
 
 struct xs_handle *xs_domain_open(void)
 {
-	return xs_open(0);
+	return xs_open(XS_OPEN_DOMAINONLY);
 }
 
 struct xs_handle *xs_open(unsigned long flags)
 {
 	struct xs_handle *xsh = NULL;
 
+	if (!(flags & XS_OPEN_DOMAINONLY)) {
 	if (flags & XS_OPEN_READONLY)
 		xsh = get_handle(xs_daemon_socket_ro());
 	else
 		xsh = get_handle(xs_daemon_socket());
+	}
 
 	if (!xsh && !(flags & XS_OPEN_SOCKETONLY))
 		xsh = get_handle(xs_domain_dev());
diff -Naur xen/unmodified_drivers/linux-2.6/Module.supported xen-b/unmodified_drivers/linux-2.6/Module.supported
--- xen/unmodified_drivers/linux-2.6/Module.supported	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/unmodified_drivers/linux-2.6/Module.supported	2013-05-30 18:15:29.975040873 -0600
@@ -0,0 +1,6 @@
+xen-vbd
+xen-platform-pci
+xen-vnif
+xenbus
+xen-balloon
+xen-scsi
diff -Naur xen/unmodified_drivers/linux-2.6/platform-pci/evtchn.c xen-b/unmodified_drivers/linux-2.6/platform-pci/evtchn.c
--- xen/unmodified_drivers/linux-2.6/platform-pci/evtchn.c	2013-05-30 10:38:28.381707539 -0600
+++ xen-b/unmodified_drivers/linux-2.6/platform-pci/evtchn.c	2013-05-30 18:15:29.975040873 -0600
@@ -40,7 +40,9 @@
 #include <xen/platform-compat.h>
 #endif
 
+#ifndef shared_info_area
 void *shared_info_area;
+#endif
 
 #define is_valid_evtchn(x)	((x) != 0)
 #define evtchn_from_irq(x)	(irq_evtchn[irq].evtchn)
diff -Naur xen/unmodified_drivers/linux-2.6/platform-pci/platform-pci.c xen-b/unmodified_drivers/linux-2.6/platform-pci/platform-pci.c
--- xen/unmodified_drivers/linux-2.6/platform-pci/platform-pci.c	2013-05-30 10:38:28.385040872 -0600
+++ xen-b/unmodified_drivers/linux-2.6/platform-pci/platform-pci.c	2013-05-30 18:15:29.975040873 -0600
@@ -27,6 +27,7 @@
 #include <linux/pci.h>
 #include <linux/init.h>
 #include <linux/version.h>
+#include <linux/dmi.h>
 #include <linux/interrupt.h>
 #include <linux/vmalloc.h>
 #include <linux/mm.h>
@@ -76,7 +77,6 @@
 static int __devinit init_xen_info(void)
 {
 	struct xen_add_to_physmap xatp;
-	extern void *shared_info_area;
 
 #ifdef __ia64__
 	xencomm_initialize();
@@ -84,6 +84,7 @@
 
 	setup_xen_features();
 
+#ifndef shared_info_area
 	shared_info_frame = alloc_xen_mmio(PAGE_SIZE) >> PAGE_SHIFT;
 	xatp.domid = DOMID_SELF;
 	xatp.idx = 0;
@@ -96,6 +97,11 @@
 		ioremap(shared_info_frame << PAGE_SHIFT, PAGE_SIZE);
 	if (shared_info_area == NULL)
 		panic("can't map shared info\n");
+#else
+	shared_info_frame = __pa(shared_info_area) >> PAGE_SHIFT;
+	printk(KERN_INFO "Using kernel provided shared info (pfn=%lx)\n",
+	       shared_info_frame);
+#endif
 
 	return 0;
 }
@@ -469,6 +475,18 @@
 
 MODULE_DEVICE_TABLE(pci, platform_pci_tbl);
 
+static const struct dmi_system_id platform_dmi_tbl[] = {
+	{
+		.ident = "Xen PV-on-HVM",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Xen"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "HVM domU"),
+		},
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(dmi, platform_dmi_tbl);
+
 static struct pci_driver platform_driver = {
 	name:     DRV_NAME,
 	probe:    platform_pci_init,
diff -Naur xen/unmodified_drivers/linux-2.6/platform-pci/platform-pci.h xen-b/unmodified_drivers/linux-2.6/platform-pci/platform-pci.h
--- xen/unmodified_drivers/linux-2.6/platform-pci/platform-pci.h	2013-05-30 10:38:28.385040872 -0600
+++ xen-b/unmodified_drivers/linux-2.6/platform-pci/platform-pci.h	2013-05-30 18:15:29.975040873 -0600
@@ -27,6 +27,11 @@
 unsigned long alloc_xen_mmio(unsigned long len);
 void platform_pci_resume(void);
 
+#ifdef CONFIG_ENLIGHTEN_SPINLOCKS
+#define shared_info_area xen_shared_info
+#endif
+extern void *shared_info_area;
+
 extern struct pci_dev *xen_platform_pdev;
 
 #endif /* _XEN_PLATFORM_PCI_H */
diff -Naur xen/xen/Makefile xen-b/xen/Makefile
--- xen/xen/Makefile	2013-05-30 10:38:28.385040872 -0600
+++ xen-b/xen/Makefile	2013-05-30 18:17:53.885040869 -0600
@@ -13,6 +13,8 @@
 export XEN_ROOT := $(BASEDIR)/..
 
 EFI_MOUNTPOINT ?= /boot/efi
+EFI_VENDOR=arch
+LD_EFI ?= $(LD)
 
 .PHONY: default
 default: build
@@ -46,7 +48,7 @@
 		ln -sf $(notdir $(TARGET))-$(XEN_FULLVERSION).efi $(DESTDIR)$(EFI_DIR)/$(notdir $(TARGET))-$(XEN_VERSION).efi; \
 		ln -sf $(notdir $(TARGET))-$(XEN_FULLVERSION).efi $(DESTDIR)$(EFI_DIR)/$(notdir $(TARGET)).efi; \
 		if [ -n '$(EFI_MOUNTPOINT)' -a -n '$(EFI_VENDOR)' ]; then \
-			$(INSTALL_DATA) $(TARGET).efi $(DESTDIR)$(EFI_MOUNTPOINT)/efi/$(EFI_VENDOR)/$(notdir $(TARGET))-$(XEN_FULLVERSION).efi; \
+			$(INSTALL_DATA) $(TARGET).efi $(DESTDIR)$(EFI_MOUNTPOINT)/EFI/$(EFI_VENDOR)/$(notdir $(TARGET))-$(XEN_FULLVERSION).efi; \
 		elif [ "$(DESTDIR)" = "$(patsubst $(shell cd $(XEN_ROOT) && pwd)/%,%,$(DESTDIR))" ]; then \
 			echo 'EFI installation only partially done (EFI_VENDOR not set)' >&2; \
 		fi; \
diff -Naur xen/xen/arch/arm/Rules.mk xen-b/xen/arch/arm/Rules.mk
--- xen/xen/arch/arm/Rules.mk	2013-05-30 10:38:28.385040872 -0600
+++ xen-b/xen/arch/arm/Rules.mk	2013-05-30 18:15:29.975040873 -0600
@@ -11,7 +11,7 @@
 HAS_ARM_HDLCD := y
 
 CFLAGS += -fno-builtin -fno-common -Wredundant-decls
-CFLAGS += -iwithprefix include -Werror -Wno-pointer-arith -pipe
+CFLAGS += -iwithprefix include -Wno-pointer-arith -pipe
 CFLAGS += -I$(BASEDIR)/include
 
 $(call cc-options-add,CFLAGS,CC,$(EMBEDDED_EXTRA_CFLAGS))
diff -Naur xen/xen/arch/arm/gic.c xen-b/xen/arch/arm/gic.c
--- xen/xen/arch/arm/gic.c	2013-05-30 10:38:28.388374206 -0600
+++ xen-b/xen/arch/arm/gic.c	2013-05-30 18:15:29.975040873 -0600
@@ -27,7 +27,6 @@
 #include <xen/serial.h>
 #include <xen/softirq.h>
 #include <xen/list.h>
-#include <xen/device_tree.h>
 #include <asm/p2m.h>
 #include <asm/domain.h>
 
@@ -44,7 +43,6 @@
     paddr_t dbase;       /* Address of distributor registers */
     paddr_t cbase;       /* Address of CPU interface registers */
     paddr_t hbase;       /* Address of virtual interface registers */
-    paddr_t vbase;       /* Address of virtual cpu interface registers */
     unsigned int lines;  /* Number of interrupts (SPIs + PPIs + SGIs) */
     struct dt_irq maintenance; /* IRQ maintenance */
     unsigned int cpus;
diff -Naur xen/xen/arch/x86/Rules.mk xen-b/xen/arch/x86/Rules.mk
--- xen/xen/arch/x86/Rules.mk	2013-05-30 10:38:28.391707539 -0600
+++ xen-b/xen/arch/x86/Rules.mk	2013-05-30 18:15:29.975040873 -0600
@@ -26,7 +26,7 @@
 endif
 
 CFLAGS += -fno-builtin -fno-common -Wredundant-decls
-CFLAGS += -iwithprefix include -Werror -Wno-pointer-arith -pipe
+CFLAGS += -iwithprefix include -Wno-pointer-arith -pipe
 CFLAGS += -I$(BASEDIR)/include 
 CFLAGS += -I$(BASEDIR)/include/asm-x86/mach-generic
 CFLAGS += -I$(BASEDIR)/include/asm-x86/mach-default
diff -Naur xen/xen/arch/x86/hvm/stdvga.c xen-b/xen/arch/x86/hvm/stdvga.c
--- xen/xen/arch/x86/hvm/stdvga.c	2013-05-30 10:38:28.405040872 -0600
+++ xen-b/xen/arch/x86/hvm/stdvga.c	2013-05-30 18:15:29.975040873 -0600
@@ -135,7 +135,10 @@
 
     /* When in standard vga mode, emulate here all writes to the vram buffer
      * so we can immediately satisfy reads without waiting for qemu. */
-    s->stdvga = (s->sr[7] == 0x00);
+    s->stdvga =
+        (s->sr[7] == 0x00) &&  /* standard vga mode */
+        (s->gr[6] == 0x05);    /* misc graphics register w/ MemoryMapSelect=1
+                                * 0xa0000-0xaffff (64k region), AlphaDis=1 */
 
     if ( !prev_stdvga && s->stdvga )
     {
diff -Naur xen/xen/arch/x86/io_apic.c xen-b/xen/arch/x86/io_apic.c
--- xen/xen/arch/x86/io_apic.c	2013-05-30 10:38:28.408374206 -0600
+++ xen-b/xen/arch/x86/io_apic.c	2013-05-30 18:15:29.975040873 -0600
@@ -2026,7 +2026,10 @@
         io_apic_irqs = ~PIC_IRQS;
 
     printk("ENABLING IO-APIC IRQs\n");
-    printk(" -> Using %s ACK method\n", ioapic_ack_new ? "new" : "old");
+    if (!directed_eoi_enabled && !ioapic_ack_forced) {
+        ioapic_ack_new = (nr_ioapics > 1);
+        printk(" -> Using %s ACK method\n", ioapic_ack_new ? "new" : "old");
+    }
 
     if (ioapic_ack_new) {
         ioapic_level_type.ack = irq_complete_move;
diff -Naur xen/xen/arch/x86/io_apic.c.orig xen-b/xen/arch/x86/io_apic.c.orig
--- xen/xen/arch/x86/io_apic.c.orig	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/xen/arch/x86/io_apic.c.orig	2013-05-30 10:38:28.408374206 -0600
@@ -0,0 +1,2597 @@
+/*
+ *	Intel IO-APIC support for multi-Pentium hosts.
+ *
+ *	Copyright (C) 1997, 1998, 1999, 2000 Ingo Molnar, Hajnalka Szabo
+ *
+ *	Many thanks to Stig Venaas for trying out countless experimental
+ *	patches and reporting/debugging problems patiently!
+ *
+ *	(c) 1999, Multiple IO-APIC support, developed by
+ *	Ken-ichi Yaku <yaku@css1.kbnes.nec.co.jp> and
+ *      Hidemi Kishimoto <kisimoto@css1.kbnes.nec.co.jp>,
+ *	further tested and cleaned up by Zach Brown <zab@redhat.com>
+ *	and Ingo Molnar <mingo@redhat.com>
+ *
+ *	Fixes
+ *	Maciej W. Rozycki	:	Bits for genuine 82489DX APICs;
+ *					thanks to Eric Gilmore
+ *					and Rolf G. Tews
+ *					for testing these extensively
+ *	Paul Diefenbaugh	:	Added full ACPI support
+ */
+
+#include <xen/config.h>
+#include <xen/lib.h>
+#include <xen/init.h>
+#include <xen/irq.h>
+#include <xen/delay.h>
+#include <xen/sched.h>
+#include <xen/acpi.h>
+#include <xen/keyhandler.h>
+#include <asm/mc146818rtc.h>
+#include <asm/smp.h>
+#include <asm/desc.h>
+#include <asm/msi.h>
+#include <mach_apic.h>
+#include <io_ports.h>
+#include <public/physdev.h>
+#include <xen/trace.h>
+
+/* Where if anywhere is the i8259 connect in external int mode */
+static struct { int pin, apic; } ioapic_i8259 = { -1, -1 };
+
+static DEFINE_SPINLOCK(ioapic_lock);
+
+bool_t __read_mostly skip_ioapic_setup;
+bool_t __initdata ioapic_ack_new = 1;
+bool_t __initdata ioapic_ack_forced = 0;
+
+/*
+ * # of IRQ routing registers
+ */
+int __read_mostly nr_ioapic_entries[MAX_IO_APICS];
+int __read_mostly nr_ioapics;
+
+/*
+ * Rough estimation of how many shared IRQs there are, can
+ * be changed anytime.
+ */
+#define MAX_PLUS_SHARED_IRQS nr_irqs_gsi
+#define PIN_MAP_SIZE (MAX_PLUS_SHARED_IRQS + nr_irqs_gsi)
+
+
+#define ioapic_has_eoi_reg(apic) (mp_ioapics[(apic)].mpc_apicver >= 0x20)
+
+static int apic_pin_2_gsi_irq(int apic, int pin);
+
+static vmask_t *__read_mostly vector_map[MAX_IO_APICS];
+
+static void share_vector_maps(unsigned int src, unsigned int dst)
+{
+    unsigned int pin;
+
+    if (vector_map[src] == vector_map[dst])
+        return;
+
+    bitmap_or(vector_map[src]->_bits, vector_map[src]->_bits,
+              vector_map[dst]->_bits, NR_VECTORS);
+
+    for (pin = 0; pin < nr_ioapic_entries[dst]; ++pin) {
+        int irq = apic_pin_2_gsi_irq(dst, pin);
+        struct irq_desc *desc;
+
+        if (irq < 0)
+            continue;
+        desc = irq_to_desc(irq);
+        if (desc->arch.used_vectors == vector_map[dst])
+            desc->arch.used_vectors = vector_map[src];
+    }
+
+    vector_map[dst] = vector_map[src];
+}
+
+/*
+ * This is performance-critical, we want to do it O(1)
+ *
+ * the indexing order of this array favors 1:1 mappings
+ * between pins and IRQs.
+ */
+
+static struct irq_pin_list {
+    int apic, pin;
+    unsigned int next;
+} *__read_mostly irq_2_pin;
+
+static unsigned int irq_2_pin_free_entry;
+
+/*
+ * The common case is 1:1 IRQ<->pin mappings. Sometimes there are
+ * shared ISA-space IRQs, so we have to support them. We are super
+ * fast in the common case, and fast for shared ISA-space IRQs.
+ */
+static void add_pin_to_irq(unsigned int irq, int apic, int pin)
+{
+    struct irq_pin_list *entry = irq_2_pin + irq;
+
+    while (entry->next) {
+        BUG_ON((entry->apic == apic) && (entry->pin == pin));
+        entry = irq_2_pin + entry->next;
+    }
+    
+    BUG_ON((entry->apic == apic) && (entry->pin == pin));
+
+    if (entry->pin != -1) {
+        if (irq_2_pin_free_entry >= PIN_MAP_SIZE)
+            panic("io_apic.c: whoops");
+        entry->next = irq_2_pin_free_entry;
+        entry = irq_2_pin + entry->next;
+        irq_2_pin_free_entry = entry->next;
+        entry->next = 0;
+    }
+    entry->apic = apic;
+    entry->pin = pin;
+    share_vector_maps(irq_2_pin[irq].apic, apic);
+}
+
+static void remove_pin_from_irq(unsigned int irq, int apic, int pin)
+{
+    struct irq_pin_list *entry, *prev;
+
+    for (entry = &irq_2_pin[irq]; ; entry = &irq_2_pin[entry->next]) {
+        if ((entry->apic == apic) && (entry->pin == pin))
+            break;
+        BUG_ON(!entry->next);
+    }
+
+    entry->pin = entry->apic = -1;
+
+    if (entry != &irq_2_pin[irq]) {
+        /* Removed entry is not at head of list. */
+        prev = &irq_2_pin[irq];
+        while (&irq_2_pin[prev->next] != entry)
+            prev = &irq_2_pin[prev->next];
+        prev->next = entry->next;
+    } else if (entry->next) {
+        /* Removed entry is at head of multi-item list. */
+        prev  = entry;
+        entry = &irq_2_pin[entry->next];
+        *prev = *entry;
+        entry->pin = entry->apic = -1;
+    } else
+        return;
+
+    entry->next = irq_2_pin_free_entry;
+    irq_2_pin_free_entry = entry - irq_2_pin;
+}
+
+/*
+ * Reroute an IRQ to a different pin.
+ */
+static void __init replace_pin_at_irq(unsigned int irq,
+                      int oldapic, int oldpin,
+                      int newapic, int newpin)
+{
+    struct irq_pin_list *entry = irq_2_pin + irq;
+
+    while (1) {
+        if (entry->apic == oldapic && entry->pin == oldpin) {
+            entry->apic = newapic;
+            entry->pin = newpin;
+            share_vector_maps(oldapic, newapic);
+        }
+        if (!entry->next)
+            break;
+        entry = irq_2_pin + entry->next;
+    }
+}
+
+vmask_t *io_apic_get_used_vector_map(unsigned int irq)
+{
+    struct irq_pin_list *entry = irq_2_pin + irq;
+
+    if (entry->pin == -1)
+        return NULL;
+
+    return vector_map[entry->apic];
+}
+
+struct IO_APIC_route_entry **alloc_ioapic_entries(void)
+{
+    int apic;
+    struct IO_APIC_route_entry **ioapic_entries;
+
+    ioapic_entries = xmalloc_array(struct IO_APIC_route_entry *, nr_ioapics);
+    if (!ioapic_entries)
+        return 0;
+
+    for (apic = 0; apic < nr_ioapics; apic++) {
+        ioapic_entries[apic] =
+            xmalloc_array(struct IO_APIC_route_entry,
+                          nr_ioapic_entries[apic]);
+        if (!ioapic_entries[apic] && nr_ioapic_entries[apic])
+            goto nomem;
+    }
+
+    return ioapic_entries;
+
+nomem:
+    while (--apic >= 0)
+        xfree(ioapic_entries[apic]);
+    xfree(ioapic_entries);
+
+    return 0;
+}
+
+union entry_union {
+    struct { u32 w1, w2; };
+    struct IO_APIC_route_entry entry;
+};
+
+struct IO_APIC_route_entry __ioapic_read_entry(
+    unsigned int apic, unsigned int pin, bool_t raw)
+{
+    unsigned int (*read)(unsigned int, unsigned int)
+        = raw ? __io_apic_read : io_apic_read;
+    union entry_union eu;
+    eu.w1 = (*read)(apic, 0x10 + 2 * pin);
+    eu.w2 = (*read)(apic, 0x11 + 2 * pin);
+    return eu.entry;
+}
+
+static struct IO_APIC_route_entry ioapic_read_entry(
+    unsigned int apic, unsigned int pin, bool_t raw)
+{
+    struct IO_APIC_route_entry entry;
+    unsigned long flags;
+
+    spin_lock_irqsave(&ioapic_lock, flags);
+    entry = __ioapic_read_entry(apic, pin, raw);
+    spin_unlock_irqrestore(&ioapic_lock, flags);
+    return entry;
+}
+
+void __ioapic_write_entry(
+    unsigned int apic, unsigned int pin, bool_t raw,
+    struct IO_APIC_route_entry e)
+{
+    void (*write)(unsigned int, unsigned int, unsigned int)
+        = raw ? __io_apic_write : io_apic_write;
+    union entry_union eu = { .entry = e };
+
+    (*write)(apic, 0x11 + 2*pin, eu.w2);
+    (*write)(apic, 0x10 + 2*pin, eu.w1);
+}
+
+static void ioapic_write_entry(
+    unsigned int apic, unsigned int pin, bool_t raw,
+    struct IO_APIC_route_entry e)
+{
+    unsigned long flags;
+    spin_lock_irqsave(&ioapic_lock, flags);
+    __ioapic_write_entry(apic, pin, raw, e);
+    spin_unlock_irqrestore(&ioapic_lock, flags);
+}
+
+/* EOI an IO-APIC entry.  Vector may be -1, indicating that it should be
+ * worked out using the pin.  This function expects that the ioapic_lock is
+ * being held, and interrupts are disabled (or there is a good reason not
+ * to), and that if both pin and vector are passed, that they refer to the
+ * same redirection entry in the IO-APIC. */
+static void __io_apic_eoi(unsigned int apic, unsigned int vector, unsigned int pin)
+{
+    /* Prefer the use of the EOI register if available */
+    if ( ioapic_has_eoi_reg(apic) )
+    {
+        /* If vector is unknown, read it from the IO-APIC */
+        if ( vector == IRQ_VECTOR_UNASSIGNED )
+            vector = __ioapic_read_entry(apic, pin, TRUE).vector;
+
+        *(IO_APIC_BASE(apic)+16) = vector;
+    }
+    else
+    {
+        /* Else fake an EOI by switching to edge triggered mode
+         * and back */
+        struct IO_APIC_route_entry entry;
+        bool_t need_to_unmask = 0;
+
+        entry = __ioapic_read_entry(apic, pin, TRUE);
+
+        if ( ! entry.mask )
+        {
+            /* If entry is not currently masked, mask it and make
+             * a note to unmask it later */
+            entry.mask = 1;
+            __ioapic_write_entry(apic, pin, TRUE, entry);
+            need_to_unmask = 1;
+        }
+
+        /* Flip the trigger mode to edge and back */
+        entry.trigger = 0;
+        __ioapic_write_entry(apic, pin, TRUE, entry);
+        entry.trigger = 1;
+        __ioapic_write_entry(apic, pin, TRUE, entry);
+
+        if ( need_to_unmask )
+        {
+            /* Unmask if neccesary */
+            entry.mask = 0;
+            __ioapic_write_entry(apic, pin, TRUE, entry);
+        }
+    }
+}
+
+/*
+ * Saves all the IO-APIC RTE's
+ */
+int save_IO_APIC_setup(struct IO_APIC_route_entry **ioapic_entries)
+{
+    int apic, pin;
+
+    if (!ioapic_entries)
+        return -ENOMEM;
+
+    for (apic = 0; apic < nr_ioapics; apic++) {
+        if (!nr_ioapic_entries[apic])
+            continue;
+
+        if (!ioapic_entries[apic])
+            return -ENOMEM;
+
+        for (pin = 0; pin < nr_ioapic_entries[apic]; pin++)
+	    ioapic_entries[apic][pin] = __ioapic_read_entry(apic, pin, 1);
+    }
+
+    return 0;
+}
+
+/*
+ * Mask all IO APIC entries.
+ */
+void mask_IO_APIC_setup(struct IO_APIC_route_entry **ioapic_entries)
+{
+    int apic, pin;
+
+    if (!ioapic_entries)
+        return;
+
+    for (apic = 0; apic < nr_ioapics; apic++) {
+        if (!nr_ioapic_entries[apic])
+            continue;
+
+        if (!ioapic_entries[apic])
+            break;
+
+        for (pin = 0; pin < nr_ioapic_entries[apic]; pin++) {
+            struct IO_APIC_route_entry entry;
+
+            entry = ioapic_entries[apic][pin];
+            if (!entry.mask) {
+                entry.mask = 1;
+
+                ioapic_write_entry(apic, pin, 1, entry);
+            }
+        }
+    }
+}
+
+/*
+ * Restore IO APIC entries which was saved in ioapic_entries.
+ */
+int restore_IO_APIC_setup(struct IO_APIC_route_entry **ioapic_entries)
+{
+    int apic, pin;
+
+    if (!ioapic_entries)
+        return -ENOMEM;
+
+    for (apic = 0; apic < nr_ioapics; apic++) {
+        if (!nr_ioapic_entries[apic])
+            continue;
+
+        if (!ioapic_entries[apic])
+            return -ENOMEM;
+
+        for (pin = 0; pin < nr_ioapic_entries[apic]; pin++)
+	    ioapic_write_entry(apic, pin, 1, ioapic_entries[apic][pin]);
+    }
+
+    return 0;
+}
+
+void free_ioapic_entries(struct IO_APIC_route_entry **ioapic_entries)
+{
+    int apic;
+
+    for (apic = 0; apic < nr_ioapics; apic++)
+        xfree(ioapic_entries[apic]);
+
+    xfree(ioapic_entries);
+}
+
+static void __modify_IO_APIC_irq (unsigned int irq, unsigned long enable, unsigned long disable)
+{
+    struct irq_pin_list *entry = irq_2_pin + irq;
+    unsigned int pin, reg;
+
+    for (;;) {
+        pin = entry->pin;
+        if (pin == -1)
+            break;
+        reg = io_apic_read(entry->apic, 0x10 + pin*2);
+        reg &= ~disable;
+        reg |= enable;
+        io_apic_modify(entry->apic, 0x10 + pin*2, reg);
+        if (!entry->next)
+            break;
+        entry = irq_2_pin + entry->next;
+    }
+}
+
+/* mask = 1 */
+static void __mask_IO_APIC_irq (unsigned int irq)
+{
+    __modify_IO_APIC_irq(irq, 0x00010000, 0);
+}
+
+/* mask = 0 */
+static void __unmask_IO_APIC_irq (unsigned int irq)
+{
+    __modify_IO_APIC_irq(irq, 0, 0x00010000);
+}
+
+/* trigger = 0 */
+static void __edge_IO_APIC_irq (unsigned int irq)
+{
+    __modify_IO_APIC_irq(irq, 0, 0x00008000);
+}
+
+/* trigger = 1 */
+static void __level_IO_APIC_irq (unsigned int irq)
+{
+    __modify_IO_APIC_irq(irq, 0x00008000, 0);
+}
+
+static void mask_IO_APIC_irq(struct irq_desc *desc)
+{
+    unsigned long flags;
+
+    spin_lock_irqsave(&ioapic_lock, flags);
+    __mask_IO_APIC_irq(desc->irq);
+    spin_unlock_irqrestore(&ioapic_lock, flags);
+}
+
+static void unmask_IO_APIC_irq(struct irq_desc *desc)
+{
+    unsigned long flags;
+
+    spin_lock_irqsave(&ioapic_lock, flags);
+    __unmask_IO_APIC_irq(desc->irq);
+    spin_unlock_irqrestore(&ioapic_lock, flags);
+}
+
+static void __eoi_IO_APIC_irq(struct irq_desc *desc)
+{
+    struct irq_pin_list *entry = irq_2_pin + desc->irq;
+    unsigned int pin, vector = desc->arch.vector;
+
+    for (;;) {
+        pin = entry->pin;
+        if (pin == -1)
+            break;
+        __io_apic_eoi(entry->apic, vector, pin);
+        if (!entry->next)
+            break;
+        entry = irq_2_pin + entry->next;
+    }
+}
+
+static void eoi_IO_APIC_irq(struct irq_desc *desc)
+{
+    unsigned long flags;
+    spin_lock_irqsave(&ioapic_lock, flags);
+    __eoi_IO_APIC_irq(desc);
+    spin_unlock_irqrestore(&ioapic_lock, flags);
+}
+
+static void clear_IO_APIC_pin(unsigned int apic, unsigned int pin)
+{
+    struct IO_APIC_route_entry entry;
+
+    /* Check delivery_mode to be sure we're not clearing an SMI pin */
+    entry = __ioapic_read_entry(apic, pin, FALSE);
+    if (entry.delivery_mode == dest_SMI)
+        return;
+
+    /*
+     * Make sure the entry is masked and re-read the contents to check
+     * if it is a level triggered pin and if the remoteIRR is set.
+     */
+    if (!entry.mask) {
+        entry.mask = 1;
+        __ioapic_write_entry(apic, pin, FALSE, entry);
+    }
+    entry = __ioapic_read_entry(apic, pin, TRUE);
+
+    if (entry.irr) {
+        /* Make sure the trigger mode is set to level. */
+        if (!entry.trigger) {
+            entry.trigger = 1;
+            __ioapic_write_entry(apic, pin, TRUE, entry);
+        }
+        __io_apic_eoi(apic, entry.vector, pin);
+    }
+
+    /*
+     * Disable it in the IO-APIC irq-routing table:
+     */
+    memset(&entry, 0, sizeof(entry));
+    entry.mask = 1;
+    __ioapic_write_entry(apic, pin, TRUE, entry);
+
+    entry = __ioapic_read_entry(apic, pin, TRUE);
+    if (entry.irr)
+        printk(KERN_ERR "IO-APIC%02x-%u: Unable to reset IRR\n",
+               IO_APIC_ID(apic), pin);
+}
+
+static void clear_IO_APIC (void)
+{
+    int apic, pin;
+
+    for (apic = 0; apic < nr_ioapics; apic++) {
+        for (pin = 0; pin < nr_ioapic_entries[apic]; pin++)
+            clear_IO_APIC_pin(apic, pin);
+    }
+}
+
+static void
+set_ioapic_affinity_irq(struct irq_desc *desc, const cpumask_t *mask)
+{
+    unsigned long flags;
+    unsigned int dest;
+    int pin, irq;
+    struct irq_pin_list *entry;
+
+    irq = desc->irq;
+
+    spin_lock_irqsave(&ioapic_lock, flags);
+    dest = set_desc_affinity(desc, mask);
+    if (dest != BAD_APICID) {
+        if ( !x2apic_enabled )
+            dest = SET_APIC_LOGICAL_ID(dest);
+        entry = irq_2_pin + irq;
+        for (;;) {
+            unsigned int data;
+            pin = entry->pin;
+            if (pin == -1)
+                break;
+
+            io_apic_write(entry->apic, 0x10 + 1 + pin*2, dest);
+            data = io_apic_read(entry->apic, 0x10 + pin*2);
+            data &= ~IO_APIC_REDIR_VECTOR_MASK;
+            data |= desc->arch.vector & 0xFF;
+            io_apic_modify(entry->apic, 0x10 + pin*2, data);
+
+            if (!entry->next)
+                break;
+            entry = irq_2_pin + entry->next;
+        }
+    }
+    spin_unlock_irqrestore(&ioapic_lock, flags);
+
+}
+
+/*
+ * Find the IRQ entry number of a certain pin.
+ */
+static int find_irq_entry(int apic, int pin, int type)
+{
+    int i;
+
+    for (i = 0; i < mp_irq_entries; i++)
+        if (mp_irqs[i].mpc_irqtype == type &&
+            (mp_irqs[i].mpc_dstapic == mp_ioapics[apic].mpc_apicid ||
+             mp_irqs[i].mpc_dstapic == MP_APIC_ALL) &&
+            mp_irqs[i].mpc_dstirq == pin)
+            return i;
+
+    return -1;
+}
+
+/*
+ * Find the pin to which IRQ[irq] (ISA) is connected
+ */
+static int __init find_isa_irq_pin(int irq, int type)
+{
+    int i;
+
+    for (i = 0; i < mp_irq_entries; i++) {
+        int lbus = mp_irqs[i].mpc_srcbus;
+
+        if ((mp_bus_id_to_type[lbus] == MP_BUS_ISA ||
+             mp_bus_id_to_type[lbus] == MP_BUS_EISA ||
+             mp_bus_id_to_type[lbus] == MP_BUS_MCA ||
+             mp_bus_id_to_type[lbus] == MP_BUS_NEC98
+            ) &&
+            (mp_irqs[i].mpc_irqtype == type) &&
+            (mp_irqs[i].mpc_srcbusirq == irq))
+
+            return mp_irqs[i].mpc_dstirq;
+    }
+    return -1;
+}
+
+static int __init find_isa_irq_apic(int irq, int type)
+{
+    int i;
+
+    for (i = 0; i < mp_irq_entries; i++) {
+        int lbus = mp_irqs[i].mpc_srcbus;
+
+        if ((mp_bus_id_to_type[lbus] == MP_BUS_ISA ||
+             mp_bus_id_to_type[lbus] == MP_BUS_EISA ||
+             mp_bus_id_to_type[lbus] == MP_BUS_MCA ||
+             mp_bus_id_to_type[lbus] == MP_BUS_NEC98
+            ) &&
+            (mp_irqs[i].mpc_irqtype == type) &&
+            (mp_irqs[i].mpc_srcbusirq == irq))
+            break;
+    }
+    if (i < mp_irq_entries) {
+        int apic;
+        for(apic = 0; apic < nr_ioapics; apic++) {
+            if (!nr_ioapic_entries[apic])
+                continue;
+            if (mp_ioapics[apic].mpc_apicid == mp_irqs[i].mpc_dstapic)
+                return apic;
+        }
+    }
+
+    return -1;
+}
+
+/*
+ * Find a specific PCI IRQ entry.
+ * Not an __init, possibly needed by modules
+ */
+static int pin_2_irq(int idx, int apic, int pin);
+
+/*
+ * This function currently is only a helper for the i386 smp boot process where 
+ * we need to reprogram the ioredtbls to cater for the cpus which have come online
+ * so mask in all cases should simply be TARGET_CPUS
+ */
+void /*__init*/ setup_ioapic_dest(void)
+{
+    int pin, ioapic, irq, irq_entry;
+
+    if (skip_ioapic_setup)
+        return;
+
+    for (ioapic = 0; ioapic < nr_ioapics; ioapic++) {
+        for (pin = 0; pin < nr_ioapic_entries[ioapic]; pin++) {
+            struct irq_desc *desc;
+
+            irq_entry = find_irq_entry(ioapic, pin, mp_INT);
+            if (irq_entry == -1)
+                continue;
+            irq = pin_2_irq(irq_entry, ioapic, pin);
+            desc = irq_to_desc(irq);
+            BUG_ON(cpumask_empty(desc->arch.cpu_mask));
+            set_ioapic_affinity_irq(desc, desc->arch.cpu_mask);
+        }
+
+    }
+}
+
+/*
+ * EISA Edge/Level control register, ELCR
+ */
+static int EISA_ELCR(unsigned int irq)
+{
+    if (platform_legacy_irq(irq)) {
+        unsigned int port = 0x4d0 + (irq >> 3);
+        return (inb(port) >> (irq & 7)) & 1;
+    }
+    apic_printk(APIC_VERBOSE, KERN_INFO
+                "Broken MPtable reports ISA irq %d\n", irq);
+    return 0;
+}
+
+/* EISA interrupts are always polarity zero and can be edge or level
+ * trigger depending on the ELCR value.  If an interrupt is listed as
+ * EISA conforming in the MP table, that means its trigger type must
+ * be read in from the ELCR */
+
+#define default_EISA_trigger(idx)    (EISA_ELCR(mp_irqs[idx].mpc_srcbusirq))
+#define default_EISA_polarity(idx)	(0)
+
+/* ISA interrupts are always polarity zero edge triggered,
+ * when listed as conforming in the MP table. */
+
+#define default_ISA_trigger(idx)	(0)
+#define default_ISA_polarity(idx)	(0)
+
+/* PCI interrupts are always polarity one level triggered,
+ * when listed as conforming in the MP table. */
+
+#define default_PCI_trigger(idx)	(1)
+#define default_PCI_polarity(idx)	(1)
+
+/* MCA interrupts are always polarity zero level triggered,
+ * when listed as conforming in the MP table. */
+
+#define default_MCA_trigger(idx)	(1)
+#define default_MCA_polarity(idx)	(0)
+
+/* NEC98 interrupts are always polarity zero edge triggered,
+ * when listed as conforming in the MP table. */
+
+#define default_NEC98_trigger(idx)     (0)
+#define default_NEC98_polarity(idx)    (0)
+
+static int __init MPBIOS_polarity(int idx)
+{
+    int bus = mp_irqs[idx].mpc_srcbus;
+    int polarity;
+
+    /*
+     * Determine IRQ line polarity (high active or low active):
+     */
+    switch (mp_irqs[idx].mpc_irqflag & 3)
+    {
+    case 0: /* conforms, ie. bus-type dependent polarity */
+    {
+        switch (mp_bus_id_to_type[bus])
+        {
+        case MP_BUS_ISA: /* ISA pin */
+        {
+            polarity = default_ISA_polarity(idx);
+            break;
+        }
+        case MP_BUS_EISA: /* EISA pin */
+        {
+            polarity = default_EISA_polarity(idx);
+            break;
+        }
+        case MP_BUS_PCI: /* PCI pin */
+        {
+            polarity = default_PCI_polarity(idx);
+            break;
+        }
+        case MP_BUS_MCA: /* MCA pin */
+        {
+            polarity = default_MCA_polarity(idx);
+            break;
+        }
+        case MP_BUS_NEC98: /* NEC 98 pin */
+        {
+            polarity = default_NEC98_polarity(idx);
+            break;
+        }
+        default:
+        {
+            printk(KERN_WARNING "broken BIOS!!\n");
+            polarity = 1;
+            break;
+        }
+        }
+        break;
+    }
+    case 1: /* high active */
+    {
+        polarity = 0;
+        break;
+    }
+    case 2: /* reserved */
+    {
+        printk(KERN_WARNING "broken BIOS!!\n");
+        polarity = 1;
+        break;
+    }
+    case 3: /* low active */
+    {
+        polarity = 1;
+        break;
+    }
+    default: /* invalid */
+    {
+        printk(KERN_WARNING "broken BIOS!!\n");
+        polarity = 1;
+        break;
+    }
+    }
+    return polarity;
+}
+
+static int MPBIOS_trigger(int idx)
+{
+    int bus = mp_irqs[idx].mpc_srcbus;
+    int trigger;
+
+    /*
+     * Determine IRQ trigger mode (edge or level sensitive):
+     */
+    switch ((mp_irqs[idx].mpc_irqflag>>2) & 3)
+    {
+    case 0: /* conforms, ie. bus-type dependent */
+    {
+        switch (mp_bus_id_to_type[bus])
+        {
+        case MP_BUS_ISA: /* ISA pin */
+        {
+            trigger = default_ISA_trigger(idx);
+            break;
+        }
+        case MP_BUS_EISA: /* EISA pin */
+        {
+            trigger = default_EISA_trigger(idx);
+            break;
+        }
+        case MP_BUS_PCI: /* PCI pin */
+        {
+            trigger = default_PCI_trigger(idx);
+            break;
+        }
+        case MP_BUS_MCA: /* MCA pin */
+        {
+            trigger = default_MCA_trigger(idx);
+            break;
+        }
+        case MP_BUS_NEC98: /* NEC 98 pin */
+        {
+            trigger = default_NEC98_trigger(idx);
+            break;
+        }
+        default:
+        {
+            printk(KERN_WARNING "broken BIOS!!\n");
+            trigger = 1;
+            break;
+        }
+        }
+        break;
+    }
+    case 1: /* edge */
+    {
+        trigger = 0;
+        break;
+    }
+    case 2: /* reserved */
+    {
+        printk(KERN_WARNING "broken BIOS!!\n");
+        trigger = 1;
+        break;
+    }
+    case 3: /* level */
+    {
+        trigger = 1;
+        break;
+    }
+    default: /* invalid */
+    {
+        printk(KERN_WARNING "broken BIOS!!\n");
+        trigger = 0;
+        break;
+    }
+    }
+    return trigger;
+}
+
+static inline int irq_polarity(int idx)
+{
+    return MPBIOS_polarity(idx);
+}
+
+static inline int irq_trigger(int idx)
+{
+    return MPBIOS_trigger(idx);
+}
+
+static int pin_2_irq(int idx, int apic, int pin)
+{
+    int irq, i;
+    int bus = mp_irqs[idx].mpc_srcbus;
+
+    /*
+     * Debugging check, we are in big trouble if this message pops up!
+     */
+    if (mp_irqs[idx].mpc_dstirq != pin)
+        printk(KERN_ERR "broken BIOS or MPTABLE parser, ayiee!!\n");
+
+    switch (mp_bus_id_to_type[bus])
+    {
+    case MP_BUS_ISA: /* ISA pin */
+    case MP_BUS_EISA:
+    case MP_BUS_MCA:
+    case MP_BUS_NEC98:
+    {
+        irq = mp_irqs[idx].mpc_srcbusirq;
+        break;
+    }
+    case MP_BUS_PCI: /* PCI pin */
+    {
+        /*
+         * PCI IRQs are mapped in order
+         */
+        i = irq = 0;
+        while (i < apic)
+            irq += nr_ioapic_entries[i++];
+        irq += pin;
+        break;
+    }
+    default:
+    {
+        printk(KERN_ERR "unknown bus type %d.\n",bus);
+        irq = 0;
+        break;
+    }
+    }
+
+    return irq;
+}
+
+static inline int IO_APIC_irq_trigger(int irq)
+{
+    int apic, idx, pin;
+
+    for (apic = 0; apic < nr_ioapics; apic++) {
+        for (pin = 0; pin < nr_ioapic_entries[apic]; pin++) {
+            idx = find_irq_entry(apic,pin,mp_INT);
+            if ((idx != -1) && (irq == pin_2_irq(idx,apic,pin)))
+                return irq_trigger(idx);
+        }
+    }
+    /*
+     * nonexistent IRQs are edge default
+     */
+    return 0;
+}
+
+static struct hw_interrupt_type ioapic_level_type;
+static hw_irq_controller ioapic_edge_type;
+
+#define IOAPIC_AUTO	-1
+#define IOAPIC_EDGE	0
+#define IOAPIC_LEVEL	1
+
+#define SET_DEST(x, y, value) \
+    do { if ( x2apic_enabled ) x = value; else y = value; } while(0)
+
+static inline void ioapic_register_intr(int irq, unsigned long trigger)
+{
+    if ((trigger == IOAPIC_AUTO && IO_APIC_irq_trigger(irq)) ||
+        trigger == IOAPIC_LEVEL)
+        irq_desc[irq].handler = &ioapic_level_type;
+    else
+        irq_desc[irq].handler = &ioapic_edge_type;
+}
+
+static void __init setup_IO_APIC_irqs(void)
+{
+    struct IO_APIC_route_entry entry;
+    int apic, pin, idx, irq, first_notcon = 1, vector;
+    unsigned long flags;
+
+    apic_printk(APIC_VERBOSE, KERN_DEBUG "init IO_APIC IRQs\n");
+
+    for (apic = 0; apic < nr_ioapics; apic++) {
+        for (pin = 0; pin < nr_ioapic_entries[apic]; pin++) {
+            struct irq_desc *desc;
+
+            /*
+             * add it to the IO-APIC irq-routing table:
+             */
+            memset(&entry,0,sizeof(entry));
+
+            entry.delivery_mode = INT_DELIVERY_MODE;
+            entry.dest_mode = INT_DEST_MODE;
+            entry.mask = 0;                /* enable IRQ */
+
+            idx = find_irq_entry(apic,pin,mp_INT);
+            if (idx == -1) {
+                if (first_notcon) {
+                    apic_printk(APIC_VERBOSE, KERN_DEBUG
+                                " IO-APIC (apicid-pin) %d-%d",
+                                mp_ioapics[apic].mpc_apicid,
+                                pin);
+                    first_notcon = 0;
+                } else
+                    apic_printk(APIC_VERBOSE, ", %d-%d",
+                                mp_ioapics[apic].mpc_apicid, pin);
+                continue;
+            }
+
+            entry.trigger = irq_trigger(idx);
+            entry.polarity = irq_polarity(idx);
+
+            if (irq_trigger(idx)) {
+                entry.trigger = 1;
+                entry.mask = 1;
+            }
+
+            irq = pin_2_irq(idx, apic, pin);
+            /*
+             * skip adding the timer int on secondary nodes, which causes
+             * a small but painful rift in the time-space continuum
+             */
+            if (multi_timer_check(apic, irq))
+                continue;
+            else
+                add_pin_to_irq(irq, apic, pin);
+
+            if (!IO_APIC_IRQ(irq))
+                continue;
+
+            vector = assign_irq_vector(irq, NULL);
+            BUG_ON(vector < 0);
+            entry.vector = vector;
+            ioapic_register_intr(irq, IOAPIC_AUTO);
+
+            if (platform_legacy_irq(irq))
+                disable_8259A_irq(irq_to_desc(irq));
+
+            desc = irq_to_desc(irq);
+            SET_DEST(entry.dest.dest32, entry.dest.logical.logical_dest,
+                     cpu_mask_to_apicid(desc->arch.cpu_mask));
+            spin_lock_irqsave(&ioapic_lock, flags);
+            __ioapic_write_entry(apic, pin, 0, entry);
+            set_native_irq_info(irq, TARGET_CPUS);
+            spin_unlock_irqrestore(&ioapic_lock, flags);
+        }
+    }
+
+    if (!first_notcon)
+        apic_printk(APIC_VERBOSE, " not connected.\n");
+}
+
+/*
+ * Set up the 8259A-master output pin:
+ */
+static void __init setup_ExtINT_IRQ0_pin(unsigned int apic, unsigned int pin, int vector)
+{
+    struct IO_APIC_route_entry entry;
+
+    memset(&entry,0,sizeof(entry));
+
+    disable_8259A_irq(irq_to_desc(0));
+
+    /* mask LVT0 */
+    apic_write_around(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_EXTINT);
+
+    /*
+     * We use logical delivery to get the timer IRQ
+     * to the first CPU.
+     */
+    entry.dest_mode = INT_DEST_MODE;
+    entry.mask = 0;					/* unmask IRQ now */
+    SET_DEST(entry.dest.dest32, entry.dest.logical.logical_dest,
+        cpu_mask_to_apicid(TARGET_CPUS));
+    entry.delivery_mode = INT_DELIVERY_MODE;
+    entry.polarity = 0;
+    entry.trigger = 0;
+    entry.vector = vector;
+
+    /*
+     * The timer IRQ doesn't have to know that behind the
+     * scene we have a 8259A-master in AEOI mode ...
+     */
+    irq_desc[0].handler = &ioapic_edge_type;
+
+    /*
+     * Add it to the IO-APIC irq-routing table:
+     */
+    ioapic_write_entry(apic, pin, 0, entry);
+
+    enable_8259A_irq(irq_to_desc(0));
+}
+
+static inline void UNEXPECTED_IO_APIC(void)
+{
+}
+
+static void /*__init*/ __print_IO_APIC(void)
+{
+    int apic, i;
+    union IO_APIC_reg_00 reg_00;
+    union IO_APIC_reg_01 reg_01;
+    union IO_APIC_reg_02 reg_02;
+    union IO_APIC_reg_03 reg_03;
+    unsigned long flags;
+
+    printk(KERN_DEBUG "number of MP IRQ sources: %d.\n", mp_irq_entries);
+    for (i = 0; i < nr_ioapics; i++)
+        printk(KERN_DEBUG "number of IO-APIC #%d registers: %d.\n",
+               mp_ioapics[i].mpc_apicid, nr_ioapic_entries[i]);
+
+    /*
+     * We are a bit conservative about what we expect.  We have to
+     * know about every hardware change ASAP.
+     */
+    printk(KERN_INFO "testing the IO APIC.......................\n");
+
+    for (apic = 0; apic < nr_ioapics; apic++) {
+        if (!nr_ioapic_entries[apic])
+            continue;
+
+	spin_lock_irqsave(&ioapic_lock, flags);
+	reg_00.raw = io_apic_read(apic, 0);
+	reg_01.raw = io_apic_read(apic, 1);
+	if (reg_01.bits.version >= 0x10)
+            reg_02.raw = io_apic_read(apic, 2);
+	if (reg_01.bits.version >= 0x20)
+            reg_03.raw = io_apic_read(apic, 3);
+	spin_unlock_irqrestore(&ioapic_lock, flags);
+
+	printk(KERN_DEBUG "IO APIC #%d......\n", mp_ioapics[apic].mpc_apicid);
+	printk(KERN_DEBUG ".... register #00: %08X\n", reg_00.raw);
+	printk(KERN_DEBUG ".......    : physical APIC id: %02X\n", reg_00.bits.ID);
+	printk(KERN_DEBUG ".......    : Delivery Type: %X\n", reg_00.bits.delivery_type);
+	printk(KERN_DEBUG ".......    : LTS          : %X\n", reg_00.bits.LTS);
+	if (reg_00.bits.ID >= get_physical_broadcast())
+            UNEXPECTED_IO_APIC();
+	if (reg_00.bits.__reserved_1 || reg_00.bits.__reserved_2)
+            UNEXPECTED_IO_APIC();
+
+	printk(KERN_DEBUG ".... register #01: %08X\n", reg_01.raw);
+	printk(KERN_DEBUG ".......     : max redirection entries: %04X\n", reg_01.bits.entries);
+	if (	(reg_01.bits.entries != 0x0f) && /* older (Neptune) boards */
+		(reg_01.bits.entries != 0x17) && /* typical ISA+PCI boards */
+		(reg_01.bits.entries != 0x1b) && /* Compaq Proliant boards */
+		(reg_01.bits.entries != 0x1f) && /* dual Xeon boards */
+		(reg_01.bits.entries != 0x22) && /* bigger Xeon boards */
+		(reg_01.bits.entries != 0x2E) &&
+		(reg_01.bits.entries != 0x3F)
+            )
+            UNEXPECTED_IO_APIC();
+
+	printk(KERN_DEBUG ".......     : PRQ implemented: %X\n", reg_01.bits.PRQ);
+	printk(KERN_DEBUG ".......     : IO APIC version: %04X\n", reg_01.bits.version);
+	if (	(reg_01.bits.version != 0x01) && /* 82489DX IO-APICs */
+		(reg_01.bits.version != 0x10) && /* oldest IO-APICs */
+		(reg_01.bits.version != 0x11) && /* Pentium/Pro IO-APICs */
+		(reg_01.bits.version != 0x13) && /* Xeon IO-APICs */
+		(reg_01.bits.version != 0x20)    /* Intel P64H (82806 AA) */
+            )
+            UNEXPECTED_IO_APIC();
+	if (reg_01.bits.__reserved_1 || reg_01.bits.__reserved_2)
+            UNEXPECTED_IO_APIC();
+
+	/*
+	 * Some Intel chipsets with IO APIC VERSION of 0x1? don't have reg_02,
+	 * but the value of reg_02 is read as the previous read register
+	 * value, so ignore it if reg_02 == reg_01.
+	 */
+	if (reg_01.bits.version >= 0x10 && reg_02.raw != reg_01.raw) {
+            printk(KERN_DEBUG ".... register #02: %08X\n", reg_02.raw);
+            printk(KERN_DEBUG ".......     : arbitration: %02X\n", reg_02.bits.arbitration);
+            if (reg_02.bits.__reserved_1 || reg_02.bits.__reserved_2)
+                UNEXPECTED_IO_APIC();
+	}
+
+	/*
+	 * Some Intel chipsets with IO APIC VERSION of 0x2? don't have reg_02
+	 * or reg_03, but the value of reg_0[23] is read as the previous read
+	 * register value, so ignore it if reg_03 == reg_0[12].
+	 */
+	if (reg_01.bits.version >= 0x20 && reg_03.raw != reg_02.raw &&
+	    reg_03.raw != reg_01.raw) {
+            printk(KERN_DEBUG ".... register #03: %08X\n", reg_03.raw);
+            printk(KERN_DEBUG ".......     : Boot DT    : %X\n", reg_03.bits.boot_DT);
+            if (reg_03.bits.__reserved_1)
+                UNEXPECTED_IO_APIC();
+	}
+
+	printk(KERN_DEBUG ".... IRQ redirection table:\n");
+
+	printk(KERN_DEBUG " NR Log Phy Mask Trig IRR Pol"
+               " Stat Dest Deli Vect:   \n");
+
+	for (i = 0; i <= reg_01.bits.entries; i++) {
+            struct IO_APIC_route_entry entry;
+
+            entry = ioapic_read_entry(apic, i, 0);
+
+            printk(KERN_DEBUG " %02x %03X %02X  ",
+                   i,
+                   entry.dest.logical.logical_dest,
+                   entry.dest.physical.physical_dest
+		);
+
+            printk("%1d    %1d    %1d   %1d   %1d    %1d    %1d    %02X\n",
+                   entry.mask,
+                   entry.trigger,
+                   entry.irr,
+                   entry.polarity,
+                   entry.delivery_status,
+                   entry.dest_mode,
+                   entry.delivery_mode,
+                   entry.vector
+		);
+	}
+    }
+    printk(KERN_INFO "Using vector-based indexing\n");
+    printk(KERN_DEBUG "IRQ to pin mappings:\n");
+    for (i = 0; i < nr_irqs_gsi; i++) {
+        struct irq_pin_list *entry = irq_2_pin + i;
+        if (entry->pin < 0)
+            continue;
+        printk(KERN_DEBUG "IRQ%d ", irq_to_desc(i)->arch.vector);
+        for (;;) {
+            printk("-> %d:%d", entry->apic, entry->pin);
+            if (!entry->next)
+                break;
+            entry = irq_2_pin + entry->next;
+        }
+        printk("\n");
+    }
+
+    printk(KERN_INFO ".................................... done.\n");
+
+    return;
+}
+
+static void __init print_IO_APIC(void)
+{
+    if (apic_verbosity != APIC_QUIET)
+        __print_IO_APIC();
+}
+
+static void _print_IO_APIC_keyhandler(unsigned char key)
+{
+    __print_IO_APIC();
+}
+static struct keyhandler print_IO_APIC_keyhandler = {
+    .diagnostic = 1,
+    .u.fn = _print_IO_APIC_keyhandler,
+    .desc = "print ioapic info"
+};
+
+static void __init enable_IO_APIC(void)
+{
+    int i8259_apic, i8259_pin;
+    int i, apic;
+
+    /* Initialise dynamic irq_2_pin free list. */
+    irq_2_pin = xzalloc_array(struct irq_pin_list, PIN_MAP_SIZE);
+        
+    for (i = 0; i < PIN_MAP_SIZE; i++)
+        irq_2_pin[i].pin = -1;
+    for (i = irq_2_pin_free_entry = nr_irqs_gsi; i < PIN_MAP_SIZE; i++)
+        irq_2_pin[i].next = i + 1;
+
+    if (directed_eoi_enabled) {
+        for (apic = 0; apic < nr_ioapics; apic++) {
+            if (!nr_ioapic_entries[apic])
+                continue;
+            vector_map[apic] = xzalloc(vmask_t);
+            BUG_ON(!vector_map[apic]);
+        }
+    } else {
+        vector_map[0] = xzalloc(vmask_t);
+        BUG_ON(!vector_map[0]);
+        for (apic = 1; apic < nr_ioapics; apic++)
+            vector_map[apic] = vector_map[0];
+    }
+
+    for(apic = 0; apic < nr_ioapics; apic++) {
+        int pin;
+        /* See if any of the pins is in ExtINT mode */
+        for (pin = 0; pin < nr_ioapic_entries[apic]; pin++) {
+            struct IO_APIC_route_entry entry = ioapic_read_entry(apic, pin, 0);
+
+            /* If the interrupt line is enabled and in ExtInt mode
+             * I have found the pin where the i8259 is connected.
+             */
+            if ((entry.mask == 0) && (entry.delivery_mode == dest_ExtINT)) {
+                ioapic_i8259.apic = apic;
+                ioapic_i8259.pin  = pin;
+                goto found_i8259;
+            }
+        }
+    }
+ found_i8259:
+    /* Look to see what if the MP table has reported the ExtINT */
+    /* If we could not find the appropriate pin by looking at the ioapic
+     * the i8259 probably is not connected the ioapic but give the
+     * mptable a chance anyway.
+     */
+    i8259_pin  = find_isa_irq_pin(0, mp_ExtINT);
+    i8259_apic = find_isa_irq_apic(0, mp_ExtINT);
+    /* Trust the MP table if nothing is setup in the hardware */
+    if ((ioapic_i8259.pin == -1) && (i8259_pin >= 0)) {
+        printk(KERN_WARNING "ExtINT not setup in hardware but reported by MP table\n");
+        ioapic_i8259.pin  = i8259_pin;
+        ioapic_i8259.apic = i8259_apic;
+    }
+    /* Complain if the MP table and the hardware disagree */
+    if (((ioapic_i8259.apic != i8259_apic) || (ioapic_i8259.pin != i8259_pin)) &&
+        (i8259_pin >= 0) && (ioapic_i8259.pin >= 0))
+    {
+        printk(KERN_WARNING "ExtINT in hardware and MP table differ\n");
+    }
+
+    /*
+     * Do not trust the IO-APIC being empty at bootup
+     */
+    clear_IO_APIC();
+}
+
+/*
+ * Not an __init, needed by the reboot code
+ */
+void disable_IO_APIC(void)
+{
+    /*
+     * Clear the IO-APIC before rebooting:
+     */
+    clear_IO_APIC();
+
+    /*
+     * If the i8259 is routed through an IOAPIC
+     * Put that IOAPIC in virtual wire mode
+     * so legacy interrupts can be delivered.
+     */
+    if (ioapic_i8259.pin != -1) {
+        struct IO_APIC_route_entry entry;
+
+        memset(&entry, 0, sizeof(entry));
+        entry.mask            = 0; /* Enabled */
+        entry.trigger         = 0; /* Edge */
+        entry.irr             = 0;
+        entry.polarity        = 0; /* High */
+        entry.delivery_status = 0;
+        entry.dest_mode       = 0; /* Physical */
+        entry.delivery_mode   = dest_ExtINT; /* ExtInt */
+        entry.vector          = 0;
+        SET_DEST(entry.dest.dest32, entry.dest.physical.physical_dest,
+            get_apic_id());
+
+        /*
+         * Add it to the IO-APIC irq-routing table:
+         */
+        ioapic_write_entry(ioapic_i8259.apic, ioapic_i8259.pin, 0, entry);
+    }
+    disconnect_bsp_APIC(ioapic_i8259.pin != -1);
+}
+
+/*
+ * function to set the IO-APIC physical IDs based on the
+ * values stored in the MPC table.
+ *
+ * by Matt Domsch <Matt_Domsch@dell.com>  Tue Dec 21 12:25:05 CST 1999
+ */
+
+static void __init setup_ioapic_ids_from_mpc(void)
+{
+    union IO_APIC_reg_00 reg_00;
+    static physid_mask_t __initdata phys_id_present_map;
+    int apic;
+    int i;
+    unsigned char old_id;
+    unsigned long flags;
+
+    /*
+     * Don't check I/O APIC IDs for xAPIC systems. They have
+     * no meaning without the serial APIC bus.
+     */
+    if (!(boot_cpu_data.x86_vendor == X86_VENDOR_INTEL)
+        || APIC_XAPIC(apic_version[boot_cpu_physical_apicid]))
+        return;
+
+    /*
+     * This is broken; anything with a real cpu count has to
+     * circumvent this idiocy regardless.
+     */
+    ioapic_phys_id_map(&phys_id_present_map);
+
+    /*
+     * Set the IOAPIC ID to the value stored in the MPC table.
+     */
+    for (apic = 0; apic < nr_ioapics; apic++) {
+        if (!nr_ioapic_entries[apic])
+            continue;
+
+        /* Read the register 0 value */
+        spin_lock_irqsave(&ioapic_lock, flags);
+        reg_00.raw = io_apic_read(apic, 0);
+        spin_unlock_irqrestore(&ioapic_lock, flags);
+		
+        old_id = mp_ioapics[apic].mpc_apicid;
+
+        if (mp_ioapics[apic].mpc_apicid >= get_physical_broadcast()) {
+            printk(KERN_ERR "BIOS bug, IO-APIC#%d ID is %d in the MPC table!...\n",
+                   apic, mp_ioapics[apic].mpc_apicid);
+            printk(KERN_ERR "... fixing up to %d. (tell your hw vendor)\n",
+                   reg_00.bits.ID);
+            mp_ioapics[apic].mpc_apicid = reg_00.bits.ID;
+        }
+
+        /*
+         * Sanity check, is the ID really free? Every APIC in a
+         * system must have a unique ID or we get lots of nice
+         * 'stuck on smp_invalidate_needed IPI wait' messages.
+         */
+        if (check_apicid_used(&phys_id_present_map,
+                              mp_ioapics[apic].mpc_apicid)) {
+            printk(KERN_ERR "BIOS bug, IO-APIC#%d ID %d is already used!...\n",
+                   apic, mp_ioapics[apic].mpc_apicid);
+            for (i = 0; i < get_physical_broadcast(); i++)
+                if (!physid_isset(i, phys_id_present_map))
+                    break;
+            if (i >= get_physical_broadcast())
+                panic("Max APIC ID exceeded!\n");
+            printk(KERN_ERR "... fixing up to %d. (tell your hw vendor)\n",
+                   i);
+            mp_ioapics[apic].mpc_apicid = i;
+        } else {
+            apic_printk(APIC_VERBOSE, "Setting %d in the "
+                        "phys_id_present_map\n",
+                        mp_ioapics[apic].mpc_apicid);
+        }
+        set_apicid(mp_ioapics[apic].mpc_apicid, &phys_id_present_map);
+
+        /*
+         * We need to adjust the IRQ routing table
+         * if the ID changed.
+         */
+        if (old_id != mp_ioapics[apic].mpc_apicid)
+            for (i = 0; i < mp_irq_entries; i++)
+                if (mp_irqs[i].mpc_dstapic == old_id)
+                    mp_irqs[i].mpc_dstapic
+                        = mp_ioapics[apic].mpc_apicid;
+
+        /*
+         * Read the right value from the MPC table and
+         * write it into the ID register.
+         */
+        apic_printk(APIC_VERBOSE, KERN_INFO
+                    "...changing IO-APIC physical APIC ID to %d ...",
+                    mp_ioapics[apic].mpc_apicid);
+
+        reg_00.bits.ID = mp_ioapics[apic].mpc_apicid;
+        spin_lock_irqsave(&ioapic_lock, flags);
+        io_apic_write(apic, 0, reg_00.raw);
+        spin_unlock_irqrestore(&ioapic_lock, flags);
+
+        /*
+         * Sanity check
+         */
+        spin_lock_irqsave(&ioapic_lock, flags);
+        reg_00.raw = io_apic_read(apic, 0);
+        spin_unlock_irqrestore(&ioapic_lock, flags);
+        if (reg_00.bits.ID != mp_ioapics[apic].mpc_apicid)
+            printk("could not set ID!\n");
+        else
+            apic_printk(APIC_VERBOSE, " ok.\n");
+    }
+}
+
+/*
+ * There is a nasty bug in some older SMP boards, their mptable lies
+ * about the timer IRQ. We do the following to work around the situation:
+ *
+ *	- timer IRQ defaults to IO-APIC IRQ
+ *	- if this function detects that timer IRQs are defunct, then we fall
+ *	  back to ISA timer IRQs
+ */
+static int __init timer_irq_works(void)
+{
+    unsigned long t1, flags;
+
+    t1 = pit0_ticks;
+    mb();
+
+    local_save_flags(flags);
+    local_irq_enable();
+    /* Let ten ticks pass... */
+    mdelay((10 * 1000) / HZ);
+    local_irq_restore(flags);
+
+    /*
+     * Expect a few ticks at least, to be sure some possible
+     * glue logic does not lock up after one or two first
+     * ticks in a non-ExtINT mode.  Also the local APIC
+     * might have cached one ExtINT interrupt.  Finally, at
+     * least one tick may be lost due to delays.
+     */
+    mb();
+    if (pit0_ticks - t1 > 4)
+        return 1;
+
+    return 0;
+}
+
+/*
+ * In the SMP+IOAPIC case it might happen that there are an unspecified
+ * number of pending IRQ events unhandled. These cases are very rare,
+ * so we 'resend' these IRQs via IPIs, to the same CPU. It's much
+ * better to do it this way as thus we do not have to be aware of
+ * 'pending' interrupts in the IRQ path, except at this point.
+ */
+/*
+ * Edge triggered needs to resend any interrupt
+ * that was delayed but this is now handled in the device
+ * independent code.
+ */
+
+/*
+ * Starting up a edge-triggered IO-APIC interrupt is
+ * nasty - we need to make sure that we get the edge.
+ * If it is already asserted for some reason, we need
+ * return 1 to indicate that is was pending.
+ *
+ * This is not complete - we should be able to fake
+ * an edge even if it isn't on the 8259A...
+ */
+static unsigned int startup_edge_ioapic_irq(struct irq_desc *desc)
+{
+    int was_pending = 0;
+    unsigned long flags;
+
+    spin_lock_irqsave(&ioapic_lock, flags);
+    if (platform_legacy_irq(desc->irq)) {
+        disable_8259A_irq(desc);
+        if (i8259A_irq_pending(desc->irq))
+            was_pending = 1;
+    }
+    __unmask_IO_APIC_irq(desc->irq);
+    spin_unlock_irqrestore(&ioapic_lock, flags);
+
+    return was_pending;
+}
+
+/*
+ * Once we have recorded IRQ_PENDING already, we can mask the
+ * interrupt for real. This prevents IRQ storms from unhandled
+ * devices.
+ */
+static void ack_edge_ioapic_irq(struct irq_desc *desc)
+{
+    irq_complete_move(desc);
+    move_native_irq(desc);
+
+    if ((desc->status & (IRQ_PENDING | IRQ_DISABLED))
+        == (IRQ_PENDING | IRQ_DISABLED))
+        mask_IO_APIC_irq(desc);
+    ack_APIC_irq();
+}
+
+/*
+ * Level triggered interrupts can just be masked,
+ * and shutting down and starting up the interrupt
+ * is the same as enabling and disabling them -- except
+ * with a startup need to return a "was pending" value.
+ *
+ * Level triggered interrupts are special because we
+ * do not touch any IO-APIC register while handling
+ * them. We ack the APIC in the end-IRQ handler, not
+ * in the start-IRQ-handler. Protection against reentrance
+ * from the same interrupt is still provided, both by the
+ * generic IRQ layer and by the fact that an unacked local
+ * APIC does not accept IRQs.
+ */
+static unsigned int startup_level_ioapic_irq(struct irq_desc *desc)
+{
+    unmask_IO_APIC_irq(desc);
+
+    return 0; /* don't check for pending */
+}
+
+static void __init setup_ioapic_ack(char *s)
+{
+    if ( !strcmp(s, "old") )
+    {
+        ioapic_ack_new = 0;
+        ioapic_ack_forced = 1;
+    }
+    else if ( !strcmp(s, "new") )
+    {
+        ioapic_ack_new = 1;
+        ioapic_ack_forced = 1;
+    }
+    else
+        printk("Unknown ioapic_ack value specified: '%s'\n", s);
+}
+custom_param("ioapic_ack", setup_ioapic_ack);
+
+static bool_t io_apic_level_ack_pending(unsigned int irq)
+{
+    struct irq_pin_list *entry;
+    unsigned long flags;
+
+    spin_lock_irqsave(&ioapic_lock, flags);
+    entry = &irq_2_pin[irq];
+    for (;;) {
+        unsigned int reg;
+        int pin;
+
+        if (!entry)
+            break;
+
+        pin = entry->pin;
+        if (pin == -1)
+            continue;
+        reg = io_apic_read(entry->apic, 0x10 + pin*2);
+        /* Is the remote IRR bit set? */
+        if (reg & IO_APIC_REDIR_REMOTE_IRR) {
+            spin_unlock_irqrestore(&ioapic_lock, flags);
+            return 1;
+        }
+        if (!entry->next)
+            break;
+        entry = irq_2_pin + entry->next;
+    }
+    spin_unlock_irqrestore(&ioapic_lock, flags);
+
+    return 0;
+}
+
+static void mask_and_ack_level_ioapic_irq(struct irq_desc *desc)
+{
+    unsigned long v;
+    int i;
+
+    irq_complete_move(desc);
+
+    if ( !directed_eoi_enabled )
+        mask_IO_APIC_irq(desc);
+
+/*
+ * It appears there is an erratum which affects at least version 0x11
+ * of I/O APIC (that's the 82093AA and cores integrated into various
+ * chipsets).  Under certain conditions a level-triggered interrupt is
+ * erroneously delivered as edge-triggered one but the respective IRR
+ * bit gets set nevertheless.  As a result the I/O unit expects an EOI
+ * message but it will never arrive and further interrupts are blocked
+ * from the source.  The exact reason is so far unknown, but the
+ * phenomenon was observed when two consecutive interrupt requests
+ * from a given source get delivered to the same CPU and the source is
+ * temporarily disabled in between.
+ *
+ * A workaround is to simulate an EOI message manually.  We achieve it
+ * by setting the trigger mode to edge and then to level when the edge
+ * trigger mode gets detected in the TMR of a local APIC for a
+ * level-triggered interrupt.  We mask the source for the time of the
+ * operation to prevent an edge-triggered interrupt escaping meanwhile.
+ * The idea is from Manfred Spraul.  --macro
+ */
+    i = desc->arch.vector;
+
+    v = apic_read(APIC_TMR + ((i & ~0x1f) >> 1));
+
+    ack_APIC_irq();
+    
+    if ( directed_eoi_enabled )
+        return;
+
+    if ((desc->status & IRQ_MOVE_PENDING) &&
+       !io_apic_level_ack_pending(desc->irq))
+        move_masked_irq(desc);
+
+    if ( !(v & (1 << (i & 0x1f))) ) {
+        spin_lock(&ioapic_lock);
+        __edge_IO_APIC_irq(desc->irq);
+        __level_IO_APIC_irq(desc->irq);
+        spin_unlock(&ioapic_lock);
+    }
+}
+
+static void end_level_ioapic_irq_old(struct irq_desc *desc, u8 vector)
+{
+    if ( directed_eoi_enabled )
+    {
+        if ( !(desc->status & (IRQ_DISABLED|IRQ_MOVE_PENDING)) )
+        {
+            eoi_IO_APIC_irq(desc);
+            return;
+        }
+
+        mask_IO_APIC_irq(desc);
+        eoi_IO_APIC_irq(desc);
+        if ( (desc->status & IRQ_MOVE_PENDING) &&
+             !io_apic_level_ack_pending(desc->irq) )
+            move_masked_irq(desc);
+    }
+
+    if ( !(desc->status & IRQ_DISABLED) )
+        unmask_IO_APIC_irq(desc);
+}
+
+static void end_level_ioapic_irq_new(struct irq_desc *desc, u8 vector)
+{
+/*
+ * It appears there is an erratum which affects at least version 0x11
+ * of I/O APIC (that's the 82093AA and cores integrated into various
+ * chipsets).  Under certain conditions a level-triggered interrupt is
+ * erroneously delivered as edge-triggered one but the respective IRR
+ * bit gets set nevertheless.  As a result the I/O unit expects an EOI
+ * message but it will never arrive and further interrupts are blocked
+ * from the source.  The exact reason is so far unknown, but the
+ * phenomenon was observed when two consecutive interrupt requests
+ * from a given source get delivered to the same CPU and the source is
+ * temporarily disabled in between.
+ *
+ * A workaround is to simulate an EOI message manually.  We achieve it
+ * by setting the trigger mode to edge and then to level when the edge
+ * trigger mode gets detected in the TMR of a local APIC for a
+ * level-triggered interrupt.  We mask the source for the time of the
+ * operation to prevent an edge-triggered interrupt escaping meanwhile.
+ * The idea is from Manfred Spraul.  --macro
+ */
+    unsigned int v, i = desc->arch.vector;
+
+    /* Manually EOI the old vector if we are moving to the new */
+    if ( vector && i != vector )
+        eoi_IO_APIC_irq(desc);
+
+    v = apic_read(APIC_TMR + ((i & ~0x1f) >> 1));
+
+    ack_APIC_irq();
+
+    if ( (desc->status & IRQ_MOVE_PENDING) &&
+         !io_apic_level_ack_pending(desc->irq) )
+        move_native_irq(desc);
+
+    if (!(v & (1 << (i & 0x1f)))) {
+        spin_lock(&ioapic_lock);
+        __mask_IO_APIC_irq(desc->irq);
+        __edge_IO_APIC_irq(desc->irq);
+        __level_IO_APIC_irq(desc->irq);
+        if ( !(desc->status & IRQ_DISABLED) )
+            __unmask_IO_APIC_irq(desc->irq);
+        spin_unlock(&ioapic_lock);
+    }
+}
+
+/*
+ * Level and edge triggered IO-APIC interrupts need different handling,
+ * so we use two separate IRQ descriptors. Edge triggered IRQs can be
+ * handled with the level-triggered descriptor, but that one has slightly
+ * more overhead. Level-triggered interrupts cannot be handled with the
+ * edge-triggered handler, without risking IRQ storms and other ugly
+ * races.
+ */
+static hw_irq_controller ioapic_edge_type = {
+    .typename 	= "IO-APIC-edge",
+    .startup 	= startup_edge_ioapic_irq,
+    .shutdown 	= irq_shutdown_none,
+    .enable 	= unmask_IO_APIC_irq,
+    .disable 	= irq_disable_none,
+    .ack 		= ack_edge_ioapic_irq,
+    .set_affinity 	= set_ioapic_affinity_irq,
+};
+
+static struct hw_interrupt_type __read_mostly ioapic_level_type = {
+    .typename 	= "IO-APIC-level",
+    .startup 	= startup_level_ioapic_irq,
+    .shutdown 	= mask_IO_APIC_irq,
+    .enable 	= unmask_IO_APIC_irq,
+    .disable 	= mask_IO_APIC_irq,
+    .ack 		= mask_and_ack_level_ioapic_irq,
+    .end 		= end_level_ioapic_irq_old,
+    .set_affinity 	= set_ioapic_affinity_irq,
+};
+
+static inline void init_IO_APIC_traps(void)
+{
+    int irq;
+    /* Xen: This is way simpler than the Linux implementation. */
+    for (irq = 0; platform_legacy_irq(irq); irq++)
+        if (IO_APIC_IRQ(irq) && !irq_to_vector(irq))
+            make_8259A_irq(irq);
+}
+
+static void enable_lapic_irq(struct irq_desc *desc)
+{
+    unsigned long v;
+
+    v = apic_read(APIC_LVT0);
+    apic_write_around(APIC_LVT0, v & ~APIC_LVT_MASKED);
+}
+
+static void disable_lapic_irq(struct irq_desc *desc)
+{
+    unsigned long v;
+
+    v = apic_read(APIC_LVT0);
+    apic_write_around(APIC_LVT0, v | APIC_LVT_MASKED);
+}
+
+static void ack_lapic_irq(struct irq_desc *desc)
+{
+    ack_APIC_irq();
+}
+
+static hw_irq_controller lapic_irq_type = {
+    .typename 	= "local-APIC-edge",
+    .startup 	= NULL, /* startup_irq() not used for IRQ0 */
+    .shutdown 	= NULL, /* shutdown_irq() not used for IRQ0 */
+    .enable 	= enable_lapic_irq,
+    .disable 	= disable_lapic_irq,
+    .ack 		= ack_lapic_irq,
+};
+
+/*
+ * This looks a bit hackish but it's about the only one way of sending
+ * a few INTA cycles to 8259As and any associated glue logic.  ICR does
+ * not support the ExtINT mode, unfortunately.  We need to send these
+ * cycles as some i82489DX-based boards have glue logic that keeps the
+ * 8259A interrupt line asserted until INTA.  --macro
+ */
+static void __init unlock_ExtINT_logic(void)
+{
+    int apic, pin, i;
+    struct IO_APIC_route_entry entry0, entry1;
+    unsigned char save_control, save_freq_select;
+
+    pin = find_isa_irq_pin(8, mp_INT);
+    apic = find_isa_irq_apic(8, mp_INT);
+    if (pin == -1)
+        return;
+
+    entry0 = ioapic_read_entry(apic, pin, 0);
+    clear_IO_APIC_pin(apic, pin);
+
+    memset(&entry1, 0, sizeof(entry1));
+
+    entry1.dest_mode = 0;			/* physical delivery */
+    entry1.mask = 0;			/* unmask IRQ now */
+    SET_DEST(entry1.dest.dest32, entry1.dest.physical.physical_dest,
+        hard_smp_processor_id());
+    entry1.delivery_mode = dest_ExtINT;
+    entry1.polarity = entry0.polarity;
+    entry1.trigger = 0;
+    entry1.vector = 0;
+
+    ioapic_write_entry(apic, pin, 0, entry1);
+
+    save_control = CMOS_READ(RTC_CONTROL);
+    save_freq_select = CMOS_READ(RTC_FREQ_SELECT);
+    CMOS_WRITE((save_freq_select & ~RTC_RATE_SELECT) | 0x6,
+               RTC_FREQ_SELECT);
+    CMOS_WRITE(save_control | RTC_PIE, RTC_CONTROL);
+
+    i = 100;
+    while (i-- > 0) {
+        mdelay(10);
+        if ((CMOS_READ(RTC_INTR_FLAGS) & RTC_PF) == RTC_PF)
+            i -= 10;
+    }
+
+    CMOS_WRITE(save_control, RTC_CONTROL);
+    CMOS_WRITE(save_freq_select, RTC_FREQ_SELECT);
+    clear_IO_APIC_pin(apic, pin);
+
+    ioapic_write_entry(apic, pin, 0, entry0);
+}
+
+/*
+ * This code may look a bit paranoid, but it's supposed to cooperate with
+ * a wide range of boards and BIOS bugs.  Fortunately only the timer IRQ
+ * is so screwy.  Thanks to Brian Perkins for testing/hacking this beast
+ * fanatically on his truly buggy board.
+ */
+static void __init check_timer(void)
+{
+    int apic1, pin1, apic2, pin2;
+    int vector, ret;
+    unsigned long flags;
+    cpumask_t mask_all;
+
+    local_irq_save(flags);
+
+    /*
+     * get/set the timer IRQ vector:
+     */
+    disable_8259A_irq(irq_to_desc(0));
+    vector = IRQ0_VECTOR;
+    clear_irq_vector(0);
+
+    cpumask_setall(&mask_all);
+    if ((ret = bind_irq_vector(0, vector, &mask_all)))
+        printk(KERN_ERR"..IRQ0 is not set correctly with ioapic!!!, err:%d\n", ret);
+    
+    irq_desc[0].status &= ~IRQ_DISABLED;
+
+    /*
+     * Subtle, code in do_timer_interrupt() expects an AEOI
+     * mode for the 8259A whenever interrupts are routed
+     * through I/O APICs.  Also IRQ0 has to be enabled in
+     * the 8259A which implies the virtual wire has to be
+     * disabled in the local APIC.
+     */
+    apic_write_around(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_EXTINT);
+    init_8259A(1);
+    /* XEN: Ripped out the legacy missed-tick logic, so below is not needed. */
+    /*timer_ack = 1;*/
+    /*enable_8259A_irq(irq_to_desc(0));*/
+
+    pin1  = find_isa_irq_pin(0, mp_INT);
+    apic1 = find_isa_irq_apic(0, mp_INT);
+    pin2  = ioapic_i8259.pin;
+    apic2 = ioapic_i8259.apic;
+
+    printk(KERN_INFO "..TIMER: vector=0x%02X apic1=%d pin1=%d apic2=%d pin2=%d\n",
+           vector, apic1, pin1, apic2, pin2);
+
+    if (pin1 != -1) {
+        /*
+         * Ok, does IRQ0 through the IOAPIC work?
+         */
+        unmask_IO_APIC_irq(irq_to_desc(0));
+        if (timer_irq_works()) {
+            local_irq_restore(flags);
+            return;
+        }
+        clear_IO_APIC_pin(apic1, pin1);
+        printk(KERN_ERR "..MP-BIOS bug: 8254 timer not connected to "
+               "IO-APIC\n");
+    }
+
+    printk(KERN_INFO "...trying to set up timer (IRQ0) through the 8259A ... ");
+    if (pin2 != -1) {
+        printk("\n..... (found pin %d) ...", pin2);
+        /*
+         * legacy devices should be connected to IO APIC #0
+         */
+        setup_ExtINT_IRQ0_pin(apic2, pin2, vector);
+        if (timer_irq_works()) {
+            local_irq_restore(flags);
+            printk("works.\n");
+            if (pin1 != -1)
+                replace_pin_at_irq(0, apic1, pin1, apic2, pin2);
+            else
+                add_pin_to_irq(0, apic2, pin2);
+            return;
+        }
+        /*
+         * Cleanup, just in case ...
+         */
+        clear_IO_APIC_pin(apic2, pin2);
+    }
+    printk(" failed.\n");
+
+    if (nmi_watchdog == NMI_IO_APIC) {
+        printk(KERN_WARNING "timer doesn't work through the IO-APIC - disabling NMI Watchdog!\n");
+        nmi_watchdog = 0;
+    }
+
+    printk(KERN_INFO "...trying to set up timer as Virtual Wire IRQ...");
+
+    disable_8259A_irq(irq_to_desc(0));
+    irq_desc[0].handler = &lapic_irq_type;
+    apic_write_around(APIC_LVT0, APIC_DM_FIXED | vector);	/* Fixed mode */
+    enable_8259A_irq(irq_to_desc(0));
+
+    if (timer_irq_works()) {
+        local_irq_restore(flags);
+        printk(" works.\n");
+        return;
+    }
+    apic_write_around(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_FIXED | vector);
+    printk(" failed.\n");
+
+    printk(KERN_INFO "...trying to set up timer as ExtINT IRQ...");
+
+    /*timer_ack = 0;*/
+    init_8259A(0);
+    make_8259A_irq(0);
+    apic_write_around(APIC_LVT0, APIC_DM_EXTINT);
+
+    unlock_ExtINT_logic();
+
+    local_irq_restore(flags);
+
+    if (timer_irq_works()) {
+        printk(" works.\n");
+        return;
+    }
+    printk(" failed :(.\n");
+    panic("IO-APIC + timer doesn't work!  Boot with apic_verbosity=debug "
+          "and send a report.  Then try booting with the 'noapic' option");
+}
+
+/*
+ *
+ * IRQ's that are handled by the PIC in the MPS IOAPIC case.
+ * - IRQ2 is the cascade IRQ, and cannot be a io-apic IRQ.
+ *   Linux doesn't really care, as it's not actually used
+ *   for any interrupt handling anyway.
+ */
+#define PIC_IRQS	(1 << PIC_CASCADE_IR)
+
+static struct IO_APIC_route_entry *ioapic_pm_state;
+
+static void __init ioapic_pm_state_alloc(void)
+{
+    int i, nr_entry = 0;
+
+    for (i = 0; i < nr_ioapics; i++)
+        nr_entry += nr_ioapic_entries[i];
+
+    ioapic_pm_state = _xmalloc(sizeof(struct IO_APIC_route_entry)*nr_entry,
+                               sizeof(struct IO_APIC_route_entry));
+    BUG_ON(ioapic_pm_state == NULL);
+}
+
+void __init setup_IO_APIC(void)
+{
+    enable_IO_APIC();
+
+    if (acpi_ioapic)
+        io_apic_irqs = ~0;	/* all IRQs go through IOAPIC */
+    else
+        io_apic_irqs = ~PIC_IRQS;
+
+    printk("ENABLING IO-APIC IRQs\n");
+    printk(" -> Using %s ACK method\n", ioapic_ack_new ? "new" : "old");
+
+    if (ioapic_ack_new) {
+        ioapic_level_type.ack = irq_complete_move;
+        ioapic_level_type.end = end_level_ioapic_irq_new;
+    }
+
+    /*
+     * Set up IO-APIC IRQ routing.
+     */
+    if (!acpi_ioapic)
+        setup_ioapic_ids_from_mpc();
+    sync_Arb_IDs();
+    setup_IO_APIC_irqs();
+    init_IO_APIC_traps();
+    check_timer();
+    print_IO_APIC();
+    ioapic_pm_state_alloc();
+
+    register_keyhandler('z', &print_IO_APIC_keyhandler);
+}
+
+void ioapic_suspend(void)
+{
+    struct IO_APIC_route_entry *entry = ioapic_pm_state;
+    unsigned long flags;
+    int apic, i;
+
+    spin_lock_irqsave(&ioapic_lock, flags);
+    for (apic = 0; apic < nr_ioapics; apic++) {
+        for (i = 0; i < nr_ioapic_entries[apic]; i ++, entry ++ ) {
+            *(((int *)entry) + 1) = __io_apic_read(apic, 0x11 + 2 * i);
+            *(((int *)entry) + 0) = __io_apic_read(apic, 0x10 + 2 * i);
+        }
+    }
+    spin_unlock_irqrestore(&ioapic_lock, flags);
+}
+
+void ioapic_resume(void)
+{
+    struct IO_APIC_route_entry *entry = ioapic_pm_state;
+    unsigned long flags;
+    union IO_APIC_reg_00 reg_00;
+    int i, apic;
+
+    spin_lock_irqsave(&ioapic_lock, flags);
+    for (apic = 0; apic < nr_ioapics; apic++){
+        if (!nr_ioapic_entries[apic])
+            continue;
+        reg_00.raw = __io_apic_read(apic, 0);
+        if (reg_00.bits.ID != mp_ioapics[apic].mpc_apicid) {
+            reg_00.bits.ID = mp_ioapics[apic].mpc_apicid;
+            __io_apic_write(apic, 0, reg_00.raw);
+        }
+        for (i = 0; i < nr_ioapic_entries[apic]; i++, entry++) {
+            __io_apic_write(apic, 0x11+2*i, *(((int *)entry)+1));
+            __io_apic_write(apic, 0x10+2*i, *(((int *)entry)+0));
+        }
+    }
+    spin_unlock_irqrestore(&ioapic_lock, flags);
+}
+
+/* --------------------------------------------------------------------------
+                          ACPI-based IOAPIC Configuration
+   -------------------------------------------------------------------------- */
+
+#ifdef CONFIG_ACPI_BOOT
+
+int __init io_apic_get_unique_id (int ioapic, int apic_id)
+{
+    union IO_APIC_reg_00 reg_00;
+    static physid_mask_t __initdata apic_id_map = PHYSID_MASK_NONE;
+    unsigned long flags;
+    int i = 0;
+
+    /*
+     * The P4 platform supports up to 256 APIC IDs on two separate APIC 
+     * buses (one for LAPICs, one for IOAPICs), where predecessors only 
+     * supports up to 16 on one shared APIC bus.
+     * 
+     * TBD: Expand LAPIC/IOAPIC support on P4-class systems to take full
+     *      advantage of new APIC bus architecture.
+     */
+
+    if (physids_empty(apic_id_map))
+        ioapic_phys_id_map(&apic_id_map);
+
+    spin_lock_irqsave(&ioapic_lock, flags);
+    reg_00.raw = io_apic_read(ioapic, 0);
+    spin_unlock_irqrestore(&ioapic_lock, flags);
+
+    if (apic_id >= get_physical_broadcast()) {
+        printk(KERN_WARNING "IOAPIC[%d]: Invalid apic_id %d, trying "
+               "%d\n", ioapic, apic_id, reg_00.bits.ID);
+        apic_id = reg_00.bits.ID;
+    }
+
+    /*
+     * Every APIC in a system must have a unique ID or we get lots of nice 
+     * 'stuck on smp_invalidate_needed IPI wait' messages.
+     */
+    if (check_apicid_used(&apic_id_map, apic_id)) {
+
+        for (i = 0; i < get_physical_broadcast(); i++) {
+            if (!check_apicid_used(&apic_id_map, i))
+                break;
+        }
+
+        if (i == get_physical_broadcast())
+            panic("Max apic_id exceeded!\n");
+
+        printk(KERN_WARNING "IOAPIC[%d]: apic_id %d already used, "
+               "trying %d\n", ioapic, apic_id, i);
+
+        apic_id = i;
+    } 
+
+    set_apicid(apic_id, &apic_id_map);
+
+    if (reg_00.bits.ID != apic_id) {
+        reg_00.bits.ID = apic_id;
+
+        spin_lock_irqsave(&ioapic_lock, flags);
+        io_apic_write(ioapic, 0, reg_00.raw);
+        reg_00.raw = io_apic_read(ioapic, 0);
+        spin_unlock_irqrestore(&ioapic_lock, flags);
+
+        /* Sanity check */
+        if (reg_00.bits.ID != apic_id) {
+            printk("IOAPIC[%d]: Unable to change apic_id!\n", ioapic);
+            return -1;
+        }
+    }
+
+    apic_printk(APIC_VERBOSE, KERN_INFO
+                "IOAPIC[%d]: Assigned apic_id %d\n", ioapic, apic_id);
+
+    return apic_id;
+}
+
+
+int __init io_apic_get_version (int ioapic)
+{
+    union IO_APIC_reg_01	reg_01;
+    unsigned long flags;
+
+    spin_lock_irqsave(&ioapic_lock, flags);
+    reg_01.raw = io_apic_read(ioapic, 1);
+    spin_unlock_irqrestore(&ioapic_lock, flags);
+
+    return reg_01.bits.version;
+}
+
+
+int __init io_apic_get_redir_entries (int ioapic)
+{
+    union IO_APIC_reg_01	reg_01;
+    unsigned long flags;
+
+    spin_lock_irqsave(&ioapic_lock, flags);
+    reg_01.raw = io_apic_read(ioapic, 1);
+    spin_unlock_irqrestore(&ioapic_lock, flags);
+
+    return reg_01.bits.entries;
+}
+
+
+int io_apic_set_pci_routing (int ioapic, int pin, int irq, int edge_level, int active_high_low)
+{
+    struct irq_desc *desc = irq_to_desc(irq);
+    struct IO_APIC_route_entry entry;
+    unsigned long flags;
+    int vector;
+
+    if (!IO_APIC_IRQ(irq)) {
+        printk(KERN_ERR "IOAPIC[%d]: Invalid reference to IRQ %d\n",
+               ioapic, irq);
+        return -EINVAL;
+    }
+
+    /*
+     * Generate a PCI IRQ routing entry and program the IOAPIC accordingly.
+     * Note that we mask (disable) IRQs now -- these get enabled when the
+     * corresponding device driver registers for this IRQ.
+     */
+
+    memset(&entry,0,sizeof(entry));
+
+    entry.delivery_mode = INT_DELIVERY_MODE;
+    entry.dest_mode = INT_DEST_MODE;
+    SET_DEST(entry.dest.dest32, entry.dest.logical.logical_dest,
+        cpu_mask_to_apicid(TARGET_CPUS));
+    entry.trigger = edge_level;
+    entry.polarity = active_high_low;
+    entry.mask  = 1;
+
+    /*
+     * IRQs < 16 are already in the irq_2_pin[] map
+     */
+    if (!platform_legacy_irq(irq))
+        add_pin_to_irq(irq, ioapic, pin);
+
+    vector = assign_irq_vector(irq, NULL);
+    if (vector < 0)
+        return vector;
+    entry.vector = vector;
+
+    apic_printk(APIC_DEBUG, KERN_DEBUG "IOAPIC[%d]: Set PCI routing entry "
+		"(%d-%d -> %#x -> IRQ %d Mode:%i Active:%i)\n", ioapic,
+		mp_ioapics[ioapic].mpc_apicid, pin, entry.vector, irq,
+		edge_level, active_high_low);
+
+    ioapic_register_intr(irq, edge_level);
+
+    if (!ioapic && platform_legacy_irq(irq))
+        disable_8259A_irq(desc);
+
+    spin_lock_irqsave(&ioapic_lock, flags);
+    __ioapic_write_entry(ioapic, pin, 0, entry);
+    set_native_irq_info(irq, TARGET_CPUS);
+    spin_unlock(&ioapic_lock);
+
+    spin_lock(&desc->lock);
+    if (!(desc->status & (IRQ_DISABLED | IRQ_GUEST)))
+        desc->handler->startup(desc);
+    spin_unlock_irqrestore(&desc->lock, flags);
+
+    return 0;
+}
+
+#endif /*CONFIG_ACPI_BOOT*/
+
+static int ioapic_physbase_to_id(unsigned long physbase)
+{
+    int apic;
+    for ( apic = 0; apic < nr_ioapics; apic++ )
+    {
+        if ( !nr_ioapic_entries[apic] )
+            continue;
+        if ( mp_ioapics[apic].mpc_apicaddr == physbase )
+            return apic;
+    }
+    return -EINVAL;
+}
+
+unsigned apic_gsi_base(int apic);
+
+static int apic_pin_2_gsi_irq(int apic, int pin)
+{
+    int idx;
+
+    if (apic < 0)
+       return -EINVAL;
+
+    idx = find_irq_entry(apic, pin, mp_INT);
+
+    return idx >= 0 ? pin_2_irq(idx, apic, pin)
+                    : apic_gsi_base(apic) + pin;
+}
+
+int ioapic_guest_read(unsigned long physbase, unsigned int reg, u32 *pval)
+{
+    int apic;
+    unsigned long flags;
+
+    if ( (apic = ioapic_physbase_to_id(physbase)) < 0 )
+        return apic;
+
+    spin_lock_irqsave(&ioapic_lock, flags);
+    *pval = io_apic_read(apic, reg);
+    spin_unlock_irqrestore(&ioapic_lock, flags);
+
+    return 0;
+}
+
+#define WARN_BOGUS_WRITE(f, a...)                                       \
+    dprintk(XENLOG_INFO, "\n%s: "                                        \
+            "apic=%d, pin=%d, irq=%d\n"                 \
+            "%s: new_entry=%08x\n"                      \
+            "%s: " f, __FUNCTION__, apic, pin, irq,        \
+            __FUNCTION__, *(u32 *)&rte,           \
+            __FUNCTION__ , ##a )
+
+int ioapic_guest_write(unsigned long physbase, unsigned int reg, u32 val)
+{
+    int apic, pin, irq, ret, pirq;
+    struct IO_APIC_route_entry rte = { 0 };
+    unsigned long flags;
+    struct irq_desc *desc;
+
+    if ( (apic = ioapic_physbase_to_id(physbase)) < 0 )
+        return apic;
+
+    /* Only write to the first half of a route entry. */
+    if ( (reg < 0x10) || (reg & 1) )
+        return 0;
+    
+    pin = (reg - 0x10) >> 1;
+
+    /* Write first half from guest; second half is target info. */
+    *(u32 *)&rte = val;
+
+    /*
+     * What about weird destination types?
+     *  SMI:    Ignore? Ought to be set up by the BIOS.
+     *  NMI:    Ignore? Watchdog functionality is Xen's concern.
+     *  INIT:   Definitely ignore: probably a guest OS bug.
+     *  ExtINT: Ignore? Linux only asserts this at start of day.
+     * For now, print a message and return an error. We can fix up on demand.
+     */
+    if ( rte.delivery_mode > dest_LowestPrio )
+    {
+        printk("ERROR: Attempt to write weird IOAPIC destination mode!\n");
+        printk("       APIC=%d/%d, lo-reg=%x\n", apic, pin, val);
+        return -EINVAL;
+    }
+
+    /*
+     * The guest does not know physical APIC arrangement (flat vs. cluster).
+     * Apply genapic conventions for this platform.
+     */
+    rte.delivery_mode = INT_DELIVERY_MODE;
+    rte.dest_mode     = INT_DEST_MODE;
+
+    irq = apic_pin_2_gsi_irq(apic, pin);
+    if ( irq < 0 )
+        return irq;
+
+    desc = irq_to_desc(irq);
+
+    /*
+     * Since PHYSDEVOP_alloc_irq_vector is dummy, rte.vector is the pirq
+     * which corresponds to this ioapic pin, retrieve it for building
+     * pirq and irq mapping. Where the GSI is greater than 256, we assume
+     * that dom0 pirq == irq.
+     */
+    pirq = (irq >= 256) ? irq : rte.vector;
+    if ( (pirq < 0) || (pirq >= dom0->nr_pirqs) )
+        return -EINVAL;
+    
+    if ( desc->action )
+    {
+        spin_lock_irqsave(&ioapic_lock, flags);
+        ret = io_apic_read(apic, 0x10 + 2 * pin);
+        spin_unlock_irqrestore(&ioapic_lock, flags);
+        rte.vector = desc->arch.vector;
+        if ( *(u32*)&rte != ret )
+            WARN_BOGUS_WRITE("old_entry=%08x pirq=%d\n%s: "
+                             "Attempt to modify IO-APIC pin for in-use IRQ!\n",
+                             ret, pirq, __FUNCTION__);
+        return 0;
+    }
+
+    if ( desc->arch.vector <= 0 || desc->arch.vector > LAST_DYNAMIC_VECTOR )
+    {
+        int vector = desc->arch.vector;
+
+        if ( vector < FIRST_HIPRIORITY_VECTOR )
+            add_pin_to_irq(irq, apic, pin);
+        else
+            desc->arch.vector = IRQ_VECTOR_UNASSIGNED;
+        ret = assign_irq_vector(irq, NULL);
+        if ( ret < 0 )
+        {
+            if ( vector < FIRST_HIPRIORITY_VECTOR )
+                remove_pin_from_irq(irq, apic, pin);
+            else
+                desc->arch.vector = vector;
+            return ret;
+        }
+
+        printk(XENLOG_INFO "allocated vector %02x for irq %d\n", ret, irq);
+    }
+    spin_lock(&dom0->event_lock);
+    ret = map_domain_pirq(dom0, pirq, irq,
+            MAP_PIRQ_TYPE_GSI, NULL);
+    spin_unlock(&dom0->event_lock);
+    if ( ret < 0 )
+        return ret;
+
+    spin_lock_irqsave(&ioapic_lock, flags);
+    /* Set the correct irq-handling type. */
+    desc->handler = rte.trigger ? 
+        &ioapic_level_type: &ioapic_edge_type;
+
+    /* Mask iff level triggered. */
+    rte.mask = rte.trigger;
+    /* Set the vector field to the real vector! */
+    rte.vector = desc->arch.vector;
+
+    SET_DEST(rte.dest.dest32, rte.dest.logical.logical_dest,
+             cpu_mask_to_apicid(desc->arch.cpu_mask));
+
+    __ioapic_write_entry(apic, pin, 0, rte);
+    
+    spin_unlock_irqrestore(&ioapic_lock, flags);
+
+    return 0;
+}
+
+static const char * delivery_mode_2_str(
+    const enum ioapic_irq_destination_types mode)
+{
+    switch ( mode )
+    {
+    case dest_Fixed: return "Fixed";
+    case dest_LowestPrio: return "LoPri";
+    case dest_SMI: return "SMI";
+    case dest_NMI: return "NMI";
+    case dest_INIT: return "INIT";
+    case dest_ExtINT: return "ExINT";
+    case dest__reserved_1:
+    case dest__reserved_2: return "Resvd";
+    default: return "INVAL";
+    }
+}
+
+void dump_ioapic_irq_info(void)
+{
+    struct irq_pin_list *entry;
+    struct IO_APIC_route_entry rte;
+    unsigned int irq, pin, printed = 0;
+
+    if ( !irq_2_pin )
+        return;
+
+    for ( irq = 0; irq < nr_irqs_gsi; irq++ )
+    {
+        entry = &irq_2_pin[irq];
+        if ( entry->pin == -1 )
+            continue;
+
+        if ( !printed++ )
+            printk("IO-APIC interrupt information:\n");
+
+        printk("    IRQ%3d Vec%3d:\n", irq, irq_to_vector(irq));
+
+        for ( ; ; )
+        {
+            pin = entry->pin;
+
+            printk("      Apic 0x%02x, Pin %2d: ", entry->apic, pin);
+
+            rte = ioapic_read_entry(entry->apic, pin, 0);
+
+            printk("vec=%02x delivery=%-5s dest=%c status=%d "
+                   "polarity=%d irr=%d trig=%c mask=%d dest_id:%d\n",
+                   rte.vector, delivery_mode_2_str(rte.delivery_mode),
+                   rte.dest_mode ? 'L' : 'P',
+                   rte.delivery_status, rte.polarity, rte.irr,
+                   rte.trigger ? 'L' : 'E', rte.mask,
+                   rte.dest.logical.logical_dest);
+
+            if ( entry->next == 0 )
+                break;
+            entry = &irq_2_pin[entry->next];
+        }
+    }
+}
+
+static unsigned int __initdata max_gsi_irqs;
+integer_param("max_gsi_irqs", max_gsi_irqs);
+
+static __init bool_t bad_ioapic_register(unsigned int idx)
+{
+    union IO_APIC_reg_00 reg_00 = { .raw = io_apic_read(idx, 0) };
+    union IO_APIC_reg_01 reg_01 = { .raw = io_apic_read(idx, 1) };
+    union IO_APIC_reg_02 reg_02 = { .raw = io_apic_read(idx, 2) };
+
+    if ( reg_00.raw == -1 && reg_01.raw == -1 && reg_02.raw == -1 )
+    {
+        printk(KERN_WARNING "I/O APIC %#x registers return all ones, skipping!\n",
+               mp_ioapics[idx].mpc_apicaddr);
+        return 1;
+    }
+
+    return 0;
+}
+
+void __init init_ioapic_mappings(void)
+{
+    unsigned long ioapic_phys;
+    unsigned int i, idx = FIX_IO_APIC_BASE_0;
+    union IO_APIC_reg_01 reg_01;
+
+    if ( smp_found_config )
+        nr_irqs_gsi = 0;
+    for ( i = 0; i < nr_ioapics; i++ )
+    {
+        if ( smp_found_config )
+        {
+            ioapic_phys = mp_ioapics[i].mpc_apicaddr;
+            if ( !ioapic_phys )
+            {
+                printk(KERN_ERR "WARNING: bogus zero IO-APIC address "
+                       "found in MPTABLE, disabling IO/APIC support!\n");
+                smp_found_config = 0;
+                skip_ioapic_setup = 1;
+                goto fake_ioapic_page;
+            }
+        }
+        else
+        {
+ fake_ioapic_page:
+            ioapic_phys = __pa(alloc_xenheap_page());
+            clear_page(__va(ioapic_phys));
+        }
+        set_fixmap_nocache(idx, ioapic_phys);
+        apic_printk(APIC_VERBOSE, "mapped IOAPIC to %08lx (%08lx)\n",
+                    __fix_to_virt(idx), ioapic_phys);
+        idx++;
+
+        if ( bad_ioapic_register(i) )
+        {
+            __set_fixmap(idx, 0, 0);
+            continue;
+        }
+
+        if ( smp_found_config )
+        {
+            /* The number of IO-APIC IRQ registers (== #pins): */
+            reg_01.raw = io_apic_read(i, 1);
+            nr_ioapic_entries[i] = reg_01.bits.entries + 1;
+            nr_irqs_gsi += nr_ioapic_entries[i];
+
+            if ( rangeset_add_singleton(mmio_ro_ranges,
+                                        ioapic_phys >> PAGE_SHIFT) )
+                printk(KERN_ERR "Failed to mark IO-APIC page %lx read-only\n",
+                       ioapic_phys);
+        }
+    }
+
+    nr_irqs_gsi = max(nr_irqs_gsi, highest_gsi() + 1);
+
+    if ( max_gsi_irqs == 0 )
+        max_gsi_irqs = nr_irqs ? nr_irqs / 8 : PAGE_SIZE;
+    else if ( nr_irqs != 0 && max_gsi_irqs > nr_irqs )
+    {
+        printk(XENLOG_WARNING "\"max_gsi_irqs=\" cannot be specified larger"
+                              " than \"nr_irqs=\"\n");
+        max_gsi_irqs = nr_irqs;
+    }
+    if ( max_gsi_irqs < 16 )
+        max_gsi_irqs = 16;
+
+    /* for PHYSDEVOP_pirq_eoi_gmfn guest assumptions */
+    if ( max_gsi_irqs > PAGE_SIZE * 8 )
+        max_gsi_irqs = PAGE_SIZE * 8;
+
+    if ( !smp_found_config || skip_ioapic_setup || nr_irqs_gsi < 16 )
+        nr_irqs_gsi = 16;
+    else if ( nr_irqs_gsi > max_gsi_irqs )
+    {
+        printk(XENLOG_WARNING "Limiting to %u GSI IRQs (found %u)\n",
+               max_gsi_irqs, nr_irqs_gsi);
+        nr_irqs_gsi = max_gsi_irqs;
+    }
+
+    if ( nr_irqs == 0 )
+        nr_irqs = cpu_has_apic ?
+                  max(16U + num_present_cpus() * NR_DYNAMIC_VECTORS,
+                      8 * nr_irqs_gsi) :
+                  nr_irqs_gsi;
+    else if ( nr_irqs < 16 )
+        nr_irqs = 16;
+    printk(XENLOG_INFO "IRQ limits: %u GSI, %u MSI/MSI-X\n",
+           nr_irqs_gsi, nr_irqs - nr_irqs_gsi);
+}
+
diff -Naur xen/xen/arch/x86/platform_hypercall.c xen-b/xen/arch/x86/platform_hypercall.c
--- xen/xen/arch/x86/platform_hypercall.c	2013-05-30 10:38:28.421707539 -0600
+++ xen-b/xen/arch/x86/platform_hypercall.c	2013-05-30 18:15:29.978374207 -0600
@@ -25,7 +25,7 @@
 #include <xen/irq.h>
 #include <asm/current.h>
 #include <public/platform.h>
-#include <acpi/cpufreq/processor_perf.h>
+#include <acpi/cpufreq/cpufreq.h>
 #include <asm/edd.h>
 #include <asm/mtrr.h>
 #include <asm/io_apic.h>
@@ -597,6 +597,41 @@
     }
     break;
 
+    case XENPF_get_cpu_freq:
+    case XENPF_get_cpu_freq_min:
+    case XENPF_get_cpu_freq_max:
+    {
+        struct vcpu *v;
+        const struct cpufreq_policy *policy;
+
+        if ( op->u.get_cpu_freq.vcpu >= current->domain->max_vcpus ||
+             !(v = current->domain->vcpu[op->u.get_cpu_freq.vcpu]) )
+        {
+            ret = -EINVAL;
+            break;
+        }
+
+        policy = per_cpu(cpufreq_cpu_policy, v->processor);
+        switch ( op->cmd & -!!policy )
+        {
+        case XENPF_get_cpu_freq:
+            op->u.get_cpu_freq.freq = policy->cur;
+            break;
+        case XENPF_get_cpu_freq_min:
+            op->u.get_cpu_freq.freq = policy->min;
+            break;
+        case XENPF_get_cpu_freq_max:
+            op->u.get_cpu_freq.freq = policy->max;
+            break;
+        default:
+            op->u.get_cpu_freq.freq = 0;
+            break;
+        }
+        if ( copy_field_to_guest(u_xenpf_op, op, u.get_cpu_freq.freq) )
+            ret = -EFAULT;
+    }
+    break;
+
     default:
         ret = -ENOSYS;
         break;
diff -Naur xen/xen/arch/x86/x86_64/entry.S xen-b/xen/arch/x86/x86_64/entry.S
--- xen/xen/arch/x86/x86_64/entry.S	2013-05-30 10:38:28.425040872 -0600
+++ xen-b/xen/arch/x86/x86_64/entry.S	2013-05-30 18:15:29.978374207 -0600
@@ -433,22 +433,35 @@
         jz    domain_crash_synchronous
         movq  %rax,UREGS_rip+8(%rsp)
         ret
-        _ASM_EXTABLE(.Lft2,  domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft3,  domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft4,  domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft5,  domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft6,  domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft7,  domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft8,  domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft9,  domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft10, domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft11, domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft12, domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft13, domain_crash_synchronous)
+        _ASM_EXTABLE(.Lft2,  domain_crash_page_fault_32)
+        _ASM_EXTABLE(.Lft3,  domain_crash_page_fault_24)
+        _ASM_EXTABLE(.Lft4,  domain_crash_page_fault_8)
+        _ASM_EXTABLE(.Lft5,  domain_crash_page_fault_16)
+        _ASM_EXTABLE(.Lft6,  domain_crash_page_fault)
+        _ASM_EXTABLE(.Lft7,  domain_crash_page_fault)
+        _ASM_EXTABLE(.Lft8,  domain_crash_page_fault_24)
+        _ASM_EXTABLE(.Lft9,  domain_crash_page_fault_16)
+        _ASM_EXTABLE(.Lft10, domain_crash_page_fault_8)
+        _ASM_EXTABLE(.Lft11, domain_crash_page_fault)
+        _ASM_EXTABLE(.Lft12, domain_crash_page_fault_8)
+        _ASM_EXTABLE(.Lft13, domain_crash_page_fault)
 
+.section .rodata, "a", @progbits
 domain_crash_synchronous_string:
         .asciz "domain_crash_sync called from entry.S\n"
+.previous
 
+domain_crash_page_fault_32:
+        addq  $8,%rsi
+domain_crash_page_fault_24:
+        addq  $8,%rsi
+domain_crash_page_fault_16:
+        addq  $8,%rsi
+domain_crash_page_fault_8:
+        addq  $8,%rsi
+domain_crash_page_fault:
+        movq  %rsi,%rdi
+        call  show_page_walk
 ENTRY(domain_crash_synchronous)
         # Get out of the guest-save area of the stack.
         GET_STACK_BASE(%rax)
diff -Naur xen/xen/include/Makefile xen-b/xen/include/Makefile
--- xen/xen/include/Makefile	2013-05-30 10:38:28.451707539 -0600
+++ xen-b/xen/include/Makefile	2013-05-30 18:15:29.978374207 -0600
@@ -78,7 +78,7 @@
 all: headers.chk
 
 headers.chk: $(filter-out public/arch-% public/%ctl.h public/xsm/% public/%hvm/save.h, $(wildcard public/*.h public/*/*.h) $(public-y)) Makefile
-	for i in $(filter %.h,$^); do $(CC) -ansi -include stdint.h -Wall -W -Werror -S -o /dev/null -xc $$i || exit 1; echo $$i; done >$@.new
+	for i in $(filter %.h,$^); do $(CC) -ansi -include stdint.h -Wall -W -S -o /dev/null -xc $$i || exit 1; echo $$i; done >$@.new
 	mv $@.new $@
 
 endif
diff -Naur xen/xen/include/public/io/blkif.h xen-b/xen/include/public/io/blkif.h
--- xen/xen/include/public/io/blkif.h	2013-05-30 10:38:28.475040873 -0600
+++ xen-b/xen/include/public/io/blkif.h	2013-05-30 18:15:29.978374207 -0600
@@ -439,7 +439,7 @@
  * Used in SLES sources for device specific command packet
  * contained within the request. Reserved for that purpose.
  */
-#define BLKIF_OP_RESERVED_1        4
+#define BLKIF_OP_PACKET        4
 /*
  * Indicate to the backend device that a region of storage is no longer in
  * use, and may be discarded at any time without impact to the client.  If
diff -Naur xen/xen/include/public/io/cdromif.h xen-b/xen/include/public/io/cdromif.h
--- xen/xen/include/public/io/cdromif.h	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/xen/include/public/io/cdromif.h	2013-05-30 18:15:29.978374207 -0600
@@ -0,0 +1,122 @@
+/******************************************************************************
+ * cdromif.h
+ *
+ * Shared definitions between backend driver and Xen guest Virtual CDROM
+ * block device.
+ *
+ * Copyright (c) 2008, Pat Campell  plc@novell.com
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this source file (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef __XEN_PUBLIC_IO_CDROMIF_H__
+#define __XEN_PUBLIC_IO_CDROMIF_H__
+
+#include <linux/cdrom.h>
+
+/*
+ * Queries backend for CDROM support
+ */
+#define XEN_TYPE_CDROM_SUPPORT         _IO('c', 1)
+
+struct xen_cdrom_support
+{
+	uint32_t type;
+	int8_t ret;                  /* returned, 0 succeded, -1 error */
+	int8_t err;                  /* returned, backend errno */
+	int8_t supported;            /* returned, 1 supported */
+};
+
+/*
+ * Opens backend device, returns drive geometry or
+ * any encountered errors
+ */
+#define XEN_TYPE_CDROM_OPEN            _IO('c', 2)
+
+struct xen_cdrom_open
+{
+	uint32_t type;
+	int8_t ret;
+	int8_t err;
+	int8_t pad;
+	int8_t media_present;        /* returned */
+	uint32_t sectors;            /* returned */
+	uint32_t sector_size;        /* returned */
+	int32_t payload_offset;      /* offset to backend node name payload */
+};
+
+/*
+ * Queries backend for media changed status
+ */
+#define XEN_TYPE_CDROM_MEDIA_CHANGED   _IO('c', 3)
+
+struct xen_cdrom_media_changed
+{
+	uint32_t type;
+	int8_t ret;
+	int8_t err;
+	int8_t media_changed;        /* returned */
+};
+
+/*
+ * Sends vcd generic CDROM packet to backend, followed
+ * immediately by the vcd_generic_command payload
+ */
+#define XEN_TYPE_CDROM_PACKET          _IO('c', 4)
+
+struct xen_cdrom_packet
+{
+	uint32_t type;
+	int8_t ret;
+	int8_t err;
+	int8_t pad[2];
+	int32_t payload_offset;      /* offset to struct vcd_generic_command payload */
+};
+
+/* CDROM_PACKET_COMMAND, payload for XEN_TYPE_CDROM_PACKET */
+struct vcd_generic_command
+{
+	uint8_t  cmd[CDROM_PACKET_SIZE];
+	uint8_t  pad[4];
+	uint32_t buffer_offset;
+	uint32_t buflen;
+	int32_t  stat;
+	uint32_t sense_offset;
+	uint8_t  data_direction;
+	uint8_t  pad1[3];
+	int32_t  quiet;
+	int32_t  timeout;
+};
+
+union xen_block_packet
+{
+	uint32_t type;
+	struct xen_cdrom_support xcs;
+	struct xen_cdrom_open xco;
+	struct xen_cdrom_media_changed xcmc;
+	struct xen_cdrom_packet xcp;
+};
+
+#define PACKET_PAYLOAD_OFFSET (sizeof(struct xen_cdrom_packet))
+#define PACKET_SENSE_OFFSET (PACKET_PAYLOAD_OFFSET + sizeof(struct vcd_generic_command))
+#define PACKET_BUFFER_OFFSET (PACKET_SENSE_OFFSET + sizeof(struct request_sense))
+#define MAX_PACKET_DATA (PAGE_SIZE - sizeof(struct xen_cdrom_packet) - \
+            sizeof(struct vcd_generic_command) - sizeof(struct request_sense))
+
+#endif
diff -Naur xen/xen/include/public/platform.h xen-b/xen/include/public/platform.h
--- xen/xen/include/public/platform.h	2013-05-30 10:38:28.475040873 -0600
+++ xen-b/xen/include/public/platform.h	2013-05-30 18:15:29.978374207 -0600
@@ -527,6 +527,16 @@
 typedef struct xenpf_core_parking xenpf_core_parking_t;
 DEFINE_XEN_GUEST_HANDLE(xenpf_core_parking_t);
 
+#define XENPF_get_cpu_freq        ('N' << 24)
+#define XENPF_get_cpu_freq_min    (XENPF_get_cpu_freq + 1)
+#define XENPF_get_cpu_freq_max    (XENPF_get_cpu_freq_min + 1)
+struct xenpf_get_cpu_freq {
+    /* IN variables */
+    uint32_t vcpu;
+    /* OUT variables */
+    uint32_t freq; /* in kHz */
+};
+
 /*
  * ` enum neg_errnoval
  * ` HYPERVISOR_platform_op(const struct xen_platform_op*);
@@ -553,6 +563,7 @@
         struct xenpf_cpu_hotadd        cpu_add;
         struct xenpf_mem_hotadd        mem_add;
         struct xenpf_core_parking      core_parking;
+        struct xenpf_get_cpu_freq      get_cpu_freq;
         uint8_t                        pad[128];
     } u;
 };
