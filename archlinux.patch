diff -Naur xen/Config.mk xen-a/Config.mk
--- xen/Config.mk	2013-07-13 21:25:38.041060484 -0600
+++ xen-a/Config.mk	2013-07-13 21:29:04.898060484 -0600
@@ -68,7 +68,7 @@
 
 # See distro_mapping.txt for other options
 $(eval $(call setvar_dir,CONFIG_LEAF_DIR,,/etc/sysconfig,sysconfig,default))
-$(eval $(call setvar_dir,SUBSYS_DIR,/var/run,/subsys,/subsys,))
+$(eval $(call setvar_dir,SUBSYS_DIR,/run,/subsys,/subsys,))
 $(eval $(call setvar_dir,INITD_DIR,/etc,/rc.d/init.d,/rc.d/init.d,/init.d))
 
 ifneq ($(EXTRA_PREFIX),)
diff -Naur xen/Makefile xen-a/Makefile
--- xen/Makefile	2013-07-13 21:25:38.041060484 -0600
+++ xen-a/Makefile	2013-07-13 21:29:04.899060484 -0600
@@ -236,7 +236,7 @@
 	rm -f  $(D)$(CONFIG_DIR)/udev/rules.d/xend.rules
 	rm -f  $(D)$(SYSCONFIG_DIR)/xendomains
 	rm -f  $(D)$(SYSCONFIG_DIR)/xencommons
-	rm -rf $(D)/var/run/xen* $(D)/var/lib/xen*
+	rm -rf $(D)/run/xen* $(D)/var/lib/xen*
 	make -C tools uninstall
 	rm -rf $(D)/boot/tboot*
 
diff -Naur xen/config/StdGNU.mk xen-a/config/StdGNU.mk
--- xen/config/StdGNU.mk	2013-07-13 21:25:38.047060484 -0600
+++ xen-a/config/StdGNU.mk	2013-07-13 21:29:04.900060484 -0600
@@ -42,8 +42,8 @@
 PRIVATE_BINDIR = $(PRIVATE_PREFIX)/bin
 
 CONFIG_DIR = /etc
-XEN_LOCK_DIR = /var/lock
-XEN_RUN_DIR = /var/run/xen
+XEN_LOCK_DIR = /run/lock
+XEN_RUN_DIR = /run/xen
 XEN_PAGING_DIR = /var/lib/xen/xenpaging
 
 SYSCONFIG_DIR = $(CONFIG_DIR)/$(CONFIG_LEAF_DIR)
diff -Naur xen/configure xen-a/configure
--- xen/configure	2013-07-13 21:25:38.053060484 -0600
+++ xen-a/configure	2013-07-13 21:29:04.903060484 -0600
@@ -666,7 +666,7 @@
 datadir='${datarootdir}'
 sysconfdir='${prefix}/etc'
 sharedstatedir='${prefix}/com'
-localstatedir='${prefix}/var'
+localstatedir='${prefix}/run'
 includedir='${prefix}/include'
 oldincludedir='/usr/include'
 docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
@@ -1210,7 +1210,7 @@
   --libexecdir=DIR        program executables [EPREFIX/libexec]
   --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
   --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
-  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --localstatedir=DIR     modifiable single-machine data [PREFIX/run]
   --libdir=DIR            object code libraries [EPREFIX/lib]
   --includedir=DIR        C header files [PREFIX/include]
   --oldincludedir=DIR     C header files for non-gcc [/usr/include]
diff -Naur xen/tools/Makefile xen-a/tools/Makefile
--- xen/tools/Makefile	2013-07-13 21:25:38.185060484 -0600
+++ xen-a/tools/Makefile	2013-07-13 21:29:04.906060484 -0600
@@ -69,7 +69,7 @@
 	$(INSTALL_DIR) $(DESTDIR)/var/xen/dump
 	$(INSTALL_DIR) $(DESTDIR)/var/log/xen
 	$(INSTALL_DIR) $(DESTDIR)/var/lib/xen
-	$(INSTALL_DIR) $(DESTDIR)/var/lock/subsys
+	$(INSTALL_DIR) $(DESTDIR)/run/lock/subsys
 
 .PHONY: uninstall
 uninstall: D=$(DESTDIR)
diff -Naur xen/tools/blktap/drivers/blktapctrl.c xen-a/tools/blktap/drivers/blktapctrl.c
--- xen/tools/blktap/drivers/blktapctrl.c	2013-07-13 21:25:38.187060484 -0600
+++ xen-a/tools/blktap/drivers/blktapctrl.c	2013-07-13 21:29:04.907060484 -0600
@@ -61,7 +61,7 @@
 #include "list.h"
 #include "xs_api.h" /* for xs_fire_next_watch() */
 
-#define PIDFILE "/var/run/blktapctrl.pid"
+#define PIDFILE "/run/blktapctrl.pid"
 
 #define NUM_POLL_FDS 2
 #define MSG_SIZE 4096
diff -Naur xen/tools/blktap/lib/blktaplib.h xen-a/tools/blktap/lib/blktaplib.h
--- xen/tools/blktap/lib/blktaplib.h	2013-07-13 21:25:38.192060484 -0600
+++ xen-a/tools/blktap/lib/blktaplib.h	2013-07-13 21:29:04.908060484 -0600
@@ -83,7 +83,7 @@
 #define BLKTAP_DEV_DIR   "/dev/xen"
 #define BLKTAP_DEV_NAME  "blktap"
 #define BLKTAP_DEV_MINOR 0
-#define BLKTAP_CTRL_DIR   "/var/run/tap"
+#define BLKTAP_CTRL_DIR   "/run/tap"
 
 extern int blktap_major;
 
diff -Naur xen/tools/blktap2/include/blktap2.h xen-a/tools/blktap2/include/blktap2.h
--- xen/tools/blktap2/include/blktap2.h	2013-07-13 21:25:38.211060484 -0600
+++ xen-a/tools/blktap2/include/blktap2.h	2013-07-13 21:29:04.910060484 -0600
@@ -45,7 +45,7 @@
 
 #define BLKTAP2_SYSFS_DIR              "/sys/class/blktap2"
 #define BLKTAP2_CONTROL_NAME           "blktap-control"
-#define BLKTAP2_CONTROL_DIR            "/var/run/"BLKTAP2_CONTROL_NAME
+#define BLKTAP2_CONTROL_DIR            "/run/"BLKTAP2_CONTROL_NAME
 #define BLKTAP2_CONTROL_SOCKET         "ctl"
 #define BLKTAP2_DIRECTORY              "/dev/xen/blktap-2"
 #define BLKTAP2_CONTROL_DEVICE         BLKTAP2_DIRECTORY"/control"
diff -Naur xen/tools/blktap2/include/blktaplib.h xen-a/tools/blktap2/include/blktaplib.h
--- xen/tools/blktap2/include/blktaplib.h	2013-07-13 21:25:38.211060484 -0600
+++ xen-a/tools/blktap2/include/blktaplib.h	2013-07-13 21:29:04.911060484 -0600
@@ -81,7 +81,7 @@
 #define BLKTAP_DEV_NAME         "blktap"
 #define BACKDEV_NAME            "backdev"
 #define BLKTAP_DEV_MINOR        0
-#define BLKTAP_CTRL_DIR         "/var/run/tap"
+#define BLKTAP_CTRL_DIR         "/run/tap"
 
 extern int blktap_major;
 
diff -Naur xen/tools/configure xen-a/tools/configure
--- xen/tools/configure	2013-07-13 21:25:38.219060484 -0600
+++ xen-a/tools/configure	2013-07-13 21:29:04.916060484 -0600
@@ -802,7 +802,7 @@
 datadir='${datarootdir}'
 sysconfdir='${prefix}/etc'
 sharedstatedir='${prefix}/com'
-localstatedir='${prefix}/var'
+localstatedir='${prefix}/run'
 includedir='${prefix}/include'
 oldincludedir='/usr/include'
 docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
@@ -1346,7 +1346,7 @@
   --libexecdir=DIR        program executables [EPREFIX/libexec]
   --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
   --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
-  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --localstatedir=DIR     modifiable single-machine data [PREFIX/run]
   --libdir=DIR            object code libraries [EPREFIX/lib]
   --includedir=DIR        C header files [PREFIX/include]
   --oldincludedir=DIR     C header files for non-gcc [/usr/include]
diff -Naur xen/tools/console/daemon/main.c xen-a/tools/console/daemon/main.c
--- xen/tools/console/daemon/main.c	2013-07-13 21:25:38.221060484 -0600
+++ xen-a/tools/console/daemon/main.c	2013-07-13 21:29:04.917060484 -0600
@@ -155,7 +155,7 @@
 	setlogmask(syslog_mask);
 
 	if (!is_interactive) {
-		daemonize(pidfile ? pidfile : "/var/run/xenconsoled.pid");
+		daemonize(pidfile ? pidfile : "/run/xenconsoled.pid");
 	}
 
 	if (!xen_setup())
diff -Naur xen/tools/examples/xl.conf xen-a/tools/examples/xl.conf
--- xen/tools/examples/xl.conf	2013-07-13 21:25:38.227060484 -0600
+++ xen-a/tools/examples/xl.conf	2013-07-13 21:29:04.920060484 -0600
@@ -6,7 +6,7 @@
 #autoballoon="auto"
 
 # full path of the lockfile used by xl during domain creation
-#lockfile="/var/lock/xl"
+#lockfile="/run/lock/xl"
 
 # default output format used by "xl list -l"
 #output_format="json"
diff -Naur xen/tools/examples/xl.conf.orig xen-a/tools/examples/xl.conf.orig
--- xen/tools/examples/xl.conf.orig	1969-12-31 17:00:00.000000000 -0700
+++ xen-a/tools/examples/xl.conf.orig	2013-07-13 21:29:04.920060484 -0600
@@ -0,0 +1,35 @@
+## Global XL config file ##
+
+# Control whether dom0 is ballooned down when xen doesn't have enough
+# free memory to create a domain.  "auto" means only balloon if dom0
+# starts with all the host's memory.
+#autoballoon="auto"
+
+# full path of the lockfile used by xl during domain creation
+#lockfile="/var/lock/xl"
+
+# default output format used by "xl list -l"
+#output_format="json"
+
+# first block device to be used for temporary VM disk mounts
+#blkdev_start="xvda"
+
+# default option to run hotplug scripts from xl
+# if disabled the old behaviour will be used, and hotplug scripts will be
+# launched by udev.
+#run_hotplug_scripts=1
+
+# default gateway device to use with vif-route hotplug script
+#vif.default.gatewaydev="eth0"
+
+# default vif script to use if none is specified in the guest config
+#vif.default.script="vif-bridge"
+
+# default bridge device to use with vif-bridge hotplug scripts
+#vif.default.bridge="xenbr0"
+
+# Reserve a claim of memory when launching a guest. This guarantees immediate
+# feedback whether the guest can be launched due to memory exhaustion
+# (which can take a long time to find out if launching huge guests).
+# see xl.conf(5) for details.
+#claim_mode=0
diff -Naur xen/tools/hotplug/Linux/init.d/xencommons xen-a/tools/hotplug/Linux/init.d/xencommons
--- xen/tools/hotplug/Linux/init.d/xencommons	2013-07-13 21:25:38.263060484 -0600
+++ xen-a/tools/hotplug/Linux/init.d/xencommons	2013-07-13 21:29:04.921060484 -0600
@@ -20,6 +20,9 @@
 
 . /etc/xen/scripts/hotplugpath.sh
 
+. /etc/rc.conf
+. /etc/rc.d/functions
+
 if [ -d /etc/sysconfig ]; then
 	xencommons_config=/etc/sysconfig
 else
@@ -28,8 +31,8 @@
 
 test -f $xencommons_config/xencommons && . $xencommons_config/xencommons
 
-XENCONSOLED_PIDFILE=/var/run/xenconsoled.pid
-QEMU_PIDFILE=/var/run/qemu-dom0.pid
+XENCONSOLED_PIDFILE=/run/xenconsoled.pid
+QEMU_PIDFILE=/run/qemu-dom0.pid
 shopt -s extglob
 
 # not running in Xen dom0 or domU
@@ -57,22 +60,27 @@
         local time=0
 	local timeout=30
 
-	modprobe xen-evtchn 2>/dev/null
-	modprobe xen-gntdev 2>/dev/null
-	modprobe xen-gntalloc 2>/dev/null
-	modprobe xen-blkback 2>/dev/null
-	modprobe xen-netback 2>/dev/null
-	modprobe xen-pciback 2>/dev/null
-	modprobe evtchn 2>/dev/null
-	modprobe gntdev 2>/dev/null
-	modprobe netbk 2>/dev/null
-	modprobe blkbk 2>/dev/null
-	modprobe xen-scsibk 2>/dev/null
-	modprobe usbbk 2>/dev/null
-	modprobe pciback 2>/dev/null
-	modprobe xen-acpi-processor 2>/dev/null
-	modprobe blktap2 2>/dev/null || modprobe blktap 2>/dev/null
-	mkdir -p /var/run/xen
+	#modprobe xen-evtchn 2>/dev/null
+	#modprobe xen-gntdev 2>/dev/null
+	#modprobe xen-gntalloc 2>/dev/null
+	#modprobe xen-blkback 2>/dev/null
+	#modprobe xen-netback 2>/dev/null
+	#modprobe xen-pciback 2>/dev/null
+	modprobe evtchn 2>/dev/null || true
+	modprobe gntdev 2>/dev/null || true
+	modprobe gntalloc 2>/dev/null || true
+	modprobe netbk 2>/dev/null || true
+	modprobe blkbk 2>/dev/null || true
+	modprobe xen-scsibk 2>/dev/null || true
+	modprobe usbbk 2>/dev/null || true
+	modprobe pciback 2>/dev/null || true
+	modprobe xen-acpi-processor 2>/dev/null || true
+	modprobe blktap2 2>/dev/null || modprobe blktap 2>/dev/null || true
+	# xenblk (frontend module) is needed in dom0, allowing it to use vbds
+	modprobe xenblk 2>/dev/null || true
+	# support xl create pv guest with qcow/qcow2 disk image
+	modprobe nbd max_part=8 2>/dev/null || true
+	mkdir -p /run/xen
 
 	if ! `${BINDIR}/xenstore-read -s / >/dev/null 2>&1`
 	then
@@ -82,13 +90,13 @@
 
 		if [ -n "$XENSTORED" ] ; then
 		    echo -n Starting $XENSTORED...
-		    $XENSTORED --pid-file /var/run/xenstored.pid $XENSTORED_ARGS
+		    $XENSTORED --pid-file /run/xenstored.pid $XENSTORED_ARGS
 		elif [ -x ${SBINDIR}/oxenstored ] ; then
 		    echo -n Starting oxenstored...
-		    ${SBINDIR}/oxenstored --pid-file /var/run/xenstored.pid $XENSTORED_ARGS
+		    ${SBINDIR}/oxenstored --pid-file /run/xenstored.pid $XENSTORED_ARGS
 		elif [ -x ${SBINDIR}/xenstored ] ; then
 		    echo -n Starting C xenstored...
-		    ${SBINDIR}/xenstored --pid-file /var/run/xenstored.pid $XENSTORED_ARGS
+		    ${SBINDIR}/xenstored --pid-file /run/xenstored.pid $XENSTORED_ARGS
 		else
 		    echo "No xenstored found"
 		    exit 1
@@ -105,14 +113,16 @@
 		# Exit if we timed out
 		if ! [ $time -lt $timeout ] ; then
 		    echo Could not start xenstored
+                    stat_fail
 		    exit 1
 		fi
 
-		echo Setting domain 0 name...
+		stat_busy "Setting domain 0 name..."
+                stat_done
 		${BINDIR}/xenstore-write "/local/domain/0/name" "Domain-0"
 	fi
 
-	echo Starting xenconsoled...
+	stat_busy "Starting xenconsoled"
 	test -z "$XENCONSOLED_TRACE" || XENCONSOLED_ARGS=" --log=$XENCONSOLED_TRACE"
 	${SBINDIR}/xenconsoled --pid-file=$XENCONSOLED_PIDFILE $XENCONSOLED_ARGS
 	echo Starting QEMU as disk backend for dom0
diff -Naur xen/tools/hotplug/Linux/init.d/xendomains xen-a/tools/hotplug/Linux/init.d/xendomains
--- xen/tools/hotplug/Linux/init.d/xendomains	2013-07-13 21:25:38.263060484 -0600
+++ xen-a/tools/hotplug/Linux/init.d/xendomains	2013-07-13 21:40:22.588060484 -0600
@@ -1,64 +1,38 @@
 #!/bin/bash
 #
-# /etc/init.d/xendomains
-# Start / stop domains automatically when domain 0 boots / shuts down.
+# xendomains	Starts and stops Xen VMs
 #
-# chkconfig: 345 99 00
-# description: Start / stop Xen domains.
-#
-# This script offers fairly basic functionality.  It should work on Redhat
-# but also on LSB-compliant SuSE releases and on Debian with the LSB package
-# installed.  (LSB is the Linux Standard Base)
-#
-# Based on the example in the "Designing High Quality Integrated Linux
-# Applications HOWTO" by Avi Alkalay
-# <http://www.tldp.org/HOWTO/HighQuality-Apps-HOWTO/>
+# chkconfig: 35 99 00
+# description: Starts and stops Xen VMs
 #
 ### BEGIN INIT INFO
 # Provides:          xendomains
 # Required-Start:    $syslog $remote_fs xenstored xenconsoled
-# Should-Start:      xend
+# Should-Start:      xend iscsi o2cb ocfs2
 # Required-Stop:     $syslog $remote_fs xenstored xenconsoled
-# Should-Stop:       xend
-# Default-Start:     2 3 5
-# Default-Stop:      0 1 6
-# Short-Description: Start/stop secondary xen domains
-# Description:       Start / stop domains automatically when domain 0 
-#                    boots / shuts down.
+# Should-Stop:       xend iscsi
+# Default-Start:     3 5
+# Default-Stop:      0 1 2 6
+# Short-Description: Starts and stops Xen VMs
+# Description:       Starts and stops Xen VMs automatically when the
+#                    host starts and stops.
 ### END INIT INFO
 
-. /etc/xen/scripts/hotplugpath.sh
-
-CMD=${SBINDIR}/xm
-HEADCOMP="LinuxGuestRecord"
-$CMD list &> /dev/null
-if test $? -ne 0
-then
-	CMD=${SBINDIR}/xl
-	HEADCOMP="Xen saved domain"
-fi
-
-$CMD list &> /dev/null
-if test $? -ne 0
-then
-	exit 0;
-fi
+. /etc/rc.status
+rc_reset
 
-# Correct exit code would probably be 5, but it's enough 
-# if xend complains if we're not running as privileged domain
-if ! [ -e /proc/xen/privcmd ]; then
-	exit 0
-fi
+RETCODE_FILE=/tmp/xendomains.rc.$$
+xm_cmd=echo
 
 # See docs/misc/distro_mapping.txt
-if [ -d /var/lock/subsys ]; then
-	LOCKFILE=/var/lock/subsys/xendomains
+if [ -d /run/lock/subsys ]; then
+	LOCKFILE=/run/lock/subsys/xendomains
 else
-	LOCKFILE=/var/lock/xendomains
+	LOCKFILE=/run/lock/xendomains
 fi
 
-if [ -d /etc/sysconfig ]; then
-	XENDOM_CONFIG=/etc/sysconfig/xendomains
+if [ -d /etc/conf.d ]; then
+	XENDOM_CONFIG=/etc/conf.d/xendomains
 else
 	XENDOM_CONFIG=/etc/default/xendomains
 fi
@@ -67,519 +41,472 @@
 	if [ "$1" = "stop" ]; then exit 0;
 	else exit 6; fi; }
 
-. $XENDOM_CONFIG
+. "$XENDOM_CONFIG"
+
+shopt -s dotglob nullglob
 
-# Use the SUSE rc_ init script functions;
-# emulate them on LSB, RH and other systems
-if test -e /etc/rc.status; then
-    # SUSE rc script library
-    . /etc/rc.status
-else    
-    _cmd=$1
-    declare -a _SMSG
-    if test "${_cmd}" = "status"; then
-	_SMSG=(running dead dead unused unknown)
-	_RC_UNUSED=3
-    else
-	_SMSG=(done failed failed missed failed skipped unused failed failed)
-	_RC_UNUSED=6
-    fi
-    if test -e /etc/init.d/functions; then
-	# REDHAT
-	. /etc/init.d/functions
-	echo_rc()
+smart_term=1
+if [ -z "$esc" ]; then
+	smart_term=0
+	rc_timer_on()
 	{
-	    #echo -n "  [${_SMSG[${_RC_RV}]}] "
-	    if test ${_RC_RV} = 0; then
-		success "  [${_SMSG[${_RC_RV}]}] "
-	    else
-		failure "  [${_SMSG[${_RC_RV}]}] "
-	    fi
+		(trap "exit 0" TERM; sleep $1) & _rc_timer_pid=$!
 	}
-    elif test -e /lib/lsb/init-functions; then
-	# LSB    
-    	. /lib/lsb/init-functions
-        if alias log_success_msg >/dev/null 2>/dev/null; then
-	  echo_rc()
-	  {
-	       echo "  [${_SMSG[${_RC_RV}]}] "
-	  }
-        else
-	  echo_rc()
-	  {
-	    if test ${_RC_RV} = 0; then
-		log_success_msg "  [${_SMSG[${_RC_RV}]}] "
-	    else
-		log_failure_msg "  [${_SMSG[${_RC_RV}]}] "
-	    fi
-	  }
-        fi
-    else    
-	# emulate it
-	echo_rc()
+	rc_timer_off()
 	{
-	    echo "  [${_SMSG[${_RC_RV}]}] "
+		if [ -n "$_rc_timer_pid" ]; then
+			kill -TERM $_rc_timer_pid > /dev/null 2>&1
+		fi
+		unset _rc_timer_pid
 	}
-    fi
-    rc_reset() { _RC_RV=0; }
-    rc_failed()
-    {
-	if test -z "$1"; then 
-	    _RC_RV=1;
-	elif test "$1" != "0"; then 
-	    _RC_RV=$1; 
-    	fi
-	return ${_RC_RV}
-    }
-    rc_check()
-    {
-	return rc_failed $?
-    }	
-    rc_status()
-    {
-	rc_failed $?
-	if test "$1" = "-r"; then _RC_RV=0; shift; fi
-	if test "$1" = "-s"; then rc_failed 5; echo_rc; rc_failed 3; shift; fi
-	if test "$1" = "-u"; then rc_failed ${_RC_UNUSED}; echo_rc; rc_failed 3; shift; fi
-	if test "$1" = "-v"; then echo_rc; shift; fi
-	if test "$1" = "-r"; then _RC_RV=0; shift; fi
-	return ${_RC_RV}
-    }
-    rc_exit() { exit ${_RC_RV}; }
-    rc_active() 
-    {
-	if test -z "$RUNLEVEL"; then read RUNLEVEL REST < <(/sbin/runlevel); fi
-	if test -e /etc/init.d/S[0-9][0-9]${1}; then return 0; fi
-	return 1
-    }
-fi
-
-if ! which usleep >&/dev/null
-then
-  usleep()
-  {
-    if [ -n "$1" ]
-    then
-      sleep $(( $1 / 1000000 ))
-    fi
-  }
 fi
 
-# Reset status of this service
-rc_reset
+xendomains_abort()
+{
+	echo -n "xendomains "
+	rc_failed $1
+	rc_status -v
+	rc_exit
+}
 
-##
-# Returns 0 (success) if the given parameter names a directory, and that
-# directory is not empty.
-#
-contains_something()
+check()
 {
-  if [ -d "$1" ] && [ `/bin/ls $1 | wc -l` -gt 0 ]
-  then
-    return 0
-  else
-    return 1
-  fi
-}
-
-# read name from xen config file
-rdname()
-{
-    NM=$($CMD create --quiet --dryrun --defconfig "$1" |
-         sed -n 's/^.*(name \(.*\))$/\1/p')
-}
-
-rdnames()
-{
-    NAMES=
-    if ! contains_something "$XENDOMAINS_AUTO"
-    then 
-	return
-    fi
-    for dom in $XENDOMAINS_AUTO/*; do
-	rdname $dom
-	if test -z $NAMES; then 
-	    NAMES=$NM; 
+	XEND=`pidof -x /usr/sbin/xend`
+	if [ -z "$XEND" ]; then
+		xm_cmd="xl -f"
+		XEND="xl"
 	else
-	    NAMES="$NAMES|$NM"
+		xm_cmd="xm"
+	fi
+	if [ "$1" = status ]; then
+		if [ ! -e /proc/xen/capabilities ] || [ ! -r "$XENDOM_CONFIG" ] || [ -z "$XEND" ]; then
+			xendomains_abort 3
+		fi
+	else
+		if [ `id -u` != 0 ]; then
+			xendomains_abort 4
+		fi
+		if [ ! -e /proc/xen/capabilities ] || [ -z "$XEND" ] ||
+		     ! grep control_d /proc/xen/capabilities >/dev/null 2>&1; then
+			if [ "$1" = stop ] ||
+			   [ "$1" = restart ]; then
+				xendomains_abort 0
+			else
+				xendomains_abort 6
+			fi
+		fi
+		if [ ! -r "$XENDOM_CONFIG" ]; then
+			xendomains_abort 6
+		fi
 	fi
-    done
 }
 
-LIST_GREP='(domain\|(domid\|(name\|^    {$\|"name":\|"domid":'
+dir_contains_something()
+{
+        [ -d "$1" ] || return 1
+	local dirfiles=( "$1"/* )
+	[ ${#dirfiles[@]} != 0 ]
+}
+
+get_name_from_cfg()
+{
+	if grep -q "^name" "$1";then
+		NM=`grep '^name[	 ]*=' "$1" | sed -e 's/^name[	 ]*=[	 ]*['\''"]\([^'\''"]*\)['\''"].*$/\1/'`
+	elif grep -q "(name " "$1";then
+		NM=`grep '(name ' "$1" | sed -e 's/^ *//' | cut -d " " -f 2 | sed -e 's/)//'`
+	fi
+}
+
+running_auto_names()
+{
+	unset AUTONAMES[@]
+	if ! dir_contains_something "$XENDOMAINS_AUTO"; then
+		return
+	fi
+	for dom in "$XENDOMAINS_AUTO"/*; do
+		get_name_from_cfg "$dom"
+		AUTONAMES+=("$NM")
+	done
+}
+
 parseln()
 {
-    if [[ "$1" =~ '(domain' ]] || [[ "$1" = "{" ]]; then
-        name=;id=
-    elif [[ "$1" =~ '(name' ]]; then
-        name=$(echo $1 | sed -e 's/^.*(name \(.*\))$/\1/')
-    elif [[ "$1" =~ '(domid' ]]; then
-        id=$(echo $1 | sed -e 's/^.*(domid \(.*\))$/\1/')
-    elif [[ "$1" =~ '"name":' ]]; then
-        name=$(echo $1 | sed -e 's/^.*"name": "\(.*\)",$/\1/')
-    elif [[ "$1" =~ '"domid":' ]]; then
-        id=$(echo $1 | sed -e 's/^.*"domid": \(.*\),$/\1/')
-    fi
-
-    [ -n "$name" -a -n "$id" ] && return 0 || return 1
-}
-
-is_running()
-{
-    rdname $1
-    RC=1
-    name=;id=
-    while read LN; do
-	parseln "$LN" || continue
-	if test $id = 0; then continue; fi
-	case $name in 
-	    ($NM)
-		RC=0
-		;;
-	esac
-    done < <($CMD list -l | grep "$LIST_GREP")
-    return $RC
-}
-
-start() 
-{
-    if [ -f $LOCKFILE ]; then 
-	echo -e "xendomains already running (lockfile exists)"
-	return; 
-    fi
-
-    saved_domains=" "
-    if [ "$XENDOMAINS_RESTORE" = "true" ] &&
-       contains_something "$XENDOMAINS_SAVE"
-    then
-	mkdir -p $(dirname "$LOCKFILE")
-	touch $LOCKFILE
-	echo -n "Restoring Xen domains:"
-	saved_domains=`ls $XENDOMAINS_SAVE`
-        for dom in $XENDOMAINS_SAVE/*; do
-            if [ -f $dom ] ; then
-                HEADER=`head -c 16 $dom | head -n 1 2> /dev/null`
-                if [ "$HEADER" = "$HEADCOMP" ]; then
-                    echo -n " ${dom##*/}"
-                    XMR=`$CMD restore $dom 2>&1 1>/dev/null`
-                    #$CMD restore $dom
-                    if [ $? -ne 0 ]; then
-                        echo -e "\nAn error occurred while restoring domain ${dom##*/}:\n$XMR"
-                        rc_failed $?
-                        echo -e '!'
-                    else
-                        # mv $dom ${dom%/*}/.${dom##*/}
-                        rm $dom
-                    fi
-                fi
-            fi
-        done
-	echo -e
-    fi
-
-    if contains_something "$XENDOMAINS_AUTO"
-    then
-	touch $LOCKFILE
-	echo -n "Starting auto Xen domains:"
-	# We expect config scripts for auto starting domains to be in
-	# XENDOMAINS_AUTO - they could just be symlinks to files elsewhere
-
-	# Create all domains with config files in XENDOMAINS_AUTO.
-	# TODO: We should record which domain name belongs 
-	# so we have the option to selectively shut down / migrate later
-	# If a domain statefile from $XENDOMAINS_SAVE matches a domain name
-	# in $XENDOMAINS_AUTO, do not try to start that domain; if it didn't 
-	# restore correctly it requires administrative attention.
-	for dom in $XENDOMAINS_AUTO/*; do
-	    echo -n " ${dom##*/}"
-	    shortdom=$(echo $dom | sed -n 's/^.*\/\(.*\)$/\1/p')
-	    echo $saved_domains | grep -w $shortdom > /dev/null
-	    if [ $? -eq 0 ] || is_running $dom; then
-		echo -n "(skip)"
-	    else
-		XMC=`$CMD create --quiet --defconfig $dom`
-		if [ $? -ne 0 ]; then
-		    echo -e "\nAn error occurred while creating domain ${dom##*/}: $XMC\n"
-		    rc_failed $?
-		    echo -e '!'
-		else
-		    usleep $XENDOMAINS_CREATE_USLEEP
+	name=${1:0:$((${#1}-36))}
+	name=${name%% *}
+	rest="${1: -36}"
+	id=${rest:0:4}
+	id=`echo $id`
+	mem=${rest:4:6}
+	mem=`echo $mem`
+	vcpu=${rest:10:6}
+	vcpu=`echo $vcpu`
+	state=${rest:16:11}
+	state=`echo $state`
+	tm=${rest:27}
+	tm=`echo $tm`
+}
+
+xm_list()
+{
+	TERM=vt100 ${xm_cmd} list | grep -v '^Name *ID'
+}
+
+is_cfg_running()
+{
+	get_name_from_cfg "$1"
+	while read LN; do
+		parseln "$LN"
+		[ "$id" = 0 ] && continue
+		if [ "$name" = "$NM" ]; then
+			[ -z "$state" ] && return 1
+			return 0
 		fi
-	    fi
-	done
-    fi
+	done < <(xm_list)
+	return 1
+}
+
+start()
+{
+	if [ -f "$LOCKFILE" ]; then
+		echo -n "xendomains already running (lockfile exists)"
+		rc_reset
+		rc_status -v
+		return 0
+	fi
+
+	local printed=0
+
+	if [ "$XENDOMAINS_RESTORE" = "true" ] &&
+	   dir_contains_something "$XENDOMAINS_SAVE"; then
+		mkdir -p $(dirname "$LOCKFILE")
+		touch "$LOCKFILE"
+		echo "Restoring saved Xen domains"
+		printed=1
+		for dom in "$XENDOMAINS_SAVE"/*; do
+			echo -n "	${dom##*/}: "
+			${xm_cmd} restore "$dom" >/dev/null 2>&1
+			if [ $? -ne 0 ]; then
+				rc_failed
+			else
+				rc_reset
+				rm -f "$dom"
+			fi
+			rc_status -v
+		done
+	fi
+
+	if dir_contains_something "$XENDOMAINS_AUTO"; then
+		touch "$LOCKFILE"
+		echo "Starting auto Xen domains"
+		printed=1
+		for dom in "$XENDOMAINS_AUTO"/*; do
+			echo -n "	${dom##*/}: "
+			if is_cfg_running "$dom"; then
+				rc_status -s
+			else
+				if grep -q "^name" "$dom";then
+					${xm_cmd} create --quiet --defconfig "$dom"
+				elif grep -q "(name .*" "$dom";then
+					${xm_cmd} create --quiet --config "$dom"
+				fi
+				if [ $? -ne 0 ]; then
+				    rc_failed
+				else
+				    usleep $XENDOMAINS_CREATE_USLEEP
+				    rc_reset
+				fi
+				rc_status -v
+			fi
+		done
+	fi
+
+	if [ $printed -eq 0 ]; then
+		echo -n "Starting xendomains"
+		rc_failed 6  # not configured
+		rc_status -v
+	fi
+}
+
+is_zombie_state()
+{
+	[ "$1" = "-b---d" ] || [ "$1" = "-----d" ]
+}
+
+any_non_zombies()
+{
+	while read LN; do
+		parseln "$LN"
+		[ "$id" = 0 ] && continue
+		[ -z "$state" ] && continue
+		is_zombie_state "$state" || return 0
+	done < <(xm_list)
+	return 1
 }
 
-all_zombies()
+migrate_with_watchdog()
 {
-    name=;id=
-    while read LN; do
-	parseln "$LN" || continue
-	if test $id = 0; then continue; fi
-	if test "$state" != "-b---d" -a "$state" != "-----d"; then
-	    return 1;
-	fi
-    done < <($CMD list -l | grep "$LIST_GREP")
-    return 0
-}
-
-# Wait for max $XENDOMAINS_STOP_MAXWAIT for $CMD $1 to finish;
-# if it has not exited by that time kill it, so the init script will
-# succeed within a finite amount of time; if $2 is nonnull, it will
-# kill the command as well as soon as no domain (except for zombies)
-# are left (used for shutdown --all). Third parameter, if any, suppresses
-# output of dots per working state (formatting issues)
-watchdog_xencmd()
-{
-    if test -z "$XENDOMAINS_STOP_MAXWAIT" -o "$XENDOMAINS_STOP_MAXWAIT" = "0"; then
-	exit
-    fi
-
-    usleep 20000
-    for no in `seq 0 $XENDOMAINS_STOP_MAXWAIT`; do
-	# exit if $CMD save/migrate/shutdown is finished
-	PSAX=`ps axlw | grep "$CMD $1" | grep -v grep`
-	if test -z "$PSAX"; then exit; fi
-	if ! test -n "$3"; then echo -n '.'; fi
-	sleep 1
-	# go to kill immediately if there's only zombies left
-	if all_zombies && test -n "$2"; then break; fi
-    done
-    sleep 1
-    read PSF PSUID PSPID PSPPID < <(echo "$PSAX")
-    # kill $CMD $1
-    kill $PSPID >/dev/null 2>&1
-    
-    echo -e .
+	(${xm_cmd} migrate "$@" ; echo $? > "$RETCODE_FILE") >/dev/null 2>&1 &
+	watchdog_xm $!
+}
+
+save_with_watchdog()
+{
+	(${xm_cmd} save "$@" ; echo $? > "$RETCODE_FILE") >/dev/null 2>&1 &
+	watchdog_xm $!
+}
+
+shutdown_with_watchdog()
+{
+	(${xm_cmd} shutdown -w "$@" ; echo $? > "$RETCODE_FILE") >/dev/null 2>&1 &
+	watchdog_xm $!
+}
+
+get_return_code()
+{
+	local RC=127
+	[ -r "$RETCODE_FILE" ] && RC=`head -c10 "$RETCODE_FILE"`
+	rm -f "$RETCODE_FILE"
+	return $RC
+}
+
+#  $1:  The PID to wait on.
+watchdog_xm()
+{
+	local col=$((COLUMNS-11))
+	if [ -z "$XENDOMAINS_STOP_MAXWAIT" ] || [ "$XENDOMAINS_STOP_MAXWAIT" = "0" ]; then
+		wait $1 >/dev/null 2>&1
+		get_return_code
+		return
+	fi
+
+	rc_timer_on $XENDOMAINS_STOP_MAXWAIT $col
+	while true; do
+		# Prefer "jobs" over "ps":  faster and no false positives
+		pid=`jobs -l | grep " $1 Running"`
+		if [ -z "$pid" ]; then
+			break
+		fi
+		pid=`jobs -l | grep " $_rc_timer_pid Running"`
+		if [ -z "$pid" ]; then
+			disown $1  # To avoid the "Terminated..." message
+			kill $1 >/dev/null 2>&1
+		fi
+		sleep 1
+	done
+	rc_timer_off
+	if [ $smart_term -ne 0 ]; then
+		echo -en "\015${esc}[${col}C      "
+	fi
+	get_return_code
 }
 
 stop()
 {
-    exec 3>&2 2> /dev/null
-    
-    # Collect list of domains to shut down
-    if test "$XENDOMAINS_AUTO_ONLY" = "true"; then
-	rdnames
-    fi
-    echo -n "Shutting down Xen domains:"
-    name=;id=
-    while read LN; do
-	parseln "$LN" || continue
-	if test $id = 0; then continue; fi
-	echo -n " $name"
-	if test "$XENDOMAINS_AUTO_ONLY" = "true"; then
-	    eval "
-	    case \"\$name\" in
-		($NAMES)
-		    # nothing
-		    ;;
-		(*)
-		    echo -e '(skip)'
-		    continue
-		    ;;
-	    esac
-	    "
-	fi
-	# XENDOMAINS_SYSRQ chould be something like just "s" 
-	# or "s e i u" or even "s e s i u o"
-	# for the latter, you should set XENDOMAINS_USLEEP to 1200000 or so
-	if test -n "$XENDOMAINS_SYSRQ"; then
-	    for sysrq in $XENDOMAINS_SYSRQ; do
-		echo -n "(SR-$sysrq)"
-		XMR=`$CMD sysrq $id $sysrq 2>&1 1>/dev/null`
-		if test $? -ne 0; then
-		    echo -e "\nAn error occurred while doing sysrq on domain:\n$XMR\n"
-		    rc_failed $?
-		    echo -n '!'
-		fi
-		# usleep just ignores empty arg
-		usleep $XENDOMAINS_USLEEP
-	    done
-	fi
-	if test "$state" = "-b---d" -o "$state" = "-----d"; then
-	    echo -n "(zomb)"
-	    continue
-	fi
-	if test -n "$XENDOMAINS_MIGRATE"; then
-	    echo -n "(migr)"
-	    watchdog_xencmd migrate &
-	    WDOG_PID=$!
-	    XMR=`$CMD migrate $id $XENDOMAINS_MIGRATE 2>&1 1>/dev/null`
-	    if test $? -ne 0; then
-		echo -e "\nAn error occurred while migrating domain:\n$XMR\n"
-		rc_failed $?
-		echo -e '!'
-
-		kill $WDOG_PID >/dev/null 2>&1
-	    else
-		kill $WDOG_PID >/dev/null 2>&1
-		
-		echo -e .
-		usleep 1000
-		continue
-	    fi
-	fi
-	if test -n "$XENDOMAINS_SAVE"; then
-	    echo -n "(save)"
-	    watchdog_xencmd save &
-	    WDOG_PID=$!
-	    mkdir -p "$XENDOMAINS_SAVE"
-	    XMR=`$CMD save $id $XENDOMAINS_SAVE/$name 2>&1 1>/dev/null`
-	    if test $? -ne 0; then
-		echo -e "\nAn error occurred while saving domain:\n$XMR\n"
-		rc_failed $?
-		echo -e '!'
-		kill $WDOG_PID >/dev/null 2>&1
-	    else
-		kill $WDOG_PID >/dev/null 2>&1
-		echo -e .
-		usleep 1000
-		continue
-	    fi
-	fi
-	if test -n "$XENDOMAINS_SHUTDOWN"; then
-	    # XENDOMAINS_SHUTDOWN should be "--wait"
-	    echo -n "(shut)"
-	    watchdog_xencmd shutdown &
-	    WDOG_PID=$!
-	    XMR=`$CMD shutdown $XENDOMAINS_SHUTDOWN $id 2>&1 1>/dev/null`
-	    if test $? -ne 0; then
-		echo -e "\nAn error occurred while shutting down domain:\n$XMR\n"
-		rc_failed $?
-		echo -e '!'
-	    fi
-	    kill $WDOG_PID >/dev/null 2>&1
-	fi
-    done < <($CMD list -l | grep "$LIST_GREP")
-
-    # NB. this shuts down ALL Xen domains (politely), not just the ones in
-    # AUTODIR/*
-    # This is because it's easier to do ;-) but arguably if this script is run
-    # on system shutdown then it's also the right thing to do.
-    if ! all_zombies && test -n "$XENDOMAINS_SHUTDOWN_ALL"; then
-	# XENDOMAINS_SHUTDOWN_ALL should be "--all --wait"
-	echo -n " SHUTDOWN_ALL "
-	watchdog_xencmd shutdown 1 false &
-	WDOG_PID=$!
-	XMR=`$CMD shutdown $XENDOMAINS_SHUTDOWN_ALL 2>&1 1>/dev/null`
-	if test $? -ne 0; then
-	    echo -e "\nAn error occurred while shutting down all domains: $XMR\n"
-	    rc_failed $?
-	    echo -e '!'
-	fi
-	kill $WDOG_PID >/dev/null 2>&1
-    fi
-
-    # Unconditionally delete lock file
-    rm -f $LOCKFILE
-    
-    exec 2>&3
+	echo "Shutting down Xen domains"
+	if [ "$XENDOMAINS_AUTO_ONLY" = "true" ]; then
+		running_auto_names
+	fi
+	local printed=0
+	while read LN; do
+		parseln "$LN"
+		[ "$id" = 0 ] && continue
+		[ -z "$state" ] && continue
+		printed=1
+		if [ "$XENDOMAINS_AUTO_ONLY" = "true" ]; then
+			is_auto_domain=0
+			for n in "${AUTONAMES[@]}"; do
+				if [ "$name" = "$n" ]; then
+					is_auto_domain=1
+					break
+				fi
+			done
+			if [ $is_auto_domain -eq 0 ]; then
+				echo -n "	$name: "
+				rc_status -s
+				continue
+			fi
+		fi
+		if [ -n "$XENDOMAINS_SYSRQ" ]; then
+			for sysrq in $XENDOMAINS_SYSRQ; do
+				echo -n "	$name: "
+				echo -n "sending sysrq '$sysrq'... "
+				${xm_cmd} sysrq $id $sysrq
+				if [ $? -ne 0 ]; then
+					rc_failed
+				else
+					rc_reset
+				fi
+				rc_status -v
+				# usleep just ignores empty arg
+				usleep $XENDOMAINS_USLEEP
+			done
+		fi
+		if is_zombie_state "$state"; then
+			echo -n "	$name: "
+			echo -n "destroying zombie... "
+			${xm_cmd} destroy $id
+			rc_reset
+			rc_status -v
+			continue
+		fi
+		if [ -n "$XENDOMAINS_MIGRATE" ]; then
+			echo -n "	$name: "
+			echo -n "migrating... "
+			migrate_with_watchdog $id "$XENDOMAINS_MIGRATE"
+			if [ $? -ne 0 ]; then
+				rc_failed
+				rc_status -v
+			else
+				rc_reset
+				rc_status -v
+				continue
+			fi
+		fi
+		if [ -n "$XENDOMAINS_SAVE" ]; then
+			echo -n "	$name: "
+			echo -n "saving... "
+			save_with_watchdog $id "$XENDOMAINS_SAVE/$name"
+			if [ $? -ne 0 ]; then
+				rm -f "$XENDOMAINS_SAVE/$name"
+				rc_failed
+				rc_status -v
+			else
+				rc_reset
+				rc_status -v
+				continue
+			fi
+		fi
+		if [ -n "$XENDOMAINS_SHUTDOWN" ]; then
+			echo -n "	$name: "
+			echo -n "shutting down... "
+			shutdown_with_watchdog $id $XENDOMAINS_SHUTDOWN
+			if [ $? -ne 0 ]; then
+				rc_failed
+			else
+				rc_reset
+			fi
+			rc_status -v
+		fi
+	done < <(xm_list)
+
+	if [ -n "$XENDOMAINS_SHUTDOWN_ALL" ] && any_non_zombies ; then
+		echo -n "	others: shutting down... "
+		shutdown_with_watchdog $XENDOMAINS_SHUTDOWN_ALL
+		if [ $? -ne 0 ]; then
+			rc_failed
+		else
+			rc_reset
+		fi
+		rc_status -v
+	fi
+
+	if [ $printed -eq 0 ]; then
+		echo -e "${rc_done_up}"
+	fi
+
+	# Unconditionally delete lock file
+	rm -f "$LOCKFILE"
 }
 
 check_domain_up()
 {
-    name=;id=
-    while read LN; do
-	parseln "$LN" || continue
-	if test $id = 0; then continue; fi
-	case $name in 
-	    ($1)
-		return 0
-		;;
-	esac
-    done < <($CMD list -l | grep "$LIST_GREP")
-    return 1
-}
-
-check_all_auto_domains_up()
-{
-    if ! contains_something "$XENDOMAINS_AUTO"
-    then
-      return 0
-    fi
-    missing=
-    for nm in $XENDOMAINS_AUTO/*; do
-	rdname $nm
-	found=0
-	if check_domain_up "$NM"; then 
-	    echo -n " $name"
-	else 
-	    missing="$missing $NM"
-	fi
-    done
-    if test -n "$missing"; then
-	echo -n " MISS AUTO:$missing"
+	while read LN; do
+		parseln "$LN"
+		[ "$id" = 0 ] && continue
+		if [ "$name" = "$1" ]; then
+			[ -z "$state" ] && return 1
+			return 0
+		fi
+	done < <(xm_list)
 	return 1
-    fi
-    return 0
 }
 
-check_all_saved_domains_up()
+check_all_domains_up()
 {
-    if ! contains_something "$XENDOMAINS_SAVE" 
-    then
-      return 0
-    fi
-    missing=`/bin/ls $XENDOMAINS_SAVE`
-    echo -n " MISS SAVED: " $missing
-    return 1
+	any_auto=0
+	any_save=0
+	dir_contains_something "$XENDOMAINS_AUTO" && any_auto=1
+	dir_contains_something "$XENDOMAINS_SAVE" && any_save=1
+	if [ $any_auto -eq 0 ] && [ $any_save -eq 0 ]; then
+		rc_reset
+		rc_status -v
+		return
+	fi
+	echo
+	if [ $any_auto -ne 0 ]; then
+		for nm in "$XENDOMAINS_AUTO"/*; do
+			get_name_from_cfg "$nm"
+			echo -n "	$nm: "
+			if check_domain_up "$NM"; then
+				rc_reset
+			else
+				rc_failed 2
+			fi
+			rc_status -v
+		done
+	fi
+	if [ $any_save -ne 0 ]; then
+		for nm in "$XENDOMAINS_SAVE"/*; do
+			echo -n "	$nm: "
+			rc_failed 3
+			rc_status -v
+		done
+	fi
 }
 
 # This does NOT necessarily restart all running domains: instead it
 # stops all running domains and then boots all the domains specified in
 # AUTODIR.  If other domains have been started manually then they will
 # not get restarted.
-# Commented out to avoid confusion!
-
 restart()
 {
-    stop
-    start
-}
-
-reload()
-{
-    restart
+	"$0" stop
+	start
 }
 
-
 case "$1" in
-    start)
+ start)
+	check $1
 	start
-	rc_status
-	if test -f $LOCKFILE; then rc_status -v; fi
 	;;
 
-    stop)
+ stop)
+	check $1
 	stop
-	rc_status -v
 	;;
 
-    restart)
+ restart|reload)
+	check $1
 	restart
 	;;
-    reload)
-	reload
+
+ try-restart)
+	check $1
+	"$0" status
+	if [ $? = 0 ]; then
+		"$0" restart
+	else
+		rc_reset
+		rc_status -v
+	fi
 	;;
 
-    status)
-	echo -n "Checking for xendomains:" 
-	if test ! -f $LOCKFILE; then 
-	    rc_failed 3
+ status)
+	check $1
+	echo -n "Checking status of Xen domains"
+	if [ ! -f "$LOCKFILE" ]; then
+		rc_failed 3
+		rc_status -v
 	else
-	    check_all_auto_domains_up
-	    rc_status
-	    check_all_saved_domains_up
-	    rc_status
+		check_all_domains_up
 	fi
-	rc_status -v
 	;;
 
-    *)
-	echo "Usage: $0 {start|stop|restart|reload|status}"
-	rc_failed 3
-	rc_status -v
+ *)
+	echo "Usage: $0 {start|stop|restart|try-restart|reload|status}"
+	rc_failed 2
 	;;
 esac
 
 rc_exit
+
diff -Naur xen/tools/hotplug/Linux/init.d/xendomains.orig xen-a/tools/hotplug/Linux/init.d/xendomains.orig
--- xen/tools/hotplug/Linux/init.d/xendomains.orig	1969-12-31 17:00:00.000000000 -0700
+++ xen-a/tools/hotplug/Linux/init.d/xendomains.orig	2013-07-13 21:29:10.732060484 -0600
@@ -0,0 +1,585 @@
+#!/bin/bash
+#
+# /etc/init.d/xendomains
+# Start / stop domains automatically when domain 0 boots / shuts down.
+#
+# chkconfig: 345 99 00
+# description: Start / stop Xen domains.
+#
+# This script offers fairly basic functionality.  It should work on Redhat
+# but also on LSB-compliant SuSE releases and on Debian with the LSB package
+# installed.  (LSB is the Linux Standard Base)
+#
+# Based on the example in the "Designing High Quality Integrated Linux
+# Applications HOWTO" by Avi Alkalay
+# <http://www.tldp.org/HOWTO/HighQuality-Apps-HOWTO/>
+#
+### BEGIN INIT INFO
+# Provides:          xendomains
+# Required-Start:    $syslog $remote_fs xenstored xenconsoled
+# Should-Start:      xend
+# Required-Stop:     $syslog $remote_fs xenstored xenconsoled
+# Should-Stop:       xend
+# Default-Start:     2 3 5
+# Default-Stop:      0 1 6
+# Short-Description: Start/stop secondary xen domains
+# Description:       Start / stop domains automatically when domain 0 
+#                    boots / shuts down.
+### END INIT INFO
+
+. /etc/xen/scripts/hotplugpath.sh
+
+CMD=${SBINDIR}/xm
+HEADCOMP="LinuxGuestRecord"
+$CMD list &> /dev/null
+if test $? -ne 0
+then
+	CMD=${SBINDIR}/xl
+	HEADCOMP="Xen saved domain"
+fi
+
+$CMD list &> /dev/null
+if test $? -ne 0
+then
+	exit 0;
+fi
+
+# Correct exit code would probably be 5, but it's enough 
+# if xend complains if we're not running as privileged domain
+if ! [ -e /proc/xen/privcmd ]; then
+	exit 0
+fi
+
+# See docs/misc/distro_mapping.txt
+if [ -d /var/lock/subsys ]; then
+	LOCKFILE=/var/lock/subsys/xendomains
+else
+	LOCKFILE=/var/lock/xendomains
+fi
+
+if [ -d /etc/sysconfig ]; then
+	XENDOM_CONFIG=/etc/sysconfig/xendomains
+else
+	XENDOM_CONFIG=/etc/default/xendomains
+fi
+
+test -r $XENDOM_CONFIG || { echo "$XENDOM_CONFIG not existing";
+	if [ "$1" = "stop" ]; then exit 0;
+	else exit 6; fi; }
+
+. $XENDOM_CONFIG
+
+# Use the SUSE rc_ init script functions;
+# emulate them on LSB, RH and other systems
+if test -e /etc/rc.status; then
+    # SUSE rc script library
+    . /etc/rc.status
+else    
+    _cmd=$1
+    declare -a _SMSG
+    if test "${_cmd}" = "status"; then
+	_SMSG=(running dead dead unused unknown)
+	_RC_UNUSED=3
+    else
+	_SMSG=(done failed failed missed failed skipped unused failed failed)
+	_RC_UNUSED=6
+    fi
+    if test -e /etc/init.d/functions; then
+	# REDHAT
+	. /etc/init.d/functions
+	echo_rc()
+	{
+	    #echo -n "  [${_SMSG[${_RC_RV}]}] "
+	    if test ${_RC_RV} = 0; then
+		success "  [${_SMSG[${_RC_RV}]}] "
+	    else
+		failure "  [${_SMSG[${_RC_RV}]}] "
+	    fi
+	}
+    elif test -e /lib/lsb/init-functions; then
+	# LSB    
+    	. /lib/lsb/init-functions
+        if alias log_success_msg >/dev/null 2>/dev/null; then
+	  echo_rc()
+	  {
+	       echo "  [${_SMSG[${_RC_RV}]}] "
+	  }
+        else
+	  echo_rc()
+	  {
+	    if test ${_RC_RV} = 0; then
+		log_success_msg "  [${_SMSG[${_RC_RV}]}] "
+	    else
+		log_failure_msg "  [${_SMSG[${_RC_RV}]}] "
+	    fi
+	  }
+        fi
+    else    
+	# emulate it
+	echo_rc()
+	{
+	    echo "  [${_SMSG[${_RC_RV}]}] "
+	}
+    fi
+    rc_reset() { _RC_RV=0; }
+    rc_failed()
+    {
+	if test -z "$1"; then 
+	    _RC_RV=1;
+	elif test "$1" != "0"; then 
+	    _RC_RV=$1; 
+    	fi
+	return ${_RC_RV}
+    }
+    rc_check()
+    {
+	return rc_failed $?
+    }	
+    rc_status()
+    {
+	rc_failed $?
+	if test "$1" = "-r"; then _RC_RV=0; shift; fi
+	if test "$1" = "-s"; then rc_failed 5; echo_rc; rc_failed 3; shift; fi
+	if test "$1" = "-u"; then rc_failed ${_RC_UNUSED}; echo_rc; rc_failed 3; shift; fi
+	if test "$1" = "-v"; then echo_rc; shift; fi
+	if test "$1" = "-r"; then _RC_RV=0; shift; fi
+	return ${_RC_RV}
+    }
+    rc_exit() { exit ${_RC_RV}; }
+    rc_active() 
+    {
+	if test -z "$RUNLEVEL"; then read RUNLEVEL REST < <(/sbin/runlevel); fi
+	if test -e /etc/init.d/S[0-9][0-9]${1}; then return 0; fi
+	return 1
+    }
+fi
+
+if ! which usleep >&/dev/null
+then
+  usleep()
+  {
+    if [ -n "$1" ]
+    then
+      sleep $(( $1 / 1000000 ))
+    fi
+  }
+fi
+
+# Reset status of this service
+rc_reset
+
+##
+# Returns 0 (success) if the given parameter names a directory, and that
+# directory is not empty.
+#
+contains_something()
+{
+  if [ -d "$1" ] && [ `/bin/ls $1 | wc -l` -gt 0 ]
+  then
+    return 0
+  else
+    return 1
+  fi
+}
+
+# read name from xen config file
+rdname()
+{
+    NM=$($CMD create --quiet --dryrun --defconfig "$1" |
+         sed -n 's/^.*(name \(.*\))$/\1/p')
+}
+
+rdnames()
+{
+    NAMES=
+    if ! contains_something "$XENDOMAINS_AUTO"
+    then 
+	return
+    fi
+    for dom in $XENDOMAINS_AUTO/*; do
+	rdname $dom
+	if test -z $NAMES; then 
+	    NAMES=$NM; 
+	else
+	    NAMES="$NAMES|$NM"
+	fi
+    done
+}
+
+LIST_GREP='(domain\|(domid\|(name\|^    {$\|"name":\|"domid":'
+parseln()
+{
+    if [[ "$1" =~ '(domain' ]] || [[ "$1" = "{" ]]; then
+        name=;id=
+    elif [[ "$1" =~ '(name' ]]; then
+        name=$(echo $1 | sed -e 's/^.*(name \(.*\))$/\1/')
+    elif [[ "$1" =~ '(domid' ]]; then
+        id=$(echo $1 | sed -e 's/^.*(domid \(.*\))$/\1/')
+    elif [[ "$1" =~ '"name":' ]]; then
+        name=$(echo $1 | sed -e 's/^.*"name": "\(.*\)",$/\1/')
+    elif [[ "$1" =~ '"domid":' ]]; then
+        id=$(echo $1 | sed -e 's/^.*"domid": \(.*\),$/\1/')
+    fi
+
+    [ -n "$name" -a -n "$id" ] && return 0 || return 1
+}
+
+is_running()
+{
+    rdname $1
+    RC=1
+    name=;id=
+    while read LN; do
+	parseln "$LN" || continue
+	if test $id = 0; then continue; fi
+	case $name in 
+	    ($NM)
+		RC=0
+		;;
+	esac
+    done < <($CMD list -l | grep "$LIST_GREP")
+    return $RC
+}
+
+start() 
+{
+    if [ -f $LOCKFILE ]; then 
+	echo -e "xendomains already running (lockfile exists)"
+	return; 
+    fi
+
+    saved_domains=" "
+    if [ "$XENDOMAINS_RESTORE" = "true" ] &&
+       contains_something "$XENDOMAINS_SAVE"
+    then
+	mkdir -p $(dirname "$LOCKFILE")
+	touch $LOCKFILE
+	echo -n "Restoring Xen domains:"
+	saved_domains=`ls $XENDOMAINS_SAVE`
+        for dom in $XENDOMAINS_SAVE/*; do
+            if [ -f $dom ] ; then
+                HEADER=`head -c 16 $dom | head -n 1 2> /dev/null`
+                if [ "$HEADER" = "$HEADCOMP" ]; then
+                    echo -n " ${dom##*/}"
+                    XMR=`$CMD restore $dom 2>&1 1>/dev/null`
+                    #$CMD restore $dom
+                    if [ $? -ne 0 ]; then
+                        echo -e "\nAn error occurred while restoring domain ${dom##*/}:\n$XMR"
+                        rc_failed $?
+                        echo -e '!'
+                    else
+                        # mv $dom ${dom%/*}/.${dom##*/}
+                        rm $dom
+                    fi
+                fi
+            fi
+        done
+	echo -e
+    fi
+
+    if contains_something "$XENDOMAINS_AUTO"
+    then
+	touch $LOCKFILE
+	echo -n "Starting auto Xen domains:"
+	# We expect config scripts for auto starting domains to be in
+	# XENDOMAINS_AUTO - they could just be symlinks to files elsewhere
+
+	# Create all domains with config files in XENDOMAINS_AUTO.
+	# TODO: We should record which domain name belongs 
+	# so we have the option to selectively shut down / migrate later
+	# If a domain statefile from $XENDOMAINS_SAVE matches a domain name
+	# in $XENDOMAINS_AUTO, do not try to start that domain; if it didn't 
+	# restore correctly it requires administrative attention.
+	for dom in $XENDOMAINS_AUTO/*; do
+	    echo -n " ${dom##*/}"
+	    shortdom=$(echo $dom | sed -n 's/^.*\/\(.*\)$/\1/p')
+	    echo $saved_domains | grep -w $shortdom > /dev/null
+	    if [ $? -eq 0 ] || is_running $dom; then
+		echo -n "(skip)"
+	    else
+		XMC=`$CMD create --quiet --defconfig $dom`
+		if [ $? -ne 0 ]; then
+		    echo -e "\nAn error occurred while creating domain ${dom##*/}: $XMC\n"
+		    rc_failed $?
+		    echo -e '!'
+		else
+		    usleep $XENDOMAINS_CREATE_USLEEP
+		fi
+	    fi
+	done
+    fi
+}
+
+all_zombies()
+{
+    name=;id=
+    while read LN; do
+	parseln "$LN" || continue
+	if test $id = 0; then continue; fi
+	if test "$state" != "-b---d" -a "$state" != "-----d"; then
+	    return 1;
+	fi
+    done < <($CMD list -l | grep "$LIST_GREP")
+    return 0
+}
+
+# Wait for max $XENDOMAINS_STOP_MAXWAIT for $CMD $1 to finish;
+# if it has not exited by that time kill it, so the init script will
+# succeed within a finite amount of time; if $2 is nonnull, it will
+# kill the command as well as soon as no domain (except for zombies)
+# are left (used for shutdown --all). Third parameter, if any, suppresses
+# output of dots per working state (formatting issues)
+watchdog_xencmd()
+{
+    if test -z "$XENDOMAINS_STOP_MAXWAIT" -o "$XENDOMAINS_STOP_MAXWAIT" = "0"; then
+	exit
+    fi
+
+    usleep 20000
+    for no in `seq 0 $XENDOMAINS_STOP_MAXWAIT`; do
+	# exit if $CMD save/migrate/shutdown is finished
+	PSAX=`ps axlw | grep "$CMD $1" | grep -v grep`
+	if test -z "$PSAX"; then exit; fi
+	if ! test -n "$3"; then echo -n '.'; fi
+	sleep 1
+	# go to kill immediately if there's only zombies left
+	if all_zombies && test -n "$2"; then break; fi
+    done
+    sleep 1
+    read PSF PSUID PSPID PSPPID < <(echo "$PSAX")
+    # kill $CMD $1
+    kill $PSPID >/dev/null 2>&1
+    
+    echo -e .
+}
+
+stop()
+{
+    exec 3>&2 2> /dev/null
+    
+    # Collect list of domains to shut down
+    if test "$XENDOMAINS_AUTO_ONLY" = "true"; then
+	rdnames
+    fi
+    echo -n "Shutting down Xen domains:"
+    name=;id=
+    while read LN; do
+	parseln "$LN" || continue
+	if test $id = 0; then continue; fi
+	echo -n " $name"
+	if test "$XENDOMAINS_AUTO_ONLY" = "true"; then
+	    eval "
+	    case \"\$name\" in
+		($NAMES)
+		    # nothing
+		    ;;
+		(*)
+		    echo -e '(skip)'
+		    continue
+		    ;;
+	    esac
+	    "
+	fi
+	# XENDOMAINS_SYSRQ chould be something like just "s" 
+	# or "s e i u" or even "s e s i u o"
+	# for the latter, you should set XENDOMAINS_USLEEP to 1200000 or so
+	if test -n "$XENDOMAINS_SYSRQ"; then
+	    for sysrq in $XENDOMAINS_SYSRQ; do
+		echo -n "(SR-$sysrq)"
+		XMR=`$CMD sysrq $id $sysrq 2>&1 1>/dev/null`
+		if test $? -ne 0; then
+		    echo -e "\nAn error occurred while doing sysrq on domain:\n$XMR\n"
+		    rc_failed $?
+		    echo -n '!'
+		fi
+		# usleep just ignores empty arg
+		usleep $XENDOMAINS_USLEEP
+	    done
+	fi
+	if test "$state" = "-b---d" -o "$state" = "-----d"; then
+	    echo -n "(zomb)"
+	    continue
+	fi
+	if test -n "$XENDOMAINS_MIGRATE"; then
+	    echo -n "(migr)"
+	    watchdog_xencmd migrate &
+	    WDOG_PID=$!
+	    XMR=`$CMD migrate $id $XENDOMAINS_MIGRATE 2>&1 1>/dev/null`
+	    if test $? -ne 0; then
+		echo -e "\nAn error occurred while migrating domain:\n$XMR\n"
+		rc_failed $?
+		echo -e '!'
+
+		kill $WDOG_PID >/dev/null 2>&1
+	    else
+		kill $WDOG_PID >/dev/null 2>&1
+		
+		echo -e .
+		usleep 1000
+		continue
+	    fi
+	fi
+	if test -n "$XENDOMAINS_SAVE"; then
+	    echo -n "(save)"
+	    watchdog_xencmd save &
+	    WDOG_PID=$!
+	    mkdir -p "$XENDOMAINS_SAVE"
+	    XMR=`$CMD save $id $XENDOMAINS_SAVE/$name 2>&1 1>/dev/null`
+	    if test $? -ne 0; then
+		echo -e "\nAn error occurred while saving domain:\n$XMR\n"
+		rc_failed $?
+		echo -e '!'
+		kill $WDOG_PID >/dev/null 2>&1
+	    else
+		kill $WDOG_PID >/dev/null 2>&1
+		echo -e .
+		usleep 1000
+		continue
+	    fi
+	fi
+	if test -n "$XENDOMAINS_SHUTDOWN"; then
+	    # XENDOMAINS_SHUTDOWN should be "--wait"
+	    echo -n "(shut)"
+	    watchdog_xencmd shutdown &
+	    WDOG_PID=$!
+	    XMR=`$CMD shutdown $XENDOMAINS_SHUTDOWN $id 2>&1 1>/dev/null`
+	    if test $? -ne 0; then
+		echo -e "\nAn error occurred while shutting down domain:\n$XMR\n"
+		rc_failed $?
+		echo -e '!'
+	    fi
+	    kill $WDOG_PID >/dev/null 2>&1
+	fi
+    done < <($CMD list -l | grep "$LIST_GREP")
+
+    # NB. this shuts down ALL Xen domains (politely), not just the ones in
+    # AUTODIR/*
+    # This is because it's easier to do ;-) but arguably if this script is run
+    # on system shutdown then it's also the right thing to do.
+    if ! all_zombies && test -n "$XENDOMAINS_SHUTDOWN_ALL"; then
+	# XENDOMAINS_SHUTDOWN_ALL should be "--all --wait"
+	echo -n " SHUTDOWN_ALL "
+	watchdog_xencmd shutdown 1 false &
+	WDOG_PID=$!
+	XMR=`$CMD shutdown $XENDOMAINS_SHUTDOWN_ALL 2>&1 1>/dev/null`
+	if test $? -ne 0; then
+	    echo -e "\nAn error occurred while shutting down all domains: $XMR\n"
+	    rc_failed $?
+	    echo -e '!'
+	fi
+	kill $WDOG_PID >/dev/null 2>&1
+    fi
+
+    # Unconditionally delete lock file
+    rm -f $LOCKFILE
+    
+    exec 2>&3
+}
+
+check_domain_up()
+{
+    name=;id=
+    while read LN; do
+	parseln "$LN" || continue
+	if test $id = 0; then continue; fi
+	case $name in 
+	    ($1)
+		return 0
+		;;
+	esac
+    done < <($CMD list -l | grep "$LIST_GREP")
+    return 1
+}
+
+check_all_auto_domains_up()
+{
+    if ! contains_something "$XENDOMAINS_AUTO"
+    then
+      return 0
+    fi
+    missing=
+    for nm in $XENDOMAINS_AUTO/*; do
+	rdname $nm
+	found=0
+	if check_domain_up "$NM"; then 
+	    echo -n " $name"
+	else 
+	    missing="$missing $NM"
+	fi
+    done
+    if test -n "$missing"; then
+	echo -n " MISS AUTO:$missing"
+	return 1
+    fi
+    return 0
+}
+
+check_all_saved_domains_up()
+{
+    if ! contains_something "$XENDOMAINS_SAVE" 
+    then
+      return 0
+    fi
+    missing=`/bin/ls $XENDOMAINS_SAVE`
+    echo -n " MISS SAVED: " $missing
+    return 1
+}
+
+# This does NOT necessarily restart all running domains: instead it
+# stops all running domains and then boots all the domains specified in
+# AUTODIR.  If other domains have been started manually then they will
+# not get restarted.
+# Commented out to avoid confusion!
+
+restart()
+{
+    stop
+    start
+}
+
+reload()
+{
+    restart
+}
+
+
+case "$1" in
+    start)
+	start
+	rc_status
+	if test -f $LOCKFILE; then rc_status -v; fi
+	;;
+
+    stop)
+	stop
+	rc_status -v
+	;;
+
+    restart)
+	restart
+	;;
+    reload)
+	reload
+	;;
+
+    status)
+	echo -n "Checking for xendomains:" 
+	if test ! -f $LOCKFILE; then 
+	    rc_failed 3
+	else
+	    check_all_auto_domains_up
+	    rc_status
+	    check_all_saved_domains_up
+	    rc_status
+	fi
+	rc_status -v
+	;;
+
+    *)
+	echo "Usage: $0 {start|stop|restart|reload|status}"
+	rc_failed 3
+	rc_status -v
+	;;
+esac
+
+rc_exit
diff -Naur xen/tools/hotplug/Linux/locking.sh xen-a/tools/hotplug/Linux/locking.sh
--- xen/tools/hotplug/Linux/locking.sh	2013-07-13 21:25:38.263060484 -0600
+++ xen-a/tools/hotplug/Linux/locking.sh	2013-07-13 21:29:10.734060484 -0600
@@ -20,7 +20,7 @@
 # Serialisation
 #
 
-LOCK_BASEDIR=/var/run/xen-hotplug
+LOCK_BASEDIR=/run/xen-hotplug
 
 _setlockfd()
 {
diff -Naur xen/tools/libxl/libxl_internal.h xen-a/tools/libxl/libxl_internal.h
--- xen/tools/libxl/libxl_internal.h	2013-07-13 21:25:38.338060484 -0600
+++ xen-a/tools/libxl/libxl_internal.h	2013-07-13 21:29:10.735060484 -0600
@@ -377,7 +377,7 @@
 #define PCI_SLOT(devfn)         (((devfn) >> 3) & 0x1f)
 #define PCI_FUNC(devfn)         ((devfn) & 0x07)
 #define AUTO_PHP_SLOT          0x100
-#define XENSTORE_PID_FILE      "/var/run/xenstored.pid"
+#define XENSTORE_PID_FILE      "/run/xenstored.pid"
 
 #define PROC_PCI_NUM_RESOURCES 7
 #define PCI_BAR_IO             0x01
diff -Naur xen/tools/libxl/xl.c xen-a/tools/libxl/xl.c
--- xen/tools/libxl/xl.c	2013-07-13 21:25:38.347060484 -0600
+++ xen-a/tools/libxl/xl.c	2013-07-13 21:29:10.736060484 -0600
@@ -33,7 +33,7 @@
 #include "libxlutil.h"
 #include "xl.h"
 
-#define XEND_LOCK { "/var/lock/subsys/xend", "/var/lock/xend" }
+#define XEND_LOCK { "/run/lock/subsys/xend", "/run/lock/xend" }
 
 xentoollog_logger_stdiostream *logger;
 int dryrun_only;
diff -Naur xen/tools/misc/xenpvnetboot xen-a/tools/misc/xenpvnetboot
--- xen/tools/misc/xenpvnetboot	2013-07-13 21:25:38.361060484 -0600
+++ xen-a/tools/misc/xenpvnetboot	2013-07-13 21:29:10.737060484 -0600
@@ -194,7 +194,7 @@
                       help='Arguments pass to the kernel.')
     parser.add_option('', '--output',
                       help='Redirect output to this file instead of stdout.')
-    parser.add_option('', '--output-directory', default='/var/run/libxl',
+    parser.add_option('', '--output-directory', default='/run/libxl',
                       help='Output directory.')
     parser.add_option('', '--output-format', default='sxp',
                       help='Output format: sxp, simple or simple0.')
diff -Naur xen/tools/ocaml/libs/xs/xs.ml xen-a/tools/ocaml/libs/xs/xs.ml
--- xen/tools/ocaml/libs/xs/xs.ml	2013-07-13 21:25:38.369060484 -0600
+++ xen-a/tools/ocaml/libs/xs/xs.ml	2013-07-13 21:29:10.738060484 -0600
@@ -147,7 +147,7 @@
 	end;
 	unwatch ()
 
-let daemon_socket = "/var/run/xenstored/socket"
+let daemon_socket = "/run/xenstored/socket"
 
 (** Throws this rather than a miscellaneous Unix.connect failed *)
 exception Failed_to_connect
diff -Naur xen/tools/ocaml/xenstored/define.ml xen-a/tools/ocaml/xenstored/define.ml
--- xen/tools/ocaml/xenstored/define.ml	2013-07-13 21:25:38.371060484 -0600
+++ xen-a/tools/ocaml/xenstored/define.ml	2013-07-13 21:29:10.739060484 -0600
@@ -20,8 +20,8 @@
 let xenstored_proc_kva = "/proc/xen/xsd_kva"
 let xenstored_proc_port = "/proc/xen/xsd_port"
 
-let xs_daemon_socket = "/var/run/xenstored/socket"
-let xs_daemon_socket_ro = "/var/run/xenstored/socket_ro"
+let xs_daemon_socket = "/run/xenstored/socket"
+let xs_daemon_socket_ro = "/run/xenstored/socket_ro"
 
 let default_config_dir = "/etc/xen"
 
diff -Naur xen/tools/ocaml/xenstored/disk.ml xen-a/tools/ocaml/xenstored/disk.ml
--- xen/tools/ocaml/xenstored/disk.ml	2013-07-13 21:25:38.371060484 -0600
+++ xen-a/tools/ocaml/xenstored/disk.ml	2013-07-13 21:29:10.740060484 -0600
@@ -15,7 +15,7 @@
  *)
 
 let enable = ref false
-let xs_daemon_database = "/var/run/xenstored/db"
+let xs_daemon_database = "/run/xenstored/db"
 
 let error fmt = Logging.error "disk" fmt
 
diff -Naur xen/tools/ocaml/xenstored/oxenstored.conf xen-a/tools/ocaml/xenstored/oxenstored.conf
--- xen/tools/ocaml/xenstored/oxenstored.conf	2013-07-13 21:25:38.372060484 -0600
+++ xen-a/tools/ocaml/xenstored/oxenstored.conf	2013-07-13 21:29:10.741060484 -0600
@@ -1,7 +1,7 @@
 # default xenstored config
 
 # Where the pid file is stored
-pid-file = /var/run/xenstored.pid
+pid-file = /run/xenstored.pid
 
 # Randomly failed a transaction with EAGAIN. Used for testing Xs user
 test-eagain = false
diff -Naur xen/tools/ocaml/xenstored/xenstored.ml xen-a/tools/ocaml/xenstored/xenstored.ml
--- xen/tools/ocaml/xenstored/xenstored.ml	2013-07-13 21:25:38.375060484 -0600
+++ xen-a/tools/ocaml/xenstored/xenstored.ml	2013-07-13 21:29:10.742060484 -0600
@@ -58,7 +58,7 @@
 let sigusr1_handler store =
 	try
 		let channel = open_out_gen [ Open_wronly; Open_creat; Open_trunc; ]
-		                           0o600 "/var/run/xenstored/db.debug" in
+		                           0o600 "/run/xenstored/db.debug" in
 		finally (fun () -> Store.dump store channel)
 			(fun () -> close_out channel)
 	with _ ->
@@ -73,7 +73,7 @@
 	| Some name -> name
 	| None      -> Define.default_config_dir ^ "/oxenstored.conf"
 
-let default_pidfile = "/var/run/xenstored.pid"
+let default_pidfile = "/run/xenstored.pid"
 
 let parse_config filename =
 	let pidfile = ref default_pidfile in
@@ -254,7 +254,7 @@
 	let quit = ref false in
 
 	if cf.restart then (
-		DB.from_file store domains cons "/var/run/xenstored/db";
+		DB.from_file store domains cons "/run/xenstored/db";
 		Event.bind_dom_exc_virq eventchn
 	) else (
 		if !Disk.enable then (
@@ -280,7 +280,7 @@
 
 	Logging.init_xenstored_log();
 	if cf.activate_access_log then begin
-		let post_rotate () = DB.to_file store cons "/var/run/xenstored/db" in
+		let post_rotate () = DB.to_file store cons "/run/xenstored/db" in
 		Logging.init_access_log post_rotate
 	end;
 
@@ -389,5 +389,5 @@
 				raise exc
 	done;
 	info "stopping xenstored";
-	DB.to_file store cons "/var/run/xenstored/db";
+	DB.to_file store cons "/run/xenstored/db";
 	()
diff -Naur xen/tools/pygrub/Makefile xen-a/tools/pygrub/Makefile
--- xen/tools/pygrub/Makefile	2013-07-13 21:25:38.375060484 -0600
+++ xen-a/tools/pygrub/Makefile	2013-07-13 21:29:10.743060484 -0600
@@ -13,7 +13,7 @@
 	CC="$(CC)" CFLAGS="$(CFLAGS)" $(PYTHON) setup.py install \
 		$(PYTHON_PREFIX_ARG) --root="$(DESTDIR)" \
 		--install-scripts=$(PRIVATE_BINDIR) --force
-	$(INSTALL_DIR) $(DESTDIR)/var/run/xend/boot
+	$(INSTALL_DIR) $(DESTDIR)/run/xend/boot
 	set -e; if [ $(BINDIR) != $(PRIVATE_BINDIR) -a \
 	             "`readlink -f $(DESTDIR)/$(BINDIR)`" != \
 	             "`readlink -f $(PRIVATE_BINDIR)`" ]; then \
diff -Naur xen/tools/pygrub/src/pygrub xen-a/tools/pygrub/src/pygrub
--- xen/tools/pygrub/src/pygrub	2013-07-13 21:25:38.379060484 -0600
+++ xen-a/tools/pygrub/src/pygrub	2013-07-13 21:29:10.744060484 -0600
@@ -768,7 +768,7 @@
     debug = False
     not_really = False
     output_format = "sxp"
-    output_directory = "/var/run/xend/boot"
+    output_directory = "/run/xend/boot"
 
     # what was passed in
     incfg = { "kernel": None, "ramdisk": None, "args": "" }
diff -Naur xen/tools/python/xen/util/fileuri.py xen-a/tools/python/xen/util/fileuri.py
--- xen/tools/python/xen/util/fileuri.py	2013-07-13 21:25:38.403060484 -0600
+++ xen-a/tools/python/xen/util/fileuri.py	2013-07-13 21:29:10.745060484 -0600
@@ -81,10 +81,10 @@
     # and a flag if this file in temporary only and must be deleted
     # after starting the VM.
     def decode(encoded_data):
-        mkdir.parents("/var/run/xend/boot/", stat.S_IRWXU)
+        mkdir.parents("/run/xend/boot/", stat.S_IRWXU)
         mediatype, encoding, data_start = scheme_data.parse(encoded_data)
         fd, filename = tempfile.mkstemp(
-            prefix="data_uri_file.", dir="/var/run/xend/boot")
+            prefix="data_uri_file.", dir="/run/xend/boot")
         # Because of python 2.3 support, there is a need to nest these
         # (see http://www.python.org/doc/2.3/ref/try.html)
         try:
diff -Naur xen/tools/xenbackendd/xenbackendd.c xen-a/tools/xenbackendd/xenbackendd.c
--- xen/tools/xenbackendd/xenbackendd.c	2013-07-13 21:25:38.466060484 -0600
+++ xen-a/tools/xenbackendd/xenbackendd.c	2013-07-13 21:29:10.746060484 -0600
@@ -48,7 +48,7 @@
 #define LOG_FILE "/var/log/xen/xenbackendd.log"
 #endif
 #ifndef PID_FILE
-#define PID_FILE "/var/run/xenbackendd.pid"
+#define PID_FILE "/run/xenbackendd.pid"
 #endif
 
 
diff -Naur xen/tools/xenmon/xenbaked.c xen-a/tools/xenmon/xenbaked.c
--- xen/tools/xenmon/xenbaked.c	2013-07-13 21:25:38.467060484 -0600
+++ xen-a/tools/xenmon/xenbaked.c	2013-07-13 21:29:10.747060484 -0600
@@ -645,7 +645,7 @@
     }
 }
 
-#define SHARED_MEM_FILE "/var/run/xenq-shm"
+#define SHARED_MEM_FILE "/run/xenq-shm"
 static void alloc_qos_data(int ncpu)
 {
     int i, n, pgsize, off=0;
diff -Naur xen/tools/xenmon/xenmon.py xen-a/tools/xenmon/xenmon.py
--- xen/tools/xenmon/xenmon.py	2013-07-13 21:25:38.467060484 -0600
+++ xen-a/tools/xenmon/xenmon.py	2013-07-13 21:29:16.627060484 -0600
@@ -46,7 +46,7 @@
 QOS_DATA_SIZE = struct.calcsize(ST_QDATA)*NSAMPLES + struct.calcsize(ST_DOM_INFO)*NDOMAINS + struct.calcsize("4i")
 
 # location of mmaped file, hard coded right now
-SHM_FILE = "/var/run/xenq-shm"
+SHM_FILE = "/run/xenq-shm"
 
 # format strings
 TOTALS = 15*' ' + "%6.2f%%" + 35*' ' + "%6.2f%%"
diff -Naur xen/tools/xenstore/Makefile xen-a/tools/xenstore/Makefile
--- xen/tools/xenstore/Makefile	2013-07-13 21:25:38.475060484 -0600
+++ xen-a/tools/xenstore/Makefile	2013-07-13 21:29:16.628060484 -0600
@@ -113,7 +113,7 @@
 	$(INSTALL_DIR) $(DESTDIR)$(SBINDIR)
 	$(INSTALL_DIR) $(DESTDIR)$(INCLUDEDIR)
 	$(INSTALL_DIR) $(DESTDIR)$(INCLUDEDIR)/xenstore-compat
-	$(INSTALL_DIR) $(DESTDIR)/var/run/xenstored
+	$(INSTALL_DIR) $(DESTDIR)/run/xenstored
 	$(INSTALL_DIR) $(DESTDIR)/var/lib/xenstored
 	$(INSTALL_PROG) xenstored $(DESTDIR)$(SBINDIR)
 	$(INSTALL_PROG) xenstore-control $(DESTDIR)$(BINDIR)
diff -Naur xen/tools/xenstore/xs_lib.c xen-a/tools/xenstore/xs_lib.c
--- xen/tools/xenstore/xs_lib.c	2013-07-13 21:25:38.483060484 -0600
+++ xen-a/tools/xenstore/xs_lib.c	2013-07-13 21:29:16.628060484 -0600
@@ -36,7 +36,7 @@
 const char *xs_daemon_rundir(void)
 {
 	char *s = getenv("XENSTORED_RUNDIR");
-	return (s ? s : "/var/run/xenstored");
+	return (s ? s : "/run/xenstored");
 }
 
 static const char *xs_daemon_path(void)
